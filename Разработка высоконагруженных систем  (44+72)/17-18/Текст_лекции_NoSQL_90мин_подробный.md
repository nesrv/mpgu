# Текст лекции: NoSQL - MongoDB и OpenSearch (90 минут)
## Для лектора-программиста

---

## Введение (5 минут)

Всем привет! Сегодня у нас тема, которая реально пригодится в работе - NoSQL базы данных. Конкретно разберем MongoDB и OpenSearch. 

**Слайд 1: Титульный**

Короче, ребят, сегодня будем говорить про NoSQL. Не пугайтесь, это не значит "нет SQL" - это "Not Only SQL". То есть не только реляционные базы, но и другие подходы к хранению данных.

Мы разберем две популярные NoSQL базы:
- **MongoDB** - для хранения JSON-документов
- **OpenSearch** - для полнотекстового поиска

И самое главное - как с ними работать через Python и FastAPI. Все будет с примерами кода, которые можно сразу юзать в проектах.

---

## Часть 1: Введение в NoSQL (10 минут)

**Слайд 2: Проблемы реляционных БД**

Окей, давайте сначала разберемся, а зачем вообще эти NoSQL базы придумали? PostgreSQL же норм работает, MySQL тоже ничего. В чем проблема?

Проблемы начинаются, когда проект растет:

### 1. Вертикальное масштабирование - это боль

Представьте: у вас PostgreSQL на сервере с 16GB RAM. Все хорошо. Потом пользователей стало больше, данных больше - база тормозит. Что делать? 

Покупать сервер с 32GB RAM. Потом с 64GB. Потом с 128GB. Это называется **вертикальное масштабирование** - апгрейдим железо.

Проблемы:
- **Дорого** - сервер с 256GB RAM стоит как подержанная машина
- **Есть предел** - больше определенного размера сервер не сделаешь
- **Single point of failure** - если сервер упал, все упало

### 2. Жёсткая схема - это головная боль

В реляционных БД нужно заранее создать таблицы:

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100)
);
```

А потом приходит менеджер: "Слушай, а давай еще поле `phone` добавим". Окей:

```sql
ALTER TABLE users ADD COLUMN phone VARCHAR(20);
```

Потом: "А давай еще `address` добавим, но он должен быть JSON с городом, улицей, домом...". И начинается:

```sql
ALTER TABLE users ADD COLUMN address JSONB;
```

А потом оказывается, что у половины пользователей адреса нет, у четверти он в старом формате, у остальных - в новом. И ты сидишь пишешь миграции, которые это все чинят.

В NoSQL базах **схема гибкая** - можно в одной коллекции хранить документы с разной структурой. Добавил поле - и все, никаких миграций.

### 3. Иерархические данные - это ад

Попробуйте в реляционной БД хранить такую структуру:

```json
{
  "user": "Иван",
  "orders": [
    {
      "id": 1,
      "items": [
        {"product": "Ноутбук", "price": 50000},
        {"product": "Мышка", "price": 1000}
      ]
    }
  ]
}
```

Вам нужно создать 3 таблицы: `users`, `orders`, `order_items`. Потом делать JOIN'ы:

```sql
SELECT u.name, o.id, oi.product, oi.price
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN order_items oi ON o.id = oi.order_id
WHERE u.name = 'Иван';
```

А в MongoDB это просто один документ. Запросил - получил. Все.

### 4. Производительность при больших объёмах

Когда в таблице миллионы строк и нужно делать JOIN по нескольким таблицам - PostgreSQL начинает думать. Долго думать. Индексы помогают, но не всегда.

**Слайд 3: Что такое NoSQL?**

NoSQL = **Not Only SQL**. Это не замена реляционным БД, а дополнение.

Основные фишки:

### 1. Горизонтальное масштабирование

Вместо одного мощного сервера - куча обычных серверов. Данные распределяются между ними автоматически.

Пример: у вас 3 сервера по 16GB RAM. MongoDB автоматически распределит данные между ними. Нужно больше мощности? Добавляете 4-й сервер - MongoDB сам перебалансирует данные.

Это называется **шардинг** (sharding). Данные разбиваются на куски (шарды) и раскидываются по серверам.

### 2. Гибкая схема

Можно хранить документы с разной структурой в одной коллекции:

```javascript
// Документ 1
{
  "name": "Иван",
  "age": 25
}

// Документ 2
{
  "name": "Мария",
  "age": 30,
  "city": "Москва",  // Новое поле!
  "hobbies": ["программирование", "бег"]  // Еще одно!
}
```

MongoDB скажет: "Норм, принял". PostgreSQL скажет: "ERROR: column 'city' does not exist".

### 3. CAP-теорема

Это важная штука. CAP = Consistency, Availability, Partition tolerance.

Простыми словами:
- **Consistency** (консистентность) - все видят одинаковые данные
- **Availability** (доступность) - система всегда отвечает
- **Partition tolerance** (устойчивость к разделению) - система работает, даже если связь между серверами пропала

Теорема говорит: **можно выбрать только 2 из 3**.

Реляционные БД выбирают **CA** (консистентность + доступность). Если связь между серверами пропала - система падает.

NoSQL базы обычно выбирают **AP** (доступность + устойчивость). Если связь пропала - система работает, но данные могут быть не синхронизированы. Потом синхронизируются.

**Слайд 4: Типы NoSQL-СУБД**

NoSQL - это не одна технология, а целое семейство. Разберем основные типы:

### 1. Document Store (MongoDB, Couchbase)

Хранят JSON-подобные документы. Это самый популярный тип.

**Когда юзать**: 
- Каталог товаров (у каждого товара свои характеристики)
- Профили пользователей
- CMS (системы управления контентом)

### 2. Key-Value (Redis, Memcached)

Простейшая структура: ключ → значение. Как Python словарь, но в базе данных.

```python
cache["user:123"] = {"name": "Иван", "age": 25}
```

**Когда юзать**:
- Кеширование
- Сессии пользователей
- Очереди задач

### 3. Column Family (Cassandra, HBase)

Данные хранятся по колонкам, а не по строкам. Звучит странно, но для аналитики это быстрее.

**Когда юзать**:
- Аналитика больших данных
- Временные ряды (метрики, логи)

### 4. Graph (Neo4j, ArangoDB)

Для связанных данных. Хранит узлы (nodes) и связи (edges).

**Когда юзать**:
- Социальные сети (друзья, подписчики)
- Рекомендательные системы
- Графы знаний

### 5. Search Engine (Elasticsearch, OpenSearch)

Для полнотекстового поиска. Умеет искать по словам, с опечатками, с морфологией.

**Когда юзать**:
- Поиск по сайту
- Логирование (ELK stack)
- Аналитика в реальном времени

Сегодня мы подробно разберем **Document Store (MongoDB)** и **Search Engine (OpenSearch)**.

**Слайд 5: Когда использовать NoSQL?**

NoSQL подходит когда:

### 1. Большие объёмы неструктурированных данных

Логи, JSON от API, данные с датчиков IoT - все это неструктурированные данные. В реляционной БД их хранить неудобно.

### 2. Высокая скорость записи

Нужно писать миллионы событий в секунду? MongoDB справится. PostgreSQL - нет.

### 3. Схема данных часто меняется

Стартапы, прототипы - требования меняются каждую неделю. Гибкая схема MongoDB спасает.

### 4. Полнотекстовый поиск

Нужен поиск по тексту с морфологией, опечатками, ранжированием? OpenSearch/Elasticsearch - ваш выбор.

### 5. Аналитика в реальном времени

Нужно считать статистику на лету? OpenSearch умеет агрегации за миллисекунды.

---

## Часть 2: MongoDB (35 минут)

**Слайд 6: MongoDB**

MongoDB - это самая популярная NoSQL база данных. Название от "humongous" (огромный).

Основные фишки:

### 1. BSON формат

Данные хранятся в формате BSON (Binary JSON). Это JSON, но:
- Бинарный (быстрее парсится)
- Поддерживает дополнительные типы (Date, ObjectId, Binary)
- Компактнее

### 2. Гибкая схема

Можно хранить документы с разной структурой. Никаких миграций.

### 3. Шардинг из коробки

MongoDB сам распределяет данные по серверам. Настроил - и работает.

**Слайд 7: Архитектура MongoDB**

Давайте разберем, как MongoDB устроена внутри.

### Уровень приложения

Ваше приложение на Python, Node.js, Java - подключается к MongoDB через драйвер. Драйвер - это библиотека, которая умеет говорить с MongoDB по сети.

### MongoDB Server (mongod)

Это процесс, который крутится на сервере. Он:
- Принимает запросы от приложений
- Читает/пишет данные
- Управляет индексами
- Делает репликацию

### Query Router (mongos)

Если у вас кластер с шардингом, между приложением и серверами стоит роутер. Он:
- Принимает запрос от приложения
- Определяет, на каком сервере лежат нужные данные
- Отправляет запрос на нужный сервер
- Собирает результаты и отдает приложению

### Storage Engine

Это движок, который физически пишет данные на диск. По умолчанию используется **WiredTiger**:
- Сжимает данные (экономит место)
- Поддерживает транзакции
- Делает снапшоты для бэкапов

Есть также **In-Memory** движок - все данные в RAM, максимальная скорость. Но если сервер упал - данные потеряны.

**Слайд 8: Основные концепции**

В MongoDB иерархия такая:

```
Database (БД)
  └─ Collection (Коллекция)
       └─ Document (Документ)
            └─ Field (Поле)
```

Аналогия с реляционными БД:
- **Database** ≈ Database
- **Collection** ≈ Table
- **Document** ≈ Row
- **Field** ≈ Column

Но есть важное отличие: **документ - это JSON-объект**, а не строка в таблице.

### Поле _id

Каждый документ имеет поле `_id` - уникальный идентификатор. Если вы его не укажете, MongoDB создаст автоматически.

```javascript
{
  "_id": ObjectId("507f1f77bcf86cd799439011"),
  "name": "Иван",
  "age": 25
}
```

`ObjectId` - это специальный тип, 12-байтовое значение:
- 4 байта - timestamp (когда создан)
- 5 байт - случайное значение
- 3 байта - счетчик

Благодаря этому `ObjectId` уникален даже в распределенной системе.

### Индексы

Индексы работают так же, как в реляционных БД - ускоряют поиск. Без индекса MongoDB сканирует всю коллекцию (collection scan). С индексом - только нужные документы.

**Слайд 9: Системные БД**

MongoDB создает 3 системные базы данных автоматически. Не трогайте их!

### 1. admin

Тут хранятся:
- Пользователи и их права
- Роли
- Административные команды

Если удалите - не сможете подключиться к MongoDB.

### 2. config

Используется только при шардинге. Хранит:
- Метаданные о шардах (какие серверы, какие данные где лежат)
- Настройки балансировки

### 3. local

Не реплицируется между серверами. Хранит:
- **oplog** (operation log) - лог всех операций для репликации
- Временные данные
- Startup log

**Слайд 10: Установка MongoDB**

Для разработки проще всего юзать Docker. Одна команда - и MongoDB крутится:

```bash
docker run -d -p 27017:27017 mongo:7
```

Что тут происходит:
- `-d` - запуск в фоне (detached)
- `-p 27017:27017` - пробрасываем порт (27017 - дефолтный порт MongoDB)
- `mongo:7` - образ MongoDB версии 7

### Для России - Percona

Если боитесь санкций, юзайте Percona Server for MongoDB. Это полностью совместимый форк:

```bash
docker run -d -p 27017:27017 percona/percona-server-mongodb:7.0
```

Работает точно так же, но разрабатывается Percona (американская компания, но open-source).

**Слайд 11: Подключение Python**

Для работы с MongoDB из Python юзаем библиотеку **Motor** - это асинхронный драйвер.

```python
from motor.motor_asyncio import AsyncIOMotorClient

# Подключаемся к MongoDB
client = AsyncIOMotorClient("mongodb://localhost:27017")

# Выбираем БД (если не существует - создастся автоматически)
db = client["university_db"]

# Выбираем коллекцию (тоже создастся автоматически)
collection = db["students"]
```

Почему Motor, а не PyMongo? Потому что Motor работает с `async/await`, а PyMongo - синхронный. Для FastAPI нужен асинхронный драйвер.

**Слайды 12-15: CRUD операции**

Теперь самое важное - как работать с данными. CRUD = Create, Read, Update, Delete.

### CREATE - создание документов

```python
# Создаем документ (обычный Python словарь)
student = {
    "name": "Иван Иванов",
    "age": 21,
    "courses": ["Математика", "Программирование"],
    "grades": {"Математика": 5, "Программирование": 4}
}

# Вставляем один документ
result = await collection.insert_one(student)
print(f"Вставлен документ с ID: {result.inserted_id}")

# Вставляем несколько документов
students = [
    {"name": "Мария", "age": 20},
    {"name": "Петр", "age": 22}
]
result = await collection.insert_many(students)
print(f"Вставлено {len(result.inserted_ids)} документов")
```

Обратите внимание: мы просто передаем Python словарь. Никаких схем, никаких миграций. Просто взяли и вставили.

### READ - чтение документов

```python
# Найти один документ
student = await collection.find_one({"name": "Иван"})
print(student)  # {'_id': ObjectId(...), 'name': 'Иван', 'age': 21, ...}

# Найти все документы с условием
cursor = collection.find({"age": {"$gte": 20}})  # age >= 20
students = await cursor.to_list(length=100)  # Получить до 100 документов

# Проекция - выбрать только нужные поля
cursor = collection.find(
    {},  # Пустой фильтр = все документы
    {"name": 1, "age": 1, "_id": 0}  # 1 = включить, 0 = исключить
)
students = await cursor.to_list(length=100)
# Результат: [{'name': 'Иван', 'age': 21}, ...]
```

`$gte` - это оператор "больше или равно". Таких операторов куча, разберем дальше.

### UPDATE - обновление документов

```python
# Обновить один документ
result = await collection.update_one(
    {"name": "Иван"},  # Фильтр - что обновляем
    {"$set": {"age": 22}}  # $set - установить значение
)
print(f"Обновлено документов: {result.modified_count}")

# Обновить несколько документов
result = await collection.update_many(
    {"age": {"$lt": 20}},  # age < 20
    {"$inc": {"age": 1}}  # $inc - увеличить на 1
)
print(f"Обновлено документов: {result.modified_count}")

# Добавить элемент в массив
await collection.update_one(
    {"name": "Иван"},
    {"$push": {"courses": "Физика"}}  # Добавить "Физика" в массив courses
)
```

Операторы обновления:
- `$set` - установить значение
- `$inc` - увеличить/уменьшить число
- `$push` - добавить в массив
- `$pull` - удалить из массива
- `$unset` - удалить поле

### DELETE - удаление документов

```python
# Удалить один документ
result = await collection.delete_one({"name": "Иван"})
print(f"Удалено документов: {result.deleted_count}")

# Удалить несколько документов
result = await collection.delete_many({"age": {"$lt": 18}})  # age < 18
print(f"Удалено документов: {result.deleted_count}")

# Удалить все документы в коллекции (осторожно!)
result = await collection.delete_many({})
```

**Слайд 16: Операторы запросов**

MongoDB имеет богатый язык запросов. Разберем основные операторы:

### Операторы сравнения

```python
# Больше
{"age": {"$gt": 20}}  # age > 20

# Больше или равно
{"age": {"$gte": 20}}  # age >= 20

# Меньше
{"age": {"$lt": 25}}  # age < 25

# Меньше или равно
{"age": {"$lte": 25}}  # age <= 25

# Не равно
{"age": {"$ne": 20}}  # age != 20

# В списке
{"age": {"$in": [20, 21, 22]}}  # age IN (20, 21, 22)

# Не в списке
{"age": {"$nin": [18, 19]}}  # age NOT IN (18, 19)
```

### Логические операторы

```python
# AND (все условия должны выполняться)
{
    "$and": [
        {"age": {"$gte": 20}},
        {"age": {"$lte": 25}}
    ]
}
# Можно короче:
{"age": {"$gte": 20, "$lte": 25}}  # 20 <= age <= 25

# OR (хотя бы одно условие)
{
    "$or": [
        {"name": "Иван"},
        {"name": "Петр"}
    ]
}

# NOT (отрицание)
{"age": {"$not": {"$gte": 20}}}  # НЕ (age >= 20) = age < 20
```

### Проверка существования поля

```python
# Поле существует
{"email": {"$exists": True}}

# Поля нет
{"email": {"$exists": False}}
```

**Слайд 17: Работа с массивами**

MongoDB отлично работает с массивами. Это одна из его сильных сторон.

### Поиск в массивах

```python
# Найти студентов, изучающих математику
{"courses": "Математика"}  # Ищет "Математика" в массиве courses

# Найти тех, кто изучает И математику, И физику
{"courses": {"$all": ["Математика", "Физика"]}}

# Найти тех, кто изучает математику ИЛИ физику
{"courses": {"$in": ["Математика", "Физика"]}}

# Массив содержит хотя бы 3 элемента
{"courses": {"$size": 3}}

# Массив содержит больше 2 элементов (через $expr)
{"$expr": {"$gt": [{"$size": "$courses"}, 2]}}
```

### Обновление массивов

```python
# Добавить элемент в конец массива
{"$push": {"courses": "Физика"}}

# Добавить несколько элементов
{"$push": {"courses": {"$each": ["Физика", "Химия"]}}}

# Добавить только если нет (уникальность)
{"$addToSet": {"courses": "Физика"}}

# Удалить элемент
{"$pull": {"courses": "Физика"}}

# Удалить несколько элементов
{"$pull": {"courses": {"$in": ["Физика", "Химия"]}}}

# Удалить первый элемент
{"$pop": {"courses": -1}}  # -1 = первый, 1 = последний
```

**Продолжение следует...**
