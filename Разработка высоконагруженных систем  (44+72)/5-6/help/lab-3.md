# Лабораторная работа 2: Автоматизированное тестирование и архитектура

## Использование форм автоматизированного тестирования FastAPI

Помимо выполняемых вручную тестов, FastAPI предоставляет автоматизированные формы тестирования в конечных точках `/docs` и `/redoc`. Это два разных стиля для одних и тех же сведений.

FastAPI автоматически генерирует интерактивную документацию Swagger UI по адресу `/docs`, где можно:

1. **Нажать стрелку вниз** под разделом GET `/student/` - откроется форма для тестирования
2. **Нажать синюю кнопку "Execute"** для выполнения запроса
3. **Просмотреть результаты** - код ответа, заголовки и тело ответа в формате JSON

### Пример ответа для студентов

В разделе Response body выводится текст в формате JSON, возвращаемый для фиктивных данных студентов:

```json
[
    {
        "name": "Иван Иванов",
        "group": "ИСТ-401",
        "specialty": "Информационные системы",
        "year": 4
    },
    {
        "name": "Мария Петрова",
        "group": "ИСТ-402",
        "specialty": "Информационные технологии",
        "year": 4
    }
]
```

### Пример ответа для курсов

```json
[
    {
        "name": "Разработка высоконагруженных систем",
        "credits": 6,
        "semester": 7,
        "description": "Проектирование и разработка масштабируемых систем",
        "instructor": "Иванов И.И."
    },
    {
        "name": "Продвинутая веб-разработка",
        "credits": 5,
        "semester": 7,
        "description": "Современные фреймворки и технологии веб-разработки",
        "instructor": "Петров П.П."
    }
]
```

## Общение с уровнями сервисов и данных

Когда функциям на веб-уровне нужны данные, находящиеся под управлением уровня данных, она должна попросить уровень сервисов стать посредником. Это требует больше кода, но это хорошая практика:

### Преимущества трехуровневой архитектуры

- **Безопасность**: Веб-уровень работает с Интернетом, а уровень данных - с внешними хранилищами
- **Тестируемость**: Уровни можно тестировать независимо друг от друга
- **Изоляция**: Сервисный уровень определяет бизнес-логику и скрывает детали реализации от других уровней

### Пример взаимодействия уровней

```python
# web/student.py
from model.student import Student
import service.student as service

@router.get("/")
def get_all() -> list[Student]:
    return service.get_all()  # Веб → Сервис

# service/student.py
import data.student as data

def get_all() -> list[Student]:
    return data.get_all()  # Сервис → Данные

# data/student.py
def get_all() -> list[Student]:
    # Работа с БД
    return _students
```

## Пагинация и сортировка

В веб-интерфейсах часто требуется:
- **Сортировка** - упорядочение результатов
- **Пагинация** - возвращение части результатов за раз

### Примеры параметров запроса для студентов

```bash
# Сортировка по группе
GET /student?sort=group

# Пагинация (позиции 10-19)
GET /student?offset=10&size=10

# Комбинированный запрос
GET /student?sort=group&offset=10&size=10
```

### Примеры параметров запроса для курсов

```bash
# Сортировка по семестру
GET /course?sort=semester

# Фильтрация по семестру
GET /course?semester=7

# Поиск по названию
GET /course?name=веб
```

### Реализация пагинации

```python
from fastapi import Query

@router.get("/")
def get_all(
    offset: int = Query(0, ge=0),
    size: int = Query(10, ge=1, le=100)
) -> list[Student]:
    return service.get_all(offset=offset, size=size)
```

Эти задачи обычно лучше решать на уровне данных, где базы данных эффективно справляются с сортировкой и пагинацией.

## Задания для самостоятельной работы

1. **Добавьте фильтрацию студентов по курсу обучения**
   ```python
   GET /student?year=4
   ```

2. **Реализуйте поиск курсов по преподавателю**
   ```python
   GET /course?instructor=Иванов
   ```

3. **Добавьте сортировку студентов по имени**
   ```python
   GET /student?sort=name&order=asc
   ```

4. **Реализуйте подсчет количества студентов в группе**
   ```python
   GET /student/count?group=ИСТ-401
   ```

5. **Добавьте валидацию для года обучения (1-6)**
   ```python
   from pydantic import Field
   
   class Student(BaseModel):
       year: int = Field(ge=1, le=6)
   ```

## Заключение

В этой лабораторной работе вы изучили:

1. **Автоматическое тестирование** через Swagger UI (`/docs`)
2. **Трехуровневую архитектуру** (web → service → data)
3. **Пагинацию и сортировку** для работы с большими объемами данных
4. **Фильтрацию данных** через параметры запроса

На веб-уровне определяются конечные точки с помощью декораторов путей FastAPI, которые:

- Автоматически проверяют и подтверждают данные с помощью Pydantic
- Собирают данные запроса из различных частей HTTP-сообщения
- Передают аргументы соответствующим сервисным функциям

Это основа для построения масштабируемого и поддерживаемого веб-приложения с четким разделением ответственности между уровнями.