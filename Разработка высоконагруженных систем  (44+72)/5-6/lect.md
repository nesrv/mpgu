## Слайд 2

**Starlette** - это легкий ASGI-фреймворк/инструментарий, он идеально подходит для создания асинхронных веб-сервисов на Python.

Большая часть веб-кода FastAPI основана на созданном Томом Кристи пакете Starlette (https://www.starlette.io). 

Его можно применять в качестве самостоятельного веб-фреймворка или как библиотеку для других фреймворков, например FastAPI. 
Как и любой другой веб-фреймворк, Starlette выполняет все обычные операции синтаксического анализа HTTP-запросов и генерации ответов.

Он аналогичен лежащему в основе Flask пакету Werkzeug (https://werkzeug.palletsprojects.com).

## Слайд 3

Самая важная его особенность заключается в поддержке современного асинхронного веб-стандарта Python - ASGI (https://asgi.readthedocs.io). 

До сих пор большинство веб-фреймворков Python, например Flask и Django, основывались на традиционном синхронном стандарте WSGI (https://wsgi.readthedocs.io).

ASGI позволяет избежать характерных для приложений на базе WSGI блокировок и напряженного ожидания. 
Проблемы такого типа связаны с частым подключением веб-приложений к гораздо более медленному коду, например, для доступа к базам данных, файлам и сетям. 

В результате Starlette и использующие его фреймворки стали самыми быстрыми веб-пакетами Python и составили конкуренцию даже приложениям на Go и Node.js.

## Слайд 4

### Типы конкурентности

При **параллельных вычислениях** задача распределяется между несколькими выделенными центральными процессорами (ЦП). Этот метод часто используется в приложениях для выполнения расчетов, таких как задачи обработки графики и машинное обучение.

При **конкурентных вычислениях** каждый ЦП переключается между несколькими задачами. Некоторые задачи из потока занимают больше времени, и необходимо сократить общее время выполнения. 

Считывание файла или доступ к удаленному сетевому сервису буквально в тысячи и миллионы раз медленнее, чем выполнение вычислений в ЦП.

Веб-приложения выполняют большую часть этой медленной работы. Как заставить их или любые другие серверы работать быстрее?


## Слайд 4-1

## GIL (Global Interpreter Lock)

**GIL** - это механизм в CPython, который позволяет только одному потоку выполнять байт-код Python одновременно. Это означает, что даже на многоядерном процессоре потоки Python не могут выполняться по-настоящему параллельно для CPU-bound задач.

![1761908864592](image/lect/1761908864592.png)

### Ограничения GIL:
- **CPU-bound задачи** (вычисления, обработка данных) - потоки не дают преимущества
- **I/O-bound задачи** (сеть, файлы, БД) - потоки работают эффективно, так как GIL освобождается во время ожидания I/O

## Слайд 4-1

| Характеристика | I/O-bound | CPU-bound |
| :--- | :--- | :--- |
| **Ограничивающий ресурс** | Скорость Ввода/Вывода (диск, сеть) | Скорость Процессора (CPU) |
| **Загрузка CPU** | Низкая (много времени в режиме ожидания) | Высокая (почти 100%) |
| **Основное время** | Ожидание | Активные вычисления |
| **Примеры** | Веб-запросы, копирование файлов | Рендеринг видео, математические расчеты |
| **Способы оптимизации** | Асинхронность, Многопоточность | Многопроцессорность, Распараллеливание |

**Простая аналогия:**

*   **CPU-bound** — это **шеф-повар**, который очень быстро режет овощи. Его скорость ограничена его личной ловкостью. Чтобы готовить быстрее, наймите еще поваров (добавьте ядер процессора).
*   **I/O-bound** — это **курьер**, который ждет лифт, чтобы доставить заказ. Его скорость ограничена временем ожидания лифта. Чтобы доставлять больше заказов, наймите больше курьеров (создайте больше потоков/задач), которые будут ждать лифты параллельно.

## Слайд 5-1

## Типы задач в FastAPI

### 1. I/O-bound задачи (связанные с вводом-выводом)
- Запросы к базам данных
- HTTP-запросы к внешним API
- Чтение/запись файлов
- Сетевые операции

Асинхронность (async/await) + asyncio

```py
@app.get("/fetch-data")
async def fetch_multiple():
    async with httpx.AsyncClient() as client:
        # Параллельное выполнение нескольких запросов
        results = await asyncio.gather(
            client.get("https://api1.com/data"),
            client.get("https://api2.com/data"),
            client.get("https://api3.com/data")
        )
    return {"results": [r.json() for r in results]}
```

## Слайд 5-2

Проблема CPU-bound задач в FastAPI

**Основная проблема**: FastAPI работает под управлением **asyncio** и использует **один поток события (event loop)**. Когда выполняется CPU-bound задача, она блокирует весь event loop, и сервер не может обрабатывать другие запросы.

### Пример проблемы

```python

# CPU-bound задача - тяжелые вычисления
def heavy_calculation(n: int):
    # Симуляция тяжелых вычислений
    result = 0
    for i in range(n):
        result += i * i
    return result

@app.get("/slow-cpu")
def slow_cpu_endpoint():
    start = time.time()
    result = heavy_calculation(50_000_000)  # Блокирующая операция!
    end = time.time()
    return {"result": result, "time": end - start}

@app.get("/fast")
def fast_endpoint():
    return {"message": "Я быстрый!"}
```

Если вы откроете два браузера и:
1. Сначала запросите `/slow-cpu` (будет выполняться 3-5 секунд)
2. Затем сразу запросите `/fast`

Второй запрос **будет ждать**, пока завершится первый, потому что CPU-bound задача заблокировала event loop!


## Слайд 5-3

**Решение**: Многопроцессорность (ProcessPoolExecutor)

```py
from fastapi import FastAPI
from concurrent.futures import ProcessPoolExecutor
import asyncio

app = FastAPI()
executor = ProcessPoolExecutor(max_workers=4)

def heavy_computation(n):
    # Тяжелые вычисления
    result = sum(i * i for i in range(n))
    return result

@app.get("/compute/{n}")
async def compute(n: int):
    loop = asyncio.get_event_loop()
    # Выполняем в отдельном процессе
    result = await loop.run_in_executor(executor, heavy_computation, n)
    return {"result": result}
```

## Слайд 5-4

### Многопоточность (Threading)
```py
from fastapi import FastAPI
from concurrent.futures import ThreadPoolExecutor
import time
import asyncio

app = FastAPI()
thread_executor = ThreadPoolExecutor(max_workers=10)

def io_task(duration):
    time.sleep(duration)  # Имитация I/O операции
    return f"Completed after {duration}s"

@app.get("/thread-task")
async def thread_task():
    loop = asyncio.get_event_loop()
    tasks = [
        loop.run_in_executor(thread_executor, io_task, 1),
        loop.run_in_executor(thread_executor, io_task, 2),
        loop.run_in_executor(thread_executor, io_task, 3)
    ]
    results = await asyncio.gather(*tasks)
    return {"results": results}
```


## Слайд 5-4

## Рекомендации по выбору

| Тип задачи | Решение | Пример |
|------------|---------|--------|
| I/O-bound (сеть, БД) | async/await | API запросы, БД запросы |
| CPU-bound (вычисления) | ProcessPoolExecutor | Обработка изображений, ML |
| Смешанные задачи | ThreadPoolExecutor | Парсинг + сеть |
| Фоновые задачи | BackgroundTasks | Отправка email, логирование |
| Распределенные задачи | Celery + Redis | Длительные задачи, очереди |


## Слайд 5-5

## Рекомендации по выбору
# Практический пример: комбинированный подход

```py
from fastapi import FastAPI, BackgroundTasks
from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor
import asyncio
import httpx
import time

app = FastAPI()
process_pool = ProcessPoolExecutor(max_workers=4)
thread_pool = ThreadPoolExecutor(max_workers=10)

def process_image(image_data):
    # CPU-intensive: обработка изображения
    return {"processed": True}

async def fetch_data(url):
    # I/O-bound: получение данных
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        return response.json()

def save_to_db(data):
    # I/O-bound: сохранение в БД
    time.sleep(1)
    return {"saved": True}

@app.post("/process")
async def process(background_tasks: BackgroundTasks):
    # 1. Асинхронно получаем данные
    data = await fetch_data("https://api.example.com/data")
    
    # 2. CPU-задачу выполняем в отдельном процессе
    loop = asyncio.get_event_loop()
    processed = await loop.run_in_executor(
        process_pool, 
        process_image, 
        data
    )
    
    # 3. Сохранение в БД делаем в фоне
    background_tasks.add_task(save_to_db, processed)
    
    return {"status": "processing", "data": processed}
```

## Слайд 5-4

### Параллельные вычисления

FastAPI отлично подходит для создания API, которые могут инициировать параллельные и распределенные вычисления, но само по себе оно не предоставляет полноценного фреймворка для этих задач.

Параллелизм в рамках одного сервера направлен на эффективное использование всех ядер процессора.
asyncio.gather() (для I/O-bound задач): 
Используем этот подход, когда ваши задачи в основном связаны с вводом-выводом (сетевые запросы, чтение/запись в БД). asyncio.gather() позволяет одновременно ожидать выполнения нескольких асинхронных операций в одном потоке событий, не блокируя его.

concurrent.futures.ProcessPoolExecutor (для CPU-bound задач): Для задач, интенсивно использующих процессор (сложные вычисления, обработка данных), Python имеет ограничение (GIL - Global Interpreter Lock), которое не позволяет потокам выполняться по-настоящему параллельно в одном процессе.
Разработка высоконагруженных систем  (44+72)\5-6\image\lect\gil.gif

BackgroundTasks: Позволяет серверу FastAPI немедленно отправить ответ клиенту, пока длительная задача выполняется в фоновом режиме. Это гарантирует, что API остается отзывчивым.


## Слайд 6

### Распределенные вычисления (несколько серверов/узлов)

Для распределенных вычислений требуется архитектура, состоящая из нескольких компонентов, взаимодействующих друг с другом.
Брокеры сообщений (Redis, RabbitMQ, Kafka) и очереди задач (Celery, Ray): Это наиболее распространенный подход.
FastAPI принимает запрос и отправляет задачу в очередь через брокер сообщений (например, Redis).
Независимые рабочие процессы (Celery Workers или Ray Workers) извлекают задачи из очереди и выполняют их в фоновом режиме на других серверах или процессах.
Результат выполнения задачи может быть сохранен в базе данных или брокере, и клиент может запросить статус задачи через другой эндпоинт FastAPI.

## Слайд 6

### Сравнение синхронного и асинхронного кода

**Синхронный код:**

```py
import time

def q():
    print("Why can't programmers tell jokes?")
    time.sleep(3)

def a():
    print("Timing!")

def main():
    q()
    a()

main()
```

Вывод:
```
Why can't programmers tell jokes?
Timing!
```

Между вопросом и ответом будет трехсекундный промежуток. Скукота.

**Асинхронный код:**

```py
import asyncio

async def q():
    print("Why can't programmers tell jokes?")
    await asyncio.sleep(3)

async def a():
    print("Timing!")

async def main():
    await asyncio.gather(q(), a())

asyncio.run(main())
```

## Слайд 7

### Асинхронный эндпоинт

```py
from fastapi import FastAPI
import asyncio

app = FastAPI()

@app.get("/hi")
async def greet():
    await asyncio.sleep(1)
    return "Hello? World?"
```

Запуск:
```bash
uvicorn greet_async:app
```

Или с uvicorn в коде:

```py
from fastapi import FastAPI
import asyncio
import uvicorn

app = FastAPI()

@app.get("/hi")
async def greet():
    await asyncio.sleep(1)
    return "Hello? World?"

if __name__ == "__main__":
    uvicorn.run("greet_async_uvicorn:app")
```

## Слайд 8

### Pydantic, подсказки типов и обзор моделей

Подсказки типа переменной могут включать только тип:
```
name: type
```

или также инициализировать переменную значением:
```
name: type = value
```

**Пример:**

```py
thing: str = "yeti"
physics_magic_number: float = 1.0/137.03599913
hp_lovecraft_noun: str = "ichor"
exploding_sheep: tuple = ("sis", "boom", "bah!")
responses: dict = {"Marco": "Polo", "answer": 42}
```

Можно также включать подтипы коллекций:

```py
name: dict[keytype, valtype] = {key1: val1, key2: val2}
```

## Слайд 9

При использовании Python до версии 3.9 необходимо импортировать прописные версии стандартных имен типов из модуля typing:

```py
from typing import Str
thing: Str = "yeti"
```

Модуль typing содержит полезные дополнения для подтипов. Наиболее распространенные из них следующие:
- **Any** - любой тип
- **Union** - любой из указанных типов, например `Union[str, int]`

## Слайд 10

Примеры определений Pydantic для словарей (dict) в Python включают следующее:

```py
from typing import Any
responses: dict[str, Any] = {"Marco": "Polo", "answer": 42}
```

Или, если быть более точными:

```py
from typing import Union
responses: dict[str, Union[str, int]] = {"Marco": "Polo", "answer": 42}
```

либо (в Python 3.10 и более поздних версиях):

```py
responses: dict[str, str | int] = {"Marco": "Polo", "answer": 42}
```

## Слайд 11

Обратите внимание на то, что в Python строка переменной с подсказкой типа является верной, а простая строка переменной - нет:

```py
>>> thing0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'thing0' is not defined

>>> thing0: str
>>> thing1: str = "yeti"
>>> thing1 = 47
```

Но такие ошибки будут обнаружены mypy.

Если у вас еще не установлен этот статический анализатор, наберите команду:
```bash
pip install mypy
```

Сохраните две предыдущие строки в файле `stuff.py`, а затем попробуйте выполнить следующие команды:

```bash
mypy stuff.py
```

## Слайд 12

В подсказке типа возврата функции вместо двоеточия применяется стрелка:

```
function(args) -> type:
```

Вот пример возврата функции при использовании Pydantic:

```py
def get_thing() -> str:
    return "yeti"
```

Можно задействовать любой тип, включая определенные классы или их комбинации.



## Слайд 13

### Методы FastAPI

Одним из преимуществ FastAPI является то, что фреймворк позволяет быстро и легко построить веб-сервис в стиле REST. Архитектура REST предполагает применение следующих методов или типов запросов HTTP для взаимодействия с сервером, где каждый тип запроса отвечает за определенное действие:

- **GET** (получение данных)
- **POST** (добавление данных)
- **PUT** (изменение данных)
- **DELETE** (удаление данных)

Кроме этих типов запросов HTTP поддерживает еще ряд, в частности:

- **OPTIONS**
- **HEAD**
- **PATCH**
- **TRACE**

## Слайд 14

В классе FastAPI для каждого из этих типов запросов определены одноименные методы:

- **get()** - получение данных (чтение)
- **post()** - создание новых данных
- **put()** - полное обновление данных (замена)
- **delete()** - удаление данных
- **options()** - получение информации о поддерживаемых методах (CORS)
- **head()** - получение только заголовков ответа
- **patch()** - частичное обновление данных
- **trace()** - диагностика, возвращает полученные данные (редко используется)

Все эти методы имеют множество параметров, но все они в качестве обязательного параметра принимают путь, запрос по которому должен обрабатываться.

Методы сам запрос не обрабатывают - они применяются в качестве декоратора к функциям, которые непосредственно обрабатывают запрос. 

Например:

```py
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def root():
    return {"message": "Hello Пушкин.COM"}
```

В данном случае метод app.get() применяется в качестве декоратора к функции root() (символ @ указывает на определение декоратора). Этот декоратор определяет путь, запросы по которому будет обрабатывать функция root(). 

В данном случае путь представляет строку "/", то есть функция будет обрабатывать запросы к корню веб-приложения (например, по адресу http://127.0.0.1:8000/).

Функция возвращает некоторый результат. Обычно это словарь (объект dict). Здесь словарь содержит один элемент "message". При отправке эти данные автоматически сериализуются в формат JSON - популярный формат для взаимодействия между клиентом и сервером. А у ответа для заголовка content-type устанавливается значение application/json. Вообще функция может возвращать различные данные - словари (dict), списки (list), одиночные значения типа строк, чисел и т.д., которые затем сериализуются в json.


## Слайд 15

Подобным образом можно определять и другие функции, которые будут обрабатывать запросы по другим путям. Например:

```py
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def root():
    return {"message": "Hello Пушкин.COM"}

@app.get("/about")
def about():
    return {"message": "О сайте"}
```

## Слайд 16

### Response

Класс fastapi.Response является базовым для остальных классов ответа. Его преимуществом является то, что он позволяет также отправить ответ, который не покрывается встроенными классами, например, в каком-то нестандартном формате. Для определения ответа конструктор класса принимает следующие параметры:

- **content**: задает отправляемое содержимое
- **status_code**: задает статусный код ответа
- **media_type**: задает MIME-тип ответа
- **headers**: задает заголовки ответа

```py
from fastapi import FastAPI, Response

app = FastAPI()

@app.get("/")
def root():
    data = "Hello Пушкин.COM"
    return Response(content=data, media_type="text/plain")
```

В данном случае клиенту отправляется обычная строка "Hello Пушкин.COM". А MIME-тип "text/plain" указывает, что тип ответа - простой текст.

## Слайд 17

### PlainTextResponse

Для отправки простого текста также можно использовать класс-наследник PlainTextResponse:

```py
from fastapi import FastAPI
from fastapi.responses import PlainTextResponse

app = FastAPI()

@app.get("/")
def root():
    data = "Hello Пушкин.COM"
    return PlainTextResponse(content=data)
```

## Слайд 18

### HTMLResponse

Для упрощения отправки кода HTML предназначен класс HTMLResponse. Он устанавливает для заголовка Content-Type значение text/html:

```py
from fastapi import FastAPI
from fastapi.responses import HTMLResponse

app = FastAPI()

@app.get("/")
def root():
    data = "<h2>Hello Пушкин.COM</h2>"
    return HTMLResponse(content=data)
```

## Слайд 19

### Установка типа ответа через методы FastAPI

Методы FastAPI такие как get(), post() и т.д. позволяют задать тип ответа с помощью параметра response_class:

```py
from fastapi import FastAPI
from fastapi.responses import PlainTextResponse, JSONResponse, HTMLResponse

app = FastAPI()

@app.get("/text", response_class=PlainTextResponse)
def root_text():
    return "Hello Пушкин.COM"

@app.get("/html", response_class=HTMLResponse)
def root_html():
    return "<h2>Hello Пушкин.COM</h2>"
```


## Слайд 20

### FileResponse

Пусть в проекте в папке public есть файл index.html со следующим кодом:

```html
<!DOCTYPE html>
<html>
<head>
    <title>Пушкин.COM</title>
    <meta charset="utf-8" />
</head>
<body>
    <h2>Hello Пушкин.COM</h2>
</body>
</html>
```

В файле main.py определим код для отправки этого файла клиенту:

```py
from fastapi import FastAPI
from fastapi.responses import FileResponse

app = FastAPI()

@app.get("/")
def root():
    return FileResponse("public/index.html")

# альтернативный вариант
@app.get("/file", response_class=FileResponse)
def root_html():
    return "public/index.html"
```

## Слайд 21

### Очередность определения путей

При определении шаблонов путей следует учитывать, что между различными шаблонами может возникнуть двойственность, когда запрос соответствует нескольким определенным шаблонам. И в этой связи следует учитывать очередность определения шаблонов путей. 

Например:

```py
@app.get("/users/{name}")
def users(name):
    return {"user_name": name}

@app.get("/users/admin")
def admin():
    return {"message": "Hello admin"}
```

В данном случае мы хотим, чтобы запросы по пути "/users/admin" обрабатывала функция admin(). А остальные пути по шаблону "/users/{name}", где второй сегмент представляет параметр name, обрабатывала бы функция users(). 

Однако если мы обратимся к приложению с запросом http://127.0.0.1:8000/users/admin, то мы увидим, что запрос обрабатывает функция users(), а не admin():

![1761900504278](image/lect/1761900504278.png)

Потому что функция users определена до функции admin, соответственно функция users и будет обрабатывать данный запрос. Чтобы добиться нужного результата, нам надо поменять определение функций местами.

## Слайд 22

### Ограничение типа параметров

FastAPI позволяет ограничить тип параметров и соответственно набор используемых значений. Например, мы хотим, чтобы параметр id представлял только целое число:

```py
@app.get("/users/{id}")
def users(id: int):
    return {"user_id": id}
```

Чтобы указать, что параметр - целое число, у параметра функции явным образом задается тип int. И если мы попробуем передать этому параметру не целочисленное значение, то сервер отправит сообщение об ошибке:

![1761900594446](image/lect/1761900594446.png)

![1761900601254](image/lect/1761900601254.png)

## Слайд 23

### Path

Дополнительно для работы с параметрами пути фреймворк FastAPI предоставляет класс Path из пакета fastapi. Класс Path позволяет валидировать значения параметров. В частности, через конструктор Path можно установить следующие параметры для валидации значений:

- **min_length**: устанавливает минимальное количество символов в значении параметра
- **max_length**: устанавливает максимальное количество символов в значении параметра
- **pattern**: устанавливает регулярное выражение, которому должно соответствовать значение параметра
- **lt**: значение параметра должно быть меньше определенного значения
- **le**: значение параметра должно быть меньше или равно определенному значению
- **gt**: значение параметра должно быть больше определенного значения
- **ge**: значение параметра должно быть больше или равно определенному значению

```py
@app.get("/users/{name}")
def users(name:str = Path(min_length=3, max_length=20)):
    return {"name": name}
```

В данном случае получаем параметр name. Причем его значение должно иметь не меньше 3 и не больше 20 символов.

![1761900680765](image/lect/1761900680765.png)

![1761900690545](image/lect/1761900690545.png)

## Слайд 24

### Валидация параметров

Подобным образом можно использовать другие параметры валидации:

```py
@app.get("/users/{name}/{age}")
def users(name:str = Path(min_length=3, max_length=20), 
          age: int = Path(ge=18, lt=111)):
    return {"name": name, "age": age}
```

В данном случае добавляется параметр "age", который должен представлять число в диапазоне от 18 (включительно) до 111 (не включая).

Валидация с помощью регулярного выражения:

```py
@app.get("/users/{phone}")
def users(phone:str = Path(pattern=r"^\d{11}$")):
    return {"phone": phone}
```

Здесь параметр phone должен состоять из 11 цифр.

## Слайд 25

### Параметры строки запроса

Параметры строки запроса представляют еще один способ передать в приложение некоторые значения в запросе типа GET. 

Например, возьмем следующий адрес:

```
http://127.0.0.1:8000/users/add?name=Tom&age=38
```

Здесь та часть, которая идет после адреса сервера и порта и до вопросительного знака ?, то есть users/add, представляет путь запроса (path). А та часть, которая идет после вопросительного знака, то есть name=Tom&age=38, представляет строку запроса (query string). В данной статье нас будет интересовать прежде всего строка запроса.

Строка запроса состоит из параметров. Каждый параметр определяется в форме:

```
имя_параметра=значение_параметра
```

## Слайд 26

### Получение параметров строки запроса

Если строка запроса содержит несколько параметров, то они отделяются друг от друга знаком амперсанда &. 

Так, в примере с адресом http://127.0.0.1:8000/users/add?name=Tom&age=38 строка запроса состоит из двух параметров: параметр name имеет значение "Tom", а параметр age имеет значение 38.

Для получения значений параметров строки запроса мы можем в функции определить одноименные параметры:

```py
@app.get("/users")
def get_model(name, age):
    return {"user_name": name, "user_age": age}
```

![1761900845557](image/lect/1761900845557.png)

## Слайд 27

### Значения по умолчанию

Вполне может быть, что при обращении к приложению пользователь не передаст значения для какого-либо параметра или даже для всех параметров строки запроса. В примере выше все параметры строки запроса являются обязательными. И если мы не передадим хотя бы один из параметров, то мы получим ошибку.

Чтобы ошибки не было, можно задать для параметров значения по умолчанию:

```py
@app.get("/users")
def get_model(name = "Undefined", age = 18):
    return {"user_name": name, "user_age": age}
```

## Слайд 28

### Ограничения по типу

Также для параметров строки запроса можно задать ограничения по типу:

```py
@app.get("/users")
def get_model(name: str, age: int = 18):
    return {"user_name": name, "user_age": age}
```

В данном случае параметр name должен представлять тип str, то есть строку, а параметр age - целое число. Если параметру age передать нечисловое значение, то мы получим ошибку.

## Слайд 29

### Query

Дополнительно для работы с параметрами строки запроса фреймворк предоставляет класс Query из пакета fastapi. Класс Query позволяет прежде всего валидировать значения параметров строки запроса. В частности, через конструктор Query можно установить следующие параметры для валидации значений:

- **min_length**: устанавливает минимальное количество символов в значении параметра
- **max_length**: устанавливает максимальное количество символов в значении параметра
- **pattern**: устанавливает регулярное выражение, которому должно соответствовать значение параметра
- **lt**: значение параметра должно быть меньше определенного значения
- **le**: значение параметра должно быть меньше или равно определенному значению
- **gt**: значение параметра должно быть больше определенного значения
- **ge**: значение параметра должно быть больше или равно определенному значению

```py
@app.get("/users")
def users(name:str = Query(min_length=3, max_length=20)):
    return {"name": name}
```

![1761900964176](image/lect/1761900964176.png)

![1761900977617](image/lect/1761900977617.png)

## Слайд 30

### Дополнительные возможности Query

Подобным образом можно использовать другие параметры валидации:

```py
@app.get("/users")
def users(name:str = Query(min_length=3, max_length=20), 
          age: int = Query(ge=18, lt=111)):
    return {"name": name, "age": age}
```

В данном случае добавляется параметр "age", который должен представлять число в диапазоне от 18 (включительно) до 111 (не включая).

Валидация с помощью регулярного выражения:

```py
@app.get("/users")
def users(phone:str = Query(pattern=r"^\d{11}$")):
    return {"phone": phone}
```

Здесь параметр phone должен состоять из 11 цифр.

Query позволяет установить значение по умолчанию с помощью параметра default:

```py
@app.get("/users")
def users(name: str = Query(default="Undefined", min_length=2)):
    return {"name": name}
```

Здесь, если в запрошенном адресе отсутствует параметр name, то по умолчанию он будет равен строке "Undefined".

Если параметры должны быть необязательными, то параметру default передается значение None:

```py
@app.get("/users")
def users(name:str | None = Query(default=None, min_length=2)):
    if name == None:
        return {"name": "Undefined"}
    else:
        return {"name": name}
```

## Слайд 31

### Получение списков значений

Использование класса Query позволяет получать через строку запроса списки. В общем случае списки значений передаются, когда в строке запроса одному параметру несколько раз передаются разные значения. 

Например, как в запросе по следующему адресу:

```
http://127.0.0.1:8000/users?people=tom&people=Sam&people=Bob
```

Здесь параметру people передаются три разных значения, соответственно мы ожидаем, что список people будет содержать три элемента.

Определим следующее приложение:

```py
@app.get("/users")
def users(people: list[str] = Query()):
    return {"people": people}
```

Здесь функция users имеет один параметр - people, который должен представлять список строк - тип list[str].

Передадим через строку запроса список значений в виде параметра people, например, с помощью запроса http://127.0.0.1:8000/users?people=tom&people=Sam:

![1761901138470](image/lect/1761901138470.png)

## Слайд 32

### Сочетание параметров пути и строки запроса

```py
@app.get("/users/{name}")
def users(name:str = Path(min_length=3, max_length=20), 
          age: int = Query(ge=18, lt=111)):
    return {"name": name, "age": age}
```

В данном случае параметр name представляет параметр пути, а age - параметр строки запроса. И в данном случае мы могли бы обратиться к функции users, например, посредством адреса http://127.0.0.1:8000/users/Tom?age=38

## Слайд 33

### Определение статусного кода в ответе

```py
@app.get("/notfound")
def notfound():
    return JSONResponse(content={"message": "Resource Not Found"}, status_code=404)
```

Изменение статусного кода:

```py
@app.get("/users/{id}", status_code=200)
def users(response: Response, id: int = Path()):
    if id < 1:
        response.status_code = 400
        return {"message": "Incorrect Data"}
    return {"message": f"Id = {id}"}
```

В данном случае если параметр пути меньше 1, то условно считаем, что переданы некорректные данные, и отправляем в ответ статусный код 400 (Bad Request).er_age": age}

![1761900845557](image/lect/1761900845557.png)

## Слайд 27

Значения по умолчанию
Вполне может быть, что при обращении к приложению пользователь не передаст значения для какого-либо параметра или даже для всех параметров строки запроса. В примере выше все параметры строки запроса являются обязательными. И если мы не передадим хотя бы один из параметров, то мы получим ошибку.

Чтобы ошибки не было, можно задать для параметров значения по умолчанию:

@app.get("/users")
def get_model(name = "Undefined", age = 18):
    return {"user_name": name, "user_age": age}

## Слайд 28

Ограничения по типу
Также для параметров строки запроса можно задать ограничения по типу:

@app.get("/users")
def get_model(name: str, age: int = 18):
    return {"user_name": name, "user_age": age}

В данном случае параметр name должен представлять тип str, то есть строку, а параметр age - целое число. 
Если параметру age передать нечисловое значение, то мы получим ошибку.

## Слайд 29

Query
Дополнительно для работы с параметрами строки запроса фреймворк предоставляет класс Query из пакета fastapi. Класс Query позволяет прежде всего валидировать значения параметров строки запроса. В частности, через конструктор Query можно установить следующие параметры для валидации значений:

min_length: устанавливает минимальное количество символов в значении параметра
max_length: устанавливает максимальное количество символов в значении параметра
pattern: устанавливает регулярное выражение, которому должно соответствовать значение параметра
lt: значение параметра должно быть меньше определенного значения
le: значение параметра должно быть меньше или равно определенному значению
gt: значение параметра должно быть больше определенного значения
ge: значение параметра должно быть больше или равно определенному значению

@app.get("/users")
def users(name:str  = Query(min_length=3, max_length=20)):
    return {"name": name}

![1761900964176](image/lect/1761900964176.png)
![1761900977617](image/lect/1761900977617.png)

## Слайд 29 
Подобным образом можно использовать другие параметры валидации:

@app.get("/users")
def users(name:str  = Query(min_length=3, max_length=20), 
            age: int = Query(ge=18, lt=111)):
    return {"name": name, "age": age}

В данном случае добавляется параметр "age", который должен представлять число в диапазоне от 18 (включительно) до 111 (не включая)
Валидация с помощью регулярного значения:

@app.get("/users")
def users(phone:str  = Query(pattern=r"^\d{11}$")):
    return {"phone": phone}

Здесь параметр phone должен состоять из 11 цифр.
Query позволяет установить значение по умолчанию с помощью параметра default:

@app.get("/users")
def users(name: str = Query(default="Undefined", min_length=2)):
    return {"name": name}

## Слайд 30 
Здесь, если в запрошенном адресе отстуствует параметр name, то по умолчанию он будет равен строке "Undefined"
Если параметры должны быть необязательными, то параметру default передается значение None:

@app.get("/users")
def users(name:str | None = Query(default=None, min_length=2)):
    if name==None:
        return {"name": "Undefined"}
    else:
        return {"name": name}


## Слайд 31

Получение списков значений

Использование класса Query позволяет получать через строку запроса списки. 
В общем случае списки значений передаются, когда в строке запроса одному параметру несколько раз передаются разные значения. 
Например, как в запросе по следующему адресу:
http://127.0.0.1:8000/users?people=tom&people=Sam&people=Bob
Здесь параметру people передаются три разных значения, соответственно мы ожидаем, что список people будет содержать три элемента.
Определим следующее приложение:

@app.get("/users")
def users(people: list[str]  = Query()):
    return {"people": people}

Здесь функция users имеет один параметр - people, который должен представлять список строк - тип list[str].

Передадим через строку запроса список значений в виде параметра people, например, с помощью запроса http://127.0.0.1:8000/users?people=tom&people=Sam:

![1761901138470](image/lect/1761901138470.png)

## Слайд 32 

Сочетание параметров пути и строки запроса

@app.get("/users/{name}")
def users(name:str  = Path(min_length=3, max_length=20), 
            age: int = Query(ge=18, lt=111)):
    return {"name": name, "age": age}

В данном случае параметр name представляет параметр пути, а age - параметр строки запроса. И в данном случае мы могли бы обратиться к функции users, например, посредством адреса http://127.0.0.1:8000/users/Tom?age=38

## Слайд 33
Определение статусного кода в ответе

@app.get("/notfound")
def notfound():
    return JSONResponse(content={"message": "Resource Not Found"}, status_code=404)

Изменение статусного кода

@app.get("/users/{id}", status_code=200)
def users(response: Response, id: int = Path()):
    if id < 1:
        response.status_code = 400
        return {"message": "Incorrect Data"}
    return  {"message": f"Id = {id}"}
В данном случае если параметр пути меньше 1, то условно считаем, что переданные некорректные данные, и отправляем в ответ статусный код 400 (Bad Request)


