# Текст лекции: PostgreSQL Full-Text Search (Часть 1)

## Слайд 1: Титульный

**Время: 1 мин**

Привет! Сегодня разбираем полнотекстовый поиск в PostgreSQL. Это как встроенный Google для вашей базы данных. Без Elasticsearch, без костылей с синхронизацией — всё внутри Postgres с транзакциями и консистентностью.

---

## Слайд 2: Содержание

**Время: 1 мин**

План на сегодня:
- Зачем вообще нужен FTS, если есть LIKE
- Как работают документы и запросы (tsvector и tsquery)
- Анализаторы — как Postgres разбирает текст на токены
- Словари — как приводим "разработчик" и "разработчика" к одной форме
- Конфигурации — как всё это связать вместе
- Индексы — GIN, GiST, RUM и когда что использовать

---

## Слайд 3: Проблемы LIKE и регулярных выражений

**Время: 4 мин**

**Ассоциация:** LIKE — это как искать иголку в стоге сена с завязанными глазами.

Давайте начнем с того, почему обычный LIKE не катит для нормального поиска.

```sql
WHERE name LIKE '%иван%'
```

**Проблема 1: Морфология не работает**
Найдет "Иван", но не найдет "Ивана", "Ивану", "Иваном". В русском языке 6 падежей, в каждом слово меняется. Вы что, будете писать 6 LIKE условий через OR? Это же ад!

**Проблема 2: Нет ранжирования**
Все результаты равны. Хотя очевидно, что документ, где слово встречается 10 раз в заголовке, релевантнее, чем где оно один раз в футере мелким шрифтом.

**Проблема 3: Full table scan**
Даже если у вас есть индекс, LIKE с процентом в начале (`'%иван%'`) его не использует. База просто читает ВСЕ строки. На миллионе записей это смерть.

**Сленг:** "LIKE убил продакшн" — классика жанра. Кто-то добавил поиск через LIKE, нагрузка выросла, база легла.

---

## Слайд 4: Проблемы внешних поисковиков

**Время: 5 мин**

**Ассоциация:** Внешние поисковики — это как вынести мозг приложения наружу.

Окей, LIKE не работает. Давайте возьмем Elasticsearch! Но тут свои грабли.

**Проблема 1: Синхронизация через костыли**

```javascript
// Классический баг:
try {
  await db.insert(post);        // ✅ Успех
  await elastic.index(post);    // ❌ Упало (сеть, timeout, что угодно)
} catch (e) {
  // Данные в БД есть, в поиске нет — рассинхрон!
}
```

Вы пишете в Postgres, потом пушите в Elastic. Если между ними что-то упало — всё, у вас inconsistency. Пользователь создал пост, а в поиске его нет. Или наоборот — удалил, а в поиске висит.

**Проблема 2: Нет транзакций**

```sql
BEGIN;
  INSERT INTO posts ...;
  -- Упс, ошибка!
ROLLBACK;
```

В Postgres откатили транзакцию, а в Elasticsearch данные уже залетели. Теперь у вас в поиске мусор.

**Проблема 3: Дублирование логики**

Поисковик не видит ваши JOIN'ы, внешние ключи, права доступа. Приходится дублировать всю бизнес-логику. Изменили схему в БД — не забудьте поменять маппинг в Elastic. Добавили роли — не забудьте фильтровать в поиске. Это как поддерживать два приложения вместо одного.

**Проблема 4: Еще один сервис в продакшене**

Еще одна точка отказа. Еще один мониторинг. Еще одно резервное копирование. Еще одна версия для обновления. Еще один сервис, который может упасть в 3 часа ночи.

**Сленг:** "Зоопарк технологий" — когда в проекте 10 разных сервисов, и никто не помнит, зачем половина из них.

---

## Слайд 5: PostgreSQL FTS — лучшее из двух миров

**Время: 3 мин**

**Ассоциация:** PostgreSQL FTS — это "best of both worlds", как iPhone (всё из коробки работает).

А теперь хорошие новости. PostgreSQL FTS дает вам:

**✅ Транзакционность (ACID)**
Откатили транзакцию — откатился и поиск. Всё атомарно.

**✅ Актуальность результатов (real-time)**
Вставили данные — они сразу доступны для поиска. Никаких refresh_interval как в Elastic.

**✅ Морфологический поиск**
"Разработчик", "разработчика", "разработке" — всё найдет.

**✅ Ранжирование по релевантности**
Как в Google — самое релевантное наверху.

**✅ Индексная поддержка**
GIN индекс — это inverted index, как в Elasticsearch. Быстро.

**✅ Нет "зоопарка технологий"**
Один сервис вместо двух. Один бэкап. Один мониторинг.

**Когда достаточно:** До 10-100 млн документов, простой поиск, нужна транзакционность.

**Когда нужен Elastic:** Миллиарды документов, сложная аналитика, ML-ранжирование.

**Правило:** Начинайте с Postgres FTS, мигрируйте на Elastic только когда упретесь в лимиты. Это как начинать с монолита, а не сразу с микросервисов.

---

## Слайд 6: Документы — tsvector

**Время: 5 мин**

**Ассоциация:** tsvector — это сериализованный JSON для поиска.

Окей, как это работает внутри? Postgres не ищет по сырому тексту. Он сначала превращает текст в специальный формат — **tsvector**.

```sql
SELECT to_tsvector('russian', 'Разработчики разрабатывают разработку');
-- Результат: 'разработ':1,2,3
```

Смотрите, что произошло:
- "Разработчики" → "разработ"
- "разрабатывают" → "разработ"
- "разработку" → "разработ"

Все три словоформы схлопнулись в одну **лексему** "разработ". Цифры 1,2,3 — это позиции слов в тексте (для фразового поиска).

**Почему это круто:**
1. **Компактность** — вместо трех слов храним одно
2. **Морфология** — все формы слова найдутся
3. **Скорость** — поиск по лексемам быстрее, чем по сырому тексту

**Сленг:** "Затсвекторить текст" — превратить текст в tsvector.

**Важно:** tsvector — это не просто массив слов. Это специальная структура данных, оптимизированная для поиска. Там еще веса лексем хранятся (A, B, C, D), позиции, всё отсортировано.

---

## Слайд 7: Запросы — tsquery

**Время: 5 мин**

**Ассоциация:** tsquery — это DSL для поисковых запросов, как WHERE условия, но для текста.

Теперь запросы. Вы не можете просто написать `WHERE tsvector = 'postgres'`. Нужен специальный формат — **tsquery**.

**Операторы:**

```sql
-- Простой поиск (одно слово)
'postgres'

-- Булева логика (как в Google)
'postgres & (performance | optimization)'
-- Найдет документы, где есть "postgres" И ("performance" ИЛИ "optimization")

-- Фразовый поиск (слова рядом)
'full <-> text <-> search'
-- Найдет только "full text search", именно в таком порядке

-- NOT оператор (исключаем мусор)
'python & !django'
-- Найдет "python", но без "django"
```

**Это как писать WHERE условия:**
- `&` = AND
- `|` = OR
- `!` = NOT
- `<->` = "следующее слово"

**Сленг:** "Забулить запрос" — написать сложный запрос с bool операторами.

**Важно:** Postgres сам оптимизирует tsquery. Если вы написали `'a | a'`, он упростит до `'a'`. Если `'a & !a'` — вернет пустой результат сразу.

---

## Слайд 8: Оператор соответствия @@

**Время: 4 мин**

**Ассоциация:** @@ — это как `==` для текстового поиска.

Теперь соединяем документ и запрос. Оператор **@@** проверяет, соответствует ли tsvector запросу tsquery.

```sql
SELECT * FROM articles 
WHERE to_tsvector('russian', content) @@ to_tsquery('postgres & performance');
```

**Что происходит:**
1. `to_tsvector('russian', content)` — превращаем текст статьи в tsvector
2. `to_tsquery('postgres & performance')` — превращаем запрос в tsquery
3. `@@` — проверяем соответствие

**Вернет только те статьи, где есть ОБА слова.**

**Важно:** Если вы пишете `to_tsvector` в WHERE без индекса — это full table scan. Каждую строку превращаем в tsvector и проверяем. Медленно! Поэтому нужны индексы (об этом позже).

**Сленг:** "Матчится" — документ соответствует запросу. "Не заматчилось" — не нашлось.

---

## Слайд 9: Релевантность — веса лексем

**Время: 5 мин**

**Ассоциация:** Веса лексем — это как приоритеты в CSS (A > B > C > D).

Окей, мы нашли документы. Но как их отсортировать? Какой документ релевантнее?

**Веса лексем (A, B, C, D):**
- **A** — заголовок (самый важный)
- **B** — подзаголовок
- **C** — аннотация
- **D** — тело документа (default)

```sql
SELECT ts_rank(
  setweight(to_tsvector(title), 'A') ||   -- Заголовок весит больше
  setweight(to_tsvector(body), 'D'),      -- Тело весит меньше
  query
) as rank
```

**Логика:** Если слово нашлось в заголовке — это важнее, чем если оно в теле документа. Как в Google: слово в title страницы весит больше, чем в футере.

**Оператор ||** — конкатенация tsvector'ов. Склеиваем заголовок и тело в один документ.

**Пример:**
- Статья 1: "PostgreSQL" в заголовке → высокий ранг
- Статья 2: "PostgreSQL" в теле → низкий ранг

**Сленг:** "Забустить ранг" — увеличить вес лексем, чтобы документ был выше в результатах.

---

## Слайд 10: Функции ранжирования

**Время: 5 мин**

**Ассоциация:** ts_rank — это как лайки в соцсетях (чем больше, тем выше).

Две основные функции для ранжирования:

**1. ts_rank — по частоте (TF — Term Frequency)**

Считает, сколько раз слово встретилось в документе. Чем больше — тем выше ранг.

```sql
SELECT title, ts_rank(fts, query) AS rank
FROM articles, to_tsquery('russian', 'postgres') query
WHERE fts @@ query
ORDER BY rank DESC;
```

**Логика:** Если в статье "postgres" встречается 10 раз, она релевантнее, чем где оно встречается 1 раз.

**2. ts_rank_cd — учитывает близость (proximity)**

Не только частота, но и насколько близко слова друг к другу.

**Пример:**
- Документ 1: "postgres" и "performance" рядом → высокий ранг
- Документ 2: "postgres" в начале, "performance" в конце → низкий ранг

**RUM индекс — это GIN на стероидах:**

Оператор `<=>` возвращает "расстояние" между документом и запросом.

```sql
SELECT * FROM docs 
ORDER BY fts <=> query;
-- Index Scan using rum_idx
```

**Магия:** Сортировка происходит прямо по индексу, без вычислений в памяти! Это как LIMIT с индексом, но для релевантности.

**Чего нет:** TF-IDF (редкость слова в корпусе) и "найди похожие документы" (как в Elasticsearch "More Like This"). Для этого нужны векторные БД или pgvector расширение.

**Сленг:** "Проранжировать результаты" — отсортировать по релевантности.
