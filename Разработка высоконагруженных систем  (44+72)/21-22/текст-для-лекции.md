# Текст лекции: OpenSearch - Поиск и аналитика для хайлоадов (60 мин)

## Слайд 1: Титульный (1 мин)

Всем привет! Сегодня разберём OpenSearch - это как Google, только для ваших данных. Если вы когда-нибудь задумывались, как Wildberries или Ozon ищут товары среди миллионов позиций за миллисекунды - вот это оно и есть.

## Слайд 2: Что такое OpenSearch? (2 мин)

OpenSearch - это распределённая поисковая машина. Представьте библиотеку на миллион книг, где вы можете найти любую фразу за секунду. Магия? Нет, просто правильная индексация.

Три главных применения:
1. **Поисковая строка** - когда пользователь вбивает "красные кроссовки 42 размер" и получает результат мгновенно
2. **Анализ логов** - когда у вас 100 серверов пишут логи, и вам нужно найти, где упало
3. **Аналитика BigData** - когда нужно посчитать, сколько пользователей из Москвы купили айфоны в пятницу

И самое крутое - масштабируется от вашего ноутбука до сотен серверов. Начали с одной машины, выросли - добавили ещё. Без переписывания кода.

## Слайд 3: SQL и DSL в OpenSearch (3 мин)

OpenSearch говорит на двух языках. Как программист, который знает и Python, и JavaScript.

**SQL** - это для аналитиков и тех, кто привык к обычным базам данных. Пишете `SELECT name, gpa FROM students WHERE gpa > 4.0` - и всё понятно. Просто, читаемо, но ограниченно.

**DSL** - Domain Specific Language. Это JSON-запросы. Выглядит страшнее, но даёт полный контроль. Как разница между автоматом и механикой в машине. Автомат проще, механика - больше возможностей.

Когда что использовать? SQL - для быстрых отчётов, дашбордов, когда подключаете BI-инструменты типа Tableau. DSL - когда нужен полнотекстовый поиск, сложная логика, максимальная производительность.

## Слайд 4-5: Примеры SQL vs DSL (3 мин)

Смотрите на примеры. SQL ищет по имени - просто LIKE. DSL делает то же самое через match, но под капотом работает мощный анализатор текста.

Второй пример - комбинированные условия. SQL: WHERE gpa >= 4.0 AND grad_year = 2023. DSL: bool query с must. Выглядит сложнее, но даёт больше контроля над релевантностью.

## Слайд 6: Сравнение SQL vs DSL (2 мин)

Таблица сравнения. Запомните главное:
- SQL проще, но не все функции доступны
- DSL сложнее, но даёт полный доступ ко всем фичам OpenSearch
- Производительность DSL выше, потому что нет промежуточного слоя трансляции

В продакшене обычно используют DSL. SQL - для аналитиков и быстрых запросов.

## Слайд 7: Документ (2 мин)

Документ - это единица хранения. JSON-объект. Как строка в таблице SQL, но без жёсткой схемы.

Ассоциация: документ = карточка студента в деканате. На карточке написано имя, средний балл, год выпуска. Всё в одном месте.

Важно: документы в OpenSearch не связаны между собой. Нет JOIN'ов как в SQL. Это NoSQL подход - денормализация данных.

## Слайд 8: Индекс (2 мин)

Индекс - коллекция документов. Как таблица в SQL, но без жёсткой схемы. Можете добавить документ с новым полем - OpenSearch сам поймёт тип.

Ассоциация: индекс = папка с карточками всех студентов. Открыли папку "students" - там все студенты.

В одном кластере может быть сотни индексов. Обычно делят по времени: logs-2025-01, logs-2025-02. Или по типу данных: products, users, orders.

## Слайд 9: Кластеры и узлы (3 мин)

Кластер - это группа серверов, работающих вместе. Узел - один сервер.

Ассоциация: кластер = команда разработчиков, узел = один девелопер. Каждый делает свою часть работы, но вместе решают большую задачу.

Типы узлов:
- **Master-node** - как тимлид. Координирует, кто что делает, но сам данные не хранит
- **Data-node** - как обычный разраб. Хранит данные и выполняет поиск
- **Ingest-node** - как ETL-разработчик. Обрабатывает данные перед сохранением

В продакшене обычно разделяют роли. Master отдельно, data отдельно. Так надёжнее.

## Слайд 10: Шарды (3 мин)

Проблема: у вас индекс на 400 ГБ. Один сервер не потянет. Что делать?

Решение: шардирование. Режем индекс на куски. Как пиццу на 8 частей - каждый берёт свой кусок.

Золотое правило: размер шарда 10-50 ГБ. Меньше - слишком много overhead. Больше - долго восстанавливается при падении.

Важный момент: каждый шард = отдельный процесс Lucene. Жрёт CPU и RAM. Не делайте 1000 шардов на маленьком кластере - убьёте производительность.

## Слайд 11: Primary и Replica шарды (3 мин)

Primary shard - оригинал. Replica shard - копия для отказоустойчивости.

По умолчанию 1 реплика. То есть каждый кусок данных хранится в двух экземплярах на разных серверах.

Зачем реплики?
1. **Отказоустойчивость** - упал сервер, данные не потеряны
2. **Скорость поиска** - запросы распределяются между primary и replica

В продакшене обычно делают 1-2 реплики. Больше - расточительно, меньше - рискованно.

## Слайд 12: Инвертированный индекс (3 мин)

Это магия, которая делает поиск быстрым. Инвертированный индекс - это структура данных: слово → документы.

Ассоциация: индекс в конце учебника. Ищете слово "алгоритм" - видите страницы 15, 42, 108. Не нужно листать весь учебник.

OpenSearch делает то же самое. При индексации разбивает текст на слова, строит индекс. При поиске смотрит в индекс - бам, результат за миллисекунды.

Бонус: OpenSearch хранит позицию слова. Поэтому может искать фразы "красные кроссовки" - именно в таком порядке.

## Слайд 13: Релевантность (2 мин)

Релевантность - это оценка, насколько документ подходит под запрос. Алгоритм BM25.

Три фактора:
1. **TF** (Term Frequency) - чем чаще слово в документе, тем выше балл
2. **IDF** (Inverse Document Frequency) - чем реже слово в коллекции, тем выше балл
3. **Длина документа** - короткие документы ранжируются выше

Пример: ищете "Python". Документ, где слово встречается 10 раз, получит выше балл, чем где 1 раз. Но если это слово "и" - балл низкий, потому что встречается везде.

## Слайд 14: REST API (1 мин)

OpenSearch - это HTTP API. Отправляете GET/POST/PUT/DELETE запросы, получаете JSON ответы.

Три способа работы:
1. cURL в терминале - для скриптов
2. Dev Tools в OpenSearch Dashboards - для разработки
3. HTTP-клиенты типа Postman - для тестирования

## Слайд 15: Dev Tools (1 мин)

Dev Tools - это встроенная консоль в OpenSearch Dashboards. Как Chrome DevTools, только для OpenSearch.

Пишете `GET _cluster/health`, жмёте Ctrl+Enter - получаете ответ. Есть автодополнение, подсветка синтаксиса, история запросов. Очень удобно для разработки.

## Слайд 16-18: CRUD операции (4 мин)

**Create** - PUT /students/_doc/1 с JSON телом. Создаёте документ с ID=1. Если ID не указать - сгенерируется автоматически.

**Read** - GET /students/_search. Ищете документы. match_all - вернёт всё.

Ключевые поля ответа:
- took - время в миллисекундах
- hits.total - сколько нашли
- _score - релевантность
- _source - сам документ

**Update** - два способа. PUT - полная замена. POST _update - частичное обновление. В продакшене чаще используют частичное - меньше трафика.

## Слайд 19-20: Update и Delete (2 мин)

Update бывает полный и частичный. Полный - заменяете весь документ. Частичный - только нужные поля.

Delete - удаляете документ или целый индекс. Осторожно с DELETE индекса - это необратимо. В продакшене обычно делают snapshot перед удалением.

## Слайд 21: Явное создание индекса (2 мин)

Можно создать индекс явно с настройками. Указываете количество шардов, маппинг полей.

Важно: количество primary шардов нельзя изменить после создания. Поэтому планируйте заранее. Обычно делают 3-5 шардов на индекс.

## Слайд 22: Bulk API (2 мин)

Bulk API - массовая загрузка данных. Вместо 1000 запросов делаете 1 запрос с 1000 документами.

Формат специфический - каждая строка отдельный JSON. Первая строка - метаданные, вторая - данные.

В продакшене всегда используют bulk. Производительность в 10-100 раз выше, чем по одному документу.

Жаргон: "залили данные через bulk" = загрузили много данных за раз.

## Слайд 23-24: Query String vs Query DSL (2 мин)

Query String - простой способ. GET /students/_search?q=name:иван. Удобно для быстрых запросов, но ограниченно.

Query DSL - мощный способ. JSON с полным контролем. match - полнотекстовый поиск с анализатором.

В продакшене используют DSL. Query String - только для дебага.

## Слайд 25-27: Фильтры и диапазоны (3 мин)

**keyword** - точное совпадение. Ищете "Иван Петров" - найдёт только полное совпадение.

**Фильтры** - бинарный результат без релевантности. Быстрее, результаты кэшируются. Используйте для точных значений: год, статус, категория.

**Диапазоны** - range query. gt (>), gte (≥), lt (<), lte (≤). Для чисел, дат, строк.

Важно: фильтры не влияют на _score. Используйте их для условий типа "только активные пользователи".

## Слайд 28: Bool query (2 мин)

Bool query - комбинация условий. Как WHERE в SQL, но мощнее.

Четыре типа:
- **must** - обязательно (AND), влияет на релевантность
- **should** - желательно (OR), влияет на релевантность
- **must_not** - исключить (NOT)
- **filter** - обязательно, но без релевантности

В продакшене обычно комбинируют: must для поиска, filter для условий.

## Слайд 29: Типы запросов (1 мин)

Два типа запросов:
1. **Листовые** - конечные запросы: match, term, range
2. **Составные** - комбинируют другие запросы: bool, dis_max

Запомните: match для текста, term для точных значений, range для диапазонов.

## Слайд 30: Ресурсоёмкие запросы (2 мин)

Дорогие запросы - fuzzy, prefix, regexp, wildcard. Они сканируют весь индекс, медленные.

Защита: можно отключить через настройки кластера. В продакшене обычно отключают или ограничивают.

Жаргон: "дорогой запрос" = ресурсоёмкий, медленный запрос.

## Слайд 31-32: Filter vs Query context (2 мин)

**Filter context** - бинарный результат (да/нет), кэшируется, быстрый. Для условий типа "статус = активный".

**Query context** - вычисляет релевантность, сортирует, медленнее. Для поиска текста.

Ассоциация: фильтр = сито (пропускает или нет), запрос = экзамен (оценивает качество).

В продакшене комбинируют: query для поиска, filter для условий.

## Слайд 33: Термовые vs полнотекстовые (1 мин)

Термовые - точное совпадение, без анализатора. Для keyword полей.

Полнотекстовые - с анализатором, релевантность. Для text полей.

Главное правило: не используйте term для text полей - не найдёт ничего.

## Слайд 34-35: Примеры (2 мин)

Термовый запрос ищет точную фразу "To be, or not to be" - не найдёт, потому что в индексе хранятся отдельные слова.

Полнотекстовый запрос разбивает фразу на слова, ищет документы с этими словами - найдёт тысячи.

## Слайд 36-37: Рекомендации (2 мин)

Что делать:
1. keyword для точных значений
2. text для текста
3. filter для фильтрации
4. query для поиска
5. Размер шарда 10-50 ГБ
6. Включите slow logs

Чего не делать:
1. term для text полей
2. Слишком много шардов
3. Дорогие запросы без необходимости
4. Забывать про реплики

## Слайд 38: Глоссарий (1 мин)

Жаргон программистов:
- **Шардить** - делить индекс на части
- **Скор** - релевантность
- **Булевый запрос** - bool query
- **Фаззи поиск** - поиск с опечатками
- **Дорогой запрос** - медленный запрос
- **Залить данные** - загрузить через bulk
- **Маппинг** - схема полей

## Слайд 39: Итоги (2 мин)

Основные концепции:
1. Документ - JSON объект
2. Индекс - коллекция документов
3. Шард - часть индекса
4. Реплика - копия шарда
5. Query DSL - язык запросов
6. Filter vs Query - фильтр быстрее, запрос умнее

Главное правило: используйте правильный тип запроса для правильного типа поля!

## Заключение (1 мин)

OpenSearch - мощный инструмент для поиска и аналитики. Масштабируется от ноутбука до сотен серверов. Используется в Wildberries, Ozon, Яндексе.

Начните с простого - один узел, один индекс. Потом масштабируйте по мере роста. OpenSearch растёт вместе с вами.

Вопросы?
