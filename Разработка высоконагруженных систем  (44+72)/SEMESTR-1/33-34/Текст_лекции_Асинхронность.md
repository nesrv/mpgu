# Текст лекции: Асинхронность и WebSocket
## Подготовка к GraphQL Subscriptions

**Длительность:** 60 минут  
**Аудитория:** 4 курс, специальность "Информационные системы и технологии"  
**Лектор:** Профессор, сениор-архитектор

---

## Слайд 1: Титульный (1 минута)

Добрый день, коллеги! Сегодня мы с вами разберем фундаментальные концепции, без которых невозможно создавать современные высоконагруженные системы. 

Представьте себе ситуацию: вы создали отличный GraphQL API, он работает, все довольны. Но вот приходит момент, когда нужно показывать данные в реальном времени. Новое сообщение появилось — и все пользователи должны его увидеть мгновенно. Не через 5 секунд после обновления страницы, а прямо сейчас.

Вот здесь на сцену выходят асинхронность и WebSocket. Это не просто модные слова — это инструменты, которые позволяют создавать системы, способные обрабатывать тысячи одновременных соединений без падения производительности.

Сегодня мы подготовимся к лабораторной работе, где вы реализуете GraphQL Subscriptions с WebSocket и Redis. Но сначала нужно понять фундамент — как работает асинхронность в Python, что такое корутины, и как все это связано с реальными задачами.

---

## Слайд 2: План занятия (2 минуты)

Давайте посмотрим, что нас ждет сегодня. Мы пройдем путь от базовых концепций до практических примеров.

**Сокеты** — это основа. Представьте, что сокет — это как телефонная розетка, но для программ. Через нее ваше приложение общается с внешним миром.

**Асинхронность** — это философия. Вместо того чтобы ждать, пока одна задача завершится, мы переключаемся на другие. Как опытный официант в ресторане: принимает заказы от всех столов, пока на кухне готовится еда.

**asyncio** — это инструментарий Python для асинхронного программирования. Библиотека, которая делает магию возможной.

**aiohttp** — это асинхронный HTTP клиент и сервер. Если requests — это такси, которое везет вас по одному маршруту, то aiohttp — это метро, где много поездов едут параллельно.

**AsyncIterator** — это ключ к GraphQL Subscriptions. Позволяет передавать данные потоком, как водопровод, а не ведрами.

**asyncio.gather** — это способ запустить несколько задач одновременно. Как если бы вы могли одновременно варить кофе, жарить яичницу и тосты — и все готово за время самого долгого процесса.

И в конце — практические примеры, которые покажут, как все это работает вместе.

---

## Слайд 3: Что такое сокеты? (3 минуты)

Итак, сокеты. Что это такое? 

Представьте, что ваше приложение — это дом. Сокет — это дверь в этот дом. Через эту дверь приходят гости (клиенты), уходят ответы. Но это не простая дверь — это дверь с умной системой безопасности, которая знает, кто пришел, откуда, и может управлять потоком гостей.

Технически, сокет — это программный интерфейс к сетевому стеку операционной системы. Посмотрите на схему на слайде: ваше Python-приложение работает на верхнем уровне, но когда нужно отправить данные в сеть, оно обращается к сокетам. Сокеты передают данные в TCP или UDP протоколы, которые работают на уровне операционной системы. Дальше идет IP-уровень, и наконец — физическая сетевая карта.

Почему это важно? Потому что сокеты — это самый низкоуровневый способ работы с сетью в приложениях. Все остальное — HTTP-библиотеки, фреймворки — это обертки над сокетами. FastAPI, Flask, Django — все они в конечном итоге используют сокеты.

Аналогия: сокет — это как телефонная розетка для программ. Вы подключаете "телефон" (ваше приложение) к "розетке" (сокету), и можете общаться с другими "телефонами" в сети.

В Python работа с сокетами выглядит так: вы создаете сокет, привязываете его к адресу и порту, и начинаете слушать входящие соединения. Но это синхронный подход — один клиент за раз. А нам нужна асинхронность.

---

## Слайд 4: Зачем нужны сокеты? (3 минуты)

Хорошо, зачем нам вообще нужны сокеты, если есть готовые библиотеки?

**Прямой доступ к сетевому стеку ОС** — это как иметь прямой доступ к двигателю автомобиля, а не только к рулю. Вы можете настроить все параметры соединения: таймауты, буферы, параметры TCP.

**Минимальные накладные расходы** — нет лишних слоев абстракции. Каждый байт данных идет напрямую, без лишних преобразований.

**Полный контроль** — вы решаете, когда открывать соединение, когда закрывать, как обрабатывать ошибки.

**Стандартный API** — сокеты работают одинаково во всех языках и операционных системах. Один раз поняли — применили везде.

Где это используется? HTTP-серверы — FastAPI, Flask под капотом используют сокеты. WebSocket соединения — это тоже сокеты, только с постоянным соединением. TCP/UDP клиенты и серверы — игры, стриминг, чаты. Низкоуровневая работа с сетью — когда нужен полный контроль.

Но есть проблема: классические сокеты блокирующие. Когда вы вызываете `socket.recv()`, программа останавливается и ждет данных. Это как стоять у двери и ждать почтальона — пока он не придет, вы ничего другого делать не можете.

Вот здесь и нужна асинхронность. Но сначала давайте поймем, что такое корутины.

---

## Слайд 5: Корутины (Coroutines) (4 минуты)

Корутины — это одна из самых важных концепций в асинхронном программировании. 

Представьте обычную функцию. Она работает как лифт: вы нажали кнопку, лифт поехал, вы ждете, лифт приехал, вы выходите. Пока лифт едет, вы ничего не можете делать.

Корутина — это как эскалатор. Вы встали на него, он везет вас, но вы можете в любой момент сойти, сделать что-то другое, и вернуться обратно. Корутина может приостановить свое выполнение, дать возможность другим задачам поработать, а потом вернуться и продолжить.

Посмотрите на код на слайде. Обычная функция `normal_function()` — это просто возврат значения. А `coroutine_function()` — это async функция. Ключевое слово `async def` говорит Python: "Это корутина, она может приостанавливаться".

Внутри корутины мы используем `await asyncio.sleep(1)`. Это не просто задержка — это сигнал Event Loop: "Я жду, переключись на другие задачи". Event Loop — это диспетчер, который управляет всеми корутинами.

**Ключевые слова:**
- `async def` — определяет корутину. Это как сказать: "Эта функция может работать асинхронно".
- `await` — приостанавливает выполнение, ждет результат. Но не блокирует весь поток!
- `asyncio.run()` — запускает корутину в Event Loop. Это точка входа в асинхронный мир.

Аналогия: корутины — это как жонглер, который может держать несколько шаров в воздухе одновременно. Пока один шар летит, он переключается на другой.

---

## Слайд 6: async/await синтаксис (4 минуты)

Давайте разберем синтаксис подробнее. Это основа всего асинхронного программирования в Python.

Посмотрите на пример. У нас есть корутина `fetch_data(url)`, которая имитирует запрос к API. Внутри мы используем `await asyncio.sleep(1)` — это не блокирующая задержка. Event Loop может в это время обработать другие задачи.

В корутине `main()` мы вызываем `fetch_data` с `await`. Это значит: "Жди результат, но пока ждешь, дай другим задачам поработать".

**Важно понимать:**
- `await` можно использовать только внутри `async def`. Это как правило игры — нельзя использовать await в обычной функции.
- `await` не блокирует весь поток, только текущую корутину. Это ключевое отличие от синхронного кода.

Представьте ситуацию: вы делаете три HTTP-запроса к разным API. В синхронном коде это займет 3 секунды (по секунде на каждый). В асинхронном коде все три запроса могут выполняться параллельно — и это займет всего 1 секунду.

Но есть нюанс: `await` работает только внутри async функций. Это как правило: нельзя использовать await в обычной функции, только в корутине.

---

## Слайд 7: asyncio - основы (4 минуты)

asyncio — это библиотека стандартной библиотеки Python для асинхронного программирования. Появилась в Python 3.4, стала стабильной в 3.5, и с тех пор — это стандарт для асинхронного кода.

Посмотрите на простой пример. Мы создаем корутину `my_task()`, которая выполняет какую-то работу. `asyncio.run(my_task())` — это точка входа. Она создает Event Loop, запускает корутину, и когда корутина завершается, закрывает Event Loop.

**Основные функции asyncio:**

`asyncio.run()` — запуск Event Loop. Это как включить двигатель автомобиля — без этого ничего не работает.

`asyncio.sleep()` — асинхронная задержка. В отличие от `time.sleep()`, она не блокирует поток. Event Loop может в это время обработать другие задачи.

`asyncio.gather()` — параллельное выполнение нескольких корутин. Это как запустить несколько процессов одновременно и дождаться всех результатов.

`asyncio.create_task()` — создание задачи из корутины. Задача — это корутина, которая уже запущена в Event Loop.

Аналогия: asyncio — это как диспетчер аэропорта. Он управляет множеством самолетов (корутин), следит, чтобы они не сталкивались, переключается между ними, и все работает эффективно.

---

## Слайд 8: asyncio.sleep vs time.sleep (5 минут)

Это критически важное различие! Многие новички путают эти две функции, и это приводит к проблемам.

`time.sleep(1)` — это блокирующая задержка. Когда вы вызываете эту функцию, весь поток останавливается на 1 секунду. Ничего другого в это время не может выполняться. Это как стоять в очереди и ждать — пока не подойдет ваша очередь, вы ничего не делаете.

`asyncio.sleep(1)` — это неблокирующая задержка. Когда вы вызываете `await asyncio.sleep(1)`, корутина говорит Event Loop: "Я буду ждать секунду, но ты можешь в это время обработать другие задачи". Event Loop переключается на другие корутины, а через секунду возвращается к этой.

Посмотрите на пример с `bad()` и `good()`. В `bad()` мы используем `time.sleep()` — это блокирует Event Loop, и оба вызова выполняются последовательно. Итого 2 секунды.

В `good()` мы используем `asyncio.gather()` с `asyncio.sleep()`. Оба вызова выполняются параллельно, и общее время — 1 секунда.

**Практический пример:** Представьте, что у вас есть веб-сервер, который обрабатывает запросы. Если вы используете `time.sleep()` в обработчике, то пока один запрос ждет, все остальные запросы тоже ждут. Сервер "замерзает". С `asyncio.sleep()` сервер может обрабатывать другие запросы, пока один ждет.

Это как разница между одним кассиром в магазине (time.sleep) и несколькими кассами (asyncio.sleep). В первом случае все стоят в одной очереди, во втором — очередь распределяется между кассами.

---

## Слайд 9: asyncio.gather - параллельное выполнение (5 минут)

`asyncio.gather()` — это один из самых мощных инструментов в asyncio. Он позволяет запустить несколько корутин параллельно и дождаться всех результатов.

Посмотрите на пример. У нас есть функция `fetch_user(id)`, которая имитирует запрос к базе данных. В синхронном коде мы бы вызывали ее три раза последовательно — и это заняло бы 1.5 секунды (по 0.5 секунды на каждый запрос).

Но с `asyncio.gather()` мы запускаем все три запроса одновременно. Они выполняются параллельно, и общее время — всего 0.5 секунды (время самого долгого запроса).

**Как это работает:** `gather()` принимает корутины (или задачи) и запускает их все одновременно в Event Loop. Event Loop переключается между ними, и когда все завершаются, `gather()` возвращает результаты в том же порядке, в котором были переданы корутины.

Аналогия: Представьте, что вы готовите ужин. У вас есть три блюда, каждое готовится 10 минут. Если готовить последовательно — это 30 минут. Но если у вас три конфорки, вы можете готовить все одновременно — и это займет 10 минут.

**Важно:** `gather()` ждет завершения всех корутин. Если одна из них упадет с ошибкой, по умолчанию `gather()` тоже упадет. Но можно использовать `return_exceptions=True`, чтобы получить исключения как результаты.

Это как командная работа: все должны закончить свою часть, чтобы проект был готов. Но если кто-то не справился, вы можете обработать это и продолжить с остальными.

---

## Слайд 10: asyncio.gather - пример (4 минуты)

Давайте посмотрим на практический пример с реальным HTTP-запросом.

У нас есть три URL, с которых нужно получить данные. В синхронном коде с библиотекой `requests` это заняло бы 3 секунды (по секунде на каждый запрос).

Но с `aiohttp` и `asyncio.gather()` все три запроса выполняются параллельно. `aiohttp.ClientSession()` создает сессию, которая может обрабатывать множество запросов одновременно. `asyncio.gather()` запускает все запросы параллельно, и мы получаем все результаты одновременно.

**Преимущество:** 3 запроса за время 1 запроса! Это не магия — это эффективное использование ресурсов. Пока один запрос ждет ответа от сервера, Event Loop обрабатывает другие запросы.

В реальных проектах это может означать разницу между 10 секундами и 1 секундой при загрузке данных с 10 разных API. Пользователь получает данные в 10 раз быстрее!

Аналогия: Представьте, что вы заказываете пиццу, суши и бургер из трех разных ресторанов. В синхронном подходе вы бы ждали пиццу, потом суши, потом бургер — это долго. В асинхронном подходе вы заказываете все одновременно, и получаете все, когда готово самое долгое блюдо.

---

## Слайд 11: AsyncIterator - асинхронные итераторы (5 минут)

AsyncIterator — это следующая ступень в понимании асинхронности. Это итератор, который работает асинхронно.

Обычный итератор работает синхронно. Когда вы делаете `for i in range(10)`, Python генерирует значения одно за другим, и пока не получите следующее значение, вы не можете делать ничего другого.

Асинхронный итератор работает по-другому. Когда вы делаете `async for value in async_iterator()`, итератор может приостановиться на `await`, дать возможность другим задачам поработать, а потом продолжить.

Посмотрите на пример. В `async_iterator()` мы используем `await asyncio.sleep(0.1)` перед каждым `yield`. Это не блокирует Event Loop — он может обрабатывать другие задачи, пока итератор ждет.

**Использование:** `async for` — это специальный синтаксис для итерации по асинхронным итераторам. Он работает как обычный `for`, но понимает `await` внутри итератора.

Аналогия: Обычный итератор — это как конвейер на заводе, где детали идут одна за другой, и вы не можете переключиться на другую линию. Асинхронный итератор — это как несколько конвейеров, и вы можете переключаться между ними, пока один ждет.

**Почему это важно для GraphQL Subscriptions?** Потому что подписки — это поток данных. Новые сообщения приходят не все сразу, а по мере появления. AsyncIterator позволяет обрабатывать их по мере поступления, не блокируя другие операции.

---

## Слайд 12: AsyncIterator в GraphQL Subscriptions (5 минут)

Вот здесь все сходится! GraphQL Subscriptions используют AsyncIterator для передачи данных в реальном времени.

Посмотрите на код. У нас есть класс `Subscription` с методом `message_added()`, который возвращает `AsyncIterator[MessageType]`. Это означает, что метод будет генерировать объекты `MessageType` по мере их появления.

Внутри метода мы используем `async for message_data in pubsub.subscribe("messages")`. Это подписка на канал "messages" через Pub/Sub систему. Когда в канале появляется новое сообщение, оно попадает в итератор.

`yield MessageType(**message_data)` отправляет данные клиенту через WebSocket. Каждый `yield` — это новое событие, которое клиент получает в реальном времени.

**Как это работает:**
1. Клиент подписывается через WebSocket. Устанавливается постоянное соединение.
2. `async for` получает события из pub/sub. Это неблокирующая операция — Event Loop может обрабатывать другие задачи.
3. `yield` отправляет каждое событие клиенту. Это происходит мгновенно, как только событие появляется.
4. Event Loop не блокируется! Пока одна подписка ждет события, другие подписки и запросы могут обрабатываться.

Аналогия: Представьте радиостанцию. Мутация — это диджей, который публикует новую песню (событие). Pub/Sub — это радиоволны, которые передают сигнал. Subscription — это радиоприемник (клиент), который настроен на эту волну и получает песни в реальном времени. AsyncIterator — это механизм, который позволяет получать песни по мере их появления, не пропуская ни одной.

---

## Слайд 13: aiohttp - асинхронный HTTP (4 минуты)

aiohttp — это асинхронная библиотека для работы с HTTP. Она может работать и как клиент, и как сервер.

**HTTP Клиент:** Посмотрите на пример `fetch_data()`. Мы создаем `ClientSession()`, которая управляет соединениями. `session.get()` делает асинхронный HTTP-запрос. `await response.json()` читает ответ, но не блокирует Event Loop.

**HTTP Сервер:** Мы создаем `web.Application()`, добавляем роутер с обработчиком, и запускаем сервер. Обработчик — это корутина, которая может обрабатывать множество запросов одновременно.

**Преимущества:** aiohttp не блокирует Event Loop! Пока один запрос ждет ответа от сервера, Event Loop может обрабатывать другие запросы. Это позволяет обрабатывать тысячи одновременных соединений на одном потоке.

Аналогия: `requests` — это как один официант в ресторане. Он обслуживает один стол, потом переходит к следующему. `aiohttp` — это как опытный официант, который принимает заказы от всех столов, передает их на кухню, и пока готовится еда, обслуживает другие столы.

В реальных проектах это означает, что один сервер может обрабатывать в 10-100 раз больше запросов, чем синхронный сервер с тем же железом.

---

## Слайд 14: aiohttp vs requests (4 минуты)

Давайте сравним `requests` и `aiohttp` на конкретном примере.

**requests — блокирующий:** Когда вы вызываете `requests.get()`, программа останавливается и ждет ответа. Если у вас три запроса, они выполняются последовательно — это 3 секунды.

**aiohttp — неблокирующий:** Все три запроса запускаются одновременно через `asyncio.gather()`. Пока один ждет ответа, Event Loop обрабатывает другие. Общее время — 1 секунда (время самого долгого запроса).

**Разница в производительности:** В синхронном коде для обработки 1000 запросов по 1 секунде каждый, вам нужно 1000 секунд (если делать последовательно) или много потоков (что накладно по памяти). В асинхронном коде те же 1000 запросов обрабатываются за ~1 секунду на одном потоке!

Аналогия: `requests` — это как один кассир в магазине. Все стоят в одной очереди. `aiohttp` — это как умная система, которая распределяет клиентов между кассами, и пока один клиент ищет деньги, кассир обслуживает следующего.

**Когда использовать что:**
- `requests` — для простых скриптов, где не нужна высокая производительность.
- `aiohttp` — для веб-серверов, API-клиентов, где важна производительность и масштабируемость.

---

## Слайд 15: aiohttp WebSocket сервер (5 минут)

WebSocket — это протокол для постоянного двустороннего соединения. В отличие от HTTP, где клиент делает запрос и получает ответ, WebSocket устанавливает постоянное соединение, через которое можно отправлять данные в обе стороны.

Посмотрите на код. `websocket_handler` — это обработчик WebSocket соединения. `await ws.prepare(request)` поднимает WebSocket соединение — это как "рукопожатие" между клиентом и сервером.

`async for msg in ws:` — это цикл, который получает сообщения от клиента в реальном времени. Это неблокирующая операция — Event Loop может обрабатывать другие соединения, пока одно ждет сообщения.

Когда приходит текстовое сообщение, мы отправляем ответ через `await ws.send_str()`. Это тоже неблокирующая операция.

**Использование:** GraphQL Subscriptions работают через WebSocket! Когда клиент подписывается на событие, устанавливается WebSocket соединение, и через него передаются события в реальном времени.

Аналогия: HTTP — это как телефонный звонок. Вы звоните, говорите, кладете трубку. WebSocket — это как видеозвонок, который идет постоянно. Вы можете говорить в любой момент, и собеседник слышит вас мгновенно.

В реальных приложениях WebSocket используется для чатов, уведомлений, онлайн-игр, мониторинга в реальном времени — везде, где нужна мгновенная передача данных.

---

## Слайд 16: WebSocket клиент (aiohttp) (3 минуты)

Клиентская сторона WebSocket работает аналогично. Мы создаем сессию, подключаемся к WebSocket серверу через `ws_connect()`, и можем отправлять и получать сообщения.

`await ws.send_str()` отправляет сообщение серверу. `async for msg in ws:` получает сообщения в реальном времени. Это неблокирующая операция — пока ждем сообщения, Event Loop может обрабатывать другие задачи.

**Важно:** `async for` позволяет получать сообщения в реальном времени! Как только сервер отправляет сообщение, клиент его получает. Нет задержек, нет polling — все происходит мгновенно.

Аналогия: Это как walkie-talkie. Вы нажали кнопку, сказали, отпустили — и собеседник сразу слышит. И наоборот — когда он говорит, вы сразу слышите.

---

## Слайд 17: Pub/Sub паттерн (5 минут)

Pub/Sub (Publish/Subscribe) — это паттерн проектирования для передачи событий. Это как система подписки на новости.

**Publisher (Издатель)** публикует события в каналы. Например, когда создается новое сообщение, оно публикуется в канал "messages".

**Subscribers (Подписчики)** подписываются на каналы и получают события. Может быть много подписчиков на один канал — все получат событие.

Посмотрите на схему. Publisher отправляет событие в канал, и все подписчики этого канала получают это событие одновременно.

**В GraphQL Subscriptions:**
- Мутация = Publisher. Когда пользователь создает сообщение через мутацию, она публикует событие.
- Subscription = Subscriber. Клиенты подписываются на события и получают их в реальном времени.

Аналогия: Представьте газету. Редакция (Publisher) публикует новость. Все подписчики (Subscribers) получают эту новость одновременно. Но если вы не подписаны, вы не получите новость.

**Преимущества Pub/Sub:**
- Разделение ответственности. Publisher не знает, кто подписан.
- Масштабируемость. Можно добавить сколько угодно подписчиков.
- Гибкость. Подписчики могут подписываться на разные каналы.

В нашей лабораторной работе мы реализуем простой Pub/Sub менеджер с использованием `asyncio.Queue`. В production обычно используют Redis или RabbitMQ.

---

## Слайд 18: Pub/Sub с AsyncIterator (5 минут)

Вот как Pub/Sub работает с AsyncIterator. Это ключевой момент для понимания GraphQL Subscriptions.

Посмотрите на класс `PubSubManager`. У него есть словарь `subscribers`, где ключ — это название канала, а значение — список очередей для подписчиков.

Метод `subscribe()` создает очередь для подписчика и добавляет ее в список подписчиков канала. Затем в бесконечном цикле `while True` мы ждем сообщения из очереди через `await queue.get()`. Когда сообщение приходит, мы `yield` его — это отправляет данные подписчику через AsyncIterator.

Метод `publish()` берет все очереди подписчиков канала и отправляет сообщение в каждую очередь через `await queue.put()`.

**Как это работает вместе:**
1. Подписчик вызывает `subscribe("messages")` и получает AsyncIterator.
2. Внутри `async for` ждет сообщения из очереди.
3. Publisher вызывает `publish("messages", data)`.
4. Сообщение попадает во все очереди подписчиков.
5. Подписчики получают сообщение через `yield`.

Аналогия: Представьте почтовые ящики. У каждого подписчика есть свой ящик (очередь). Когда Publisher отправляет письмо (событие), почтальон кладет копию в каждый ящик. Подписчики забирают письма из своих ящиков.

---

## Слайд 19: Полный пример: Pub/Sub + AsyncIterator (4 минуты)

Давайте посмотрим на полный рабочий пример. У нас есть PubSubManager, подписчик и издатель.

Подписчик вызывает `pubsub.subscribe("messages")` и получает AsyncIterator. В цикле `async for` он ждет события и выводит их.

Издатель ждет секунду (имитация какой-то работы), затем публикует событие в канал "messages".

В `main()` мы запускаем подписчика и издателя параллельно через `asyncio.gather()`. Подписчик начинает ждать события, издатель через секунду отправляет событие, и подписчик его получает.

**Вывод:** "Получено событие: {'id': 1, 'text': 'Hello!'}"

Это простой пример, но он демонстрирует всю механику: подписка, публикация, передача через AsyncIterator. В GraphQL Subscriptions работает точно так же, только вместо `print()` данные отправляются клиенту через WebSocket.

Аналогия: Это как система оповещений в мессенджере. Когда кто-то отправляет сообщение в группу (Publisher), все участники группы (Subscribers) получают уведомление мгновенно.

---

## Слайд 20: asyncio.Queue - асинхронная очередь (4 минуты)

`asyncio.Queue` — это асинхронная очередь для передачи данных между корутинами. Это как почтовый ящик, но для корутин.

Посмотрите на пример. У нас есть `producer` (производитель), который кладет элементы в очередь через `await queue.put()`. И `consumer` (потребитель), который забирает элементы из очереди через `await queue.get()`.

Оба работают параллельно через `asyncio.gather()`. Producer кладет элементы, consumer забирает их. Это неблокирующие операции — пока producer ждет, consumer может работать, и наоборот.

**Использование:** В Pub/Sub для передачи событий! Каждый подписчик имеет свою очередь. Publisher кладет события в очереди всех подписчиков. Подписчики забирают события из своих очередей.

Аналогия: Представьте конвейер на заводе. Рабочий A (producer) кладет детали на конвейер (queue). Рабочий B (consumer) забирает детали с конвейера. Пока A кладет одну деталь, B может обрабатывать предыдущую. Все работает параллельно и эффективно.

**Важно:** `asyncio.Queue` потокобезопасна для использования в асинхронном коде. Не нужно использовать блокировки — все работает через Event Loop.

---

## Слайд 21: Обработка ошибок в async коде (4 минуты)

Обработка ошибок в асинхронном коде работает так же, как в синхронном, но есть нюансы.

В простом случае мы используем `try/except` как обычно. Если корутина выбрасывает исключение, мы можем его поймать.

Но в `asyncio.gather()` ситуация интереснее. По умолчанию, если одна из корутин упадет с ошибкой, `gather()` тоже упадет, и остальные корутины могут не завершиться.

Но можно использовать `return_exceptions=True`. Тогда исключения возвращаются как результаты, и мы можем обработать их отдельно. Остальные корутины продолжают работать.

Посмотрите на пример. Мы проверяем каждый результат: если это исключение, обрабатываем ошибку, если нет — используем результат.

Аналогия: Представьте команду строителей. Если один упал и сломал ногу, в обычном случае вся стройка останавливается. Но с `return_exceptions=True` остальные продолжают работать, а мы просто вызываем замену для пострадавшего.

**Практический совет:** В production всегда используйте `return_exceptions=True` в `gather()`, если не хотите, чтобы одна ошибка останавливала все остальные задачи.

---

## Слайд 22: Практический пример: WebSocket сервер (5 минут)

Вот полный практический пример, который объединяет все концепции: Pub/Sub, AsyncIterator, WebSocket.

У нас есть `websocket_handler`, который обрабатывает WebSocket соединения. Когда клиент подключается, мы подписываемся на канал "messages" через `pubsub.subscribe()`. Это возвращает AsyncIterator.

В цикле `async for event in pubsub.subscribe("messages")` мы получаем события из Pub/Sub и отправляем их клиенту через `await ws.send_json(event)`. Это происходит в реальном времени — как только событие появляется, клиент его получает.

Функция `create_message()` имитирует создание сообщения. Через 2 секунды она публикует событие в канал "messages". Это событие попадет ко всем подписчикам, включая WebSocket клиентов.

Мы запускаем `create_message()` в фоне через `asyncio.create_task()`, чтобы она работала параллельно с сервером.

**Как это работает:**
1. Клиент подключается через WebSocket.
2. Сервер подписывается на канал "messages".
3. Через 2 секунды создается сообщение и публикуется событие.
4. Событие попадает в очередь подписчика.
5. AsyncIterator получает событие и отправляет его клиенту через WebSocket.
6. Клиент получает событие в реальном времени!

Аналогия: Это как система уведомлений в мессенджере. Когда приходит новое сообщение, все подключенные клиенты получают его мгновенно через WebSocket.

---

## Слайд 23: Связь с GraphQL Subscriptions (5 минут)

Вот как все это связано с GraphQL Subscriptions. Это финальная картина.

**1. Pub/Sub менеджер (asyncio.Queue)** — это основа. Он управляет событиями и передает их между компонентами.

**2. GraphQL Subscription (AsyncIterator)** — это интерфейс для клиентов. Когда клиент подписывается, создается AsyncIterator, который получает события из Pub/Sub и отправляет их клиенту через `yield`.

**3. GraphQL Mutation (Publisher)** — это источник событий. Когда пользователь создает сообщение через мутацию, она публикует событие в Pub/Sub. Все подписчики получают это событие.

**4. WebSocket (aiohttp/FastAPI)** — это транспорт. GraphQL Subscriptions работают через WebSocket, обеспечивая постоянное соединение для передачи событий в реальном времени.

**Вся цепочка:**
1. Пользователь создает сообщение через GraphQL Mutation.
2. Mutation сохраняет сообщение в БД и публикует событие в Pub/Sub.
3. Pub/Sub отправляет событие всем подписчикам канала.
4. GraphQL Subscription получает событие через AsyncIterator.
5. Subscription отправляет событие клиенту через WebSocket.
6. Клиент получает обновление в реальном времени!

Аналогия: Это как система оповещений в социальной сети. Вы публикуете пост (Mutation) → система уведомляет всех подписчиков (Pub/Sub) → подписчики получают уведомление в реальном времени (Subscription через WebSocket).

---

## Слайд 24: Ключевые моменты (3 минуты)

Давайте закрепим ключевые моменты, которые вы должны запомнить.

**asyncio** — это основа асинхронного Python. Без него ничего не работает.

**async/await** — это синтаксис для корутин. `async def` определяет корутину, `await` приостанавливает выполнение.

**AsyncIterator** — для потоковой передачи данных. Это ключ к GraphQL Subscriptions.

**asyncio.gather** — параллельное выполнение. Запускает несколько задач одновременно.

**aiohttp** — асинхронный HTTP/WebSocket. Не блокирует Event Loop.

**asyncio.Queue** — передача данных между корутинами. Основа Pub/Sub.

**Pub/Sub** — паттерн для событий. Разделяет издателей и подписчиков.

**WebSocket** — real-time соединение. Транспорт для GraphQL Subscriptions.

**В GraphQL Subscriptions:**
- Subscription = AsyncIterator (поток данных)
- WebSocket = транспорт (постоянное соединение)
- Pub/Sub = механизм событий (распределение событий)

Запомните эту триаду: AsyncIterator + WebSocket + Pub/Sub = GraphQL Subscriptions.

---

## Слайд 25: Что дальше? (2 минуты)

Итак, что вас ждет в лабораторной работе?

**1. Создадим Pub/Sub менеджер с `asyncio.Queue`** — это основа всей системы. Вы реализуете простой, но рабочий менеджер событий.

**2. Реализуем GraphQL Subscriptions с `AsyncIterator`** — это интерфейс для клиентов. Каждая подписка будет возвращать AsyncIterator.

**3. Интегрируем WebSocket через FastAPI/Strawberry** — это транспорт. GraphQL Subscriptions будут работать через WebSocket.

**4. Добавим Redis для масштабирования** — это для production. Redis позволит масштабировать систему на несколько серверов.

**Помните ключевые концепции:**
- `async def` — корутина
- `await` — не блокирует Event Loop
- `async for` — асинхронная итерация
- `asyncio.gather()` — параллельное выполнение
- `yield` в AsyncIterator — отправка данных клиенту

Все эти концепции работают вместе, создавая мощную систему для real-time обновлений.

**Удачи в лабораторной работе!** Если что-то непонятно — задавайте вопросы. Асинхронность — это не магия, это просто другой способ думать о программировании.

---

## Вопросы и ответы (5 минут)

Теперь время для вопросов. Что непонятно? Какие концепции вызывают затруднения?

[Пауза для вопросов студентов]

---

## Итоги (1 минута)

Сегодня мы разобрали фундаментальные концепции асинхронного программирования в Python. Вы узнали:
- Что такое сокеты и зачем они нужны
- Как работают корутины и Event Loop
- Как использовать asyncio для параллельного выполнения
- Как AsyncIterator работает в GraphQL Subscriptions
- Как aiohttp обеспечивает асинхронный HTTP и WebSocket
- Как Pub/Sub паттерн связывает все вместе

На следующем занятии вы примените эти знания на практике в лабораторной работе. До встречи!

---

**Общее время:** ~60 минут

