# Сценарий презентации: GraphQL WebSocket Subscriptions
## Объяснение концепций для понимания STEP_5_GUIDE.md

---

## Слайд 1: Введение - Зачем нужны Subscriptions?

**Проблема без Subscriptions:**
Представьте мессенджер без real-time обновлений. Вы постоянно обновляете страницу, чтобы увидеть новые сообщения. Это как если бы вы каждые 5 секунд спрашивали друга: "Ты написал мне?" - надоедает и неэффективно!

**С Subscriptions:**
Сервер сам отправляет вам данные, когда они появляются. Это как уведомления в мессенджере - пришло сообщение, вы сразу видите. Никаких обновлений страницы, никаких опросов сервера.

**Ассоциация:** 
- Без Subscriptions = почта, которую нужно проверять вручную
- С Subscriptions = курьер, который приносит письма сразу, как они приходят

**Технически:**
- Query/Mutation = HTTP запросы (один запрос - один ответ)
- Subscription = WebSocket (постоянное соединение, сервер может отправлять данные когда угодно)

---

## Слайд 2: Что такое Pub/Sub паттерн?

**Pub/Sub (Publish/Subscribe)** - это паттерн, где есть два типа участников:

**Publisher (Издатель)** - тот, кто публикует события
- Создал сообщение → опубликовал событие "новое сообщение"
- Обновил пост → опубликовал событие "пост обновлен"

**Subscriber (Подписчик)** - тот, кто подписывается на события
- Подписался на "новые сообщения" → получает все новые сообщения
- Подписался на "комментарии к посту #1" → получает только комментарии к этому посту

**Ассоциация:**
Представьте YouTube канал:
- **Publisher** = создатель канала (публикует видео)
- **Subscriber** = подписчик канала (получает уведомления о новых видео)
- **Channel** = название канала (например, "messages", "comments:1")

**В коде:**
```python
# Publisher публикует событие
await pubsub.publish("messages", {"id": 1, "content": "Hello"})

# Subscriber подписывается и получает события
async for event in pubsub.subscribe("messages"):
    print(event)  # Получит {"id": 1, "content": "Hello"}
```

---

## Слайд 3: Как работает PubSubManager?

**PubSubManager** - это менеджер, который управляет подписками и публикациями.

**Структура:**
```python
self.subscribers = {
    "messages": [queue1, queue2, queue3],  # 3 подписчика на "messages"
    "comments:1": [queue4],                 # 1 подписчик на комментарии к посту #1
    "comments:2": [queue5, queue6]         # 2 подписчика на комментарии к посту #2
}
```

**Как это работает:**

1. **Подписка:**
   ```python
   async for event in pubsub.subscribe("messages"):
       # Создается очередь для этого подписчика
       # Очередь добавляется в список подписчиков канала "messages"
   ```

2. **Публикация:**
   ```python
   await pubsub.publish("messages", {"id": 1})
   # Менеджер берет все очереди из subscribers["messages"]
   # И отправляет событие в каждую очередь
   ```

**Ассоциация:**
Представьте почтовую рассылку:
- **Канал** = тема рассылки ("новости", "акции", "техподдержка")
- **Очередь** = почтовый ящик подписчика
- **Публикация** = отправка письма всем подписчикам этой темы

**Важно:** Каждый подписчик имеет свою очередь (queue). Это как у каждого подписчика свой почтовый ящик - письма не смешиваются.

---

## Слайд 4: AsyncIterator - что это такое?

**AsyncIterator** - это асинхронный итератор. Позволяет получать данные по одному элементу за раз, но асинхронно.

**Обычный итератор:**
```python
for item in [1, 2, 3]:
    print(item)  # Синхронно, блокирует выполнение
```

**Асинхронный итератор:**
```python
async for event in pubsub.subscribe("messages"):
    print(event)  # Асинхронно, не блокирует выполнение
```

**Почему AsyncIterator?**
- Подписки работают через WebSocket (асинхронно)
- События приходят не сразу, а когда происходят
- Нужно ждать события, но не блокировать другие запросы

**Ассоциация:**
- Обычный итератор = чтение книги (читаете страницу за страницей)
- AsyncIterator = ожидание писем в почтовом ящике (проверяете ящик, ждете, получаете письмо, обрабатываете, снова ждете)

**В GraphQL:**
```python
@strawberry.subscription
async def message_added(self) -> AsyncIterator[MessageType]:
    async for message_data in pubsub.subscribe("messages"):
        yield message_data  # Отправляем клиенту через WebSocket
```

`yield` - это как `return`, но для итератора. Вы возвращаете значение, но функция продолжает работать и может вернуть еще значения.

---

## Слайд 5: Каналы (Channels) - как они работают?

**Канал** - это название группы подписчиков. Как тема в мессенджере или категория на форуме.

**Примеры каналов:**
- `"messages"` - все новые сообщения
- `"comments:1"` - комментарии к сообщению с ID=1
- `"comments:2"` - комментарии к сообщению с ID=2
- `"message_updates:1"` - обновления сообщения с ID=1

**Как формируются каналы:**
```python
# Для комментариев к конкретному сообщению
channel = f"comments:{message_id}"  # "comments:1", "comments:2"

# Для обновлений конкретного сообщения
channel = f"message_updates:{message_id}"  # "message_updates:1"
```

**Ассоциация:**
Представьте телеграм-каналы:
- `"messages"` = общий канал "Новости"
- `"comments:1"` = канал "Обсуждение поста #1"
- `"comments:2"` = канал "Обсуждение поста #2"

Каждый канал независим. Подписчик на "comments:1" не получит события из "comments:2".

**В коде:**
```python
# Подписываемся на комментарии к посту #1
async for comment in pubsub.subscribe("comments:1"):
    print(comment)  # Получим только комментарии к посту #1

# Публикуем комментарий к посту #1
await pubsub.publish("comments:1", {"id": 1, "content": "Круто!"})
```

---

## Слайд 6: Очереди (Queues) - зачем они нужны?

**Очередь (Queue)** - это структура данных "первый пришел - первый ушел" (FIFO).

**Зачем нужны очереди в Pub/Sub?**
- Каждый подписчик имеет свою очередь
- Когда публикуется событие, оно добавляется во все очереди подписчиков
- Подписчик читает события из своей очереди по порядку

**Как это работает:**
```python
# Подписчик 1 создает очередь
queue1 = asyncio.Queue()
subscribers["messages"].append(queue1)

# Подписчик 2 создает очередь
queue2 = asyncio.Queue()
subscribers["messages"].append(queue2)

# Публикуем событие
await pubsub.publish("messages", {"id": 1})
# Событие добавляется в queue1 И в queue2

# Подписчик 1 читает из своей очереди
event = await queue1.get()  # Получит {"id": 1}

# Подписчик 2 читает из своей очереди
event = await queue2.get()  # Получит {"id": 1}
```

**Ассоциация:**
Представьте очередь в магазине:
- Каждый покупатель = подписчик
- Касса = очередь
- Товар = событие

Когда приходит товар, он попадает в очередь каждого покупателя. Каждый покупатель получает свой товар из своей очереди.

**Важно:** Очереди изолированы. Если подписчик 1 отключился, это не влияет на подписчика 2. Каждый работает со своей очередью.

---

## Слайд 7: WebSocket vs HTTP - в чем разница?

**HTTP (Query/Mutation):**
- Один запрос → один ответ
- Соединение закрывается после ответа
- Клиент инициирует запрос
- Это как телефонный звонок: позвонили, поговорили, положили трубку

**WebSocket (Subscription):**
- Постоянное соединение
- Сервер может отправлять данные когда угодно
- Соединение остается открытым
- Это как рация: включили, говорите когда нужно, выключили когда закончили

**Ассоциация:**
- HTTP = почта (отправили письмо, получили ответ, конец)
- WebSocket = мессенджер (открыли чат, общаетесь, получаете сообщения когда приходят)

**В GraphQL:**
```graphql
# HTTP запрос (Query)
query {
  messages {
    id
    content
  }
}
# Получили ответ, соединение закрыто

# WebSocket подписка (Subscription)
subscription {
  messageAdded {
    id
    content
  }
}
# Соединение открыто, ждем события, получаем когда приходят
```

**Когда использовать:**
- Query/Mutation = когда нужно получить данные один раз
- Subscription = когда нужно получать обновления в реальном времени

---

## Слайд 8: Как работает Subscription в GraphQL?

**Subscription** - это третий тип операций в GraphQL (после Query и Mutation).

**Структура:**
```python
@strawberry.subscription
async def message_added(self) -> AsyncIterator[MessageType]:
    async for message_data in pubsub.subscribe("messages"):
        yield MessageType(**message_data)
```

**Как это работает:**

1. **Клиент подписывается:**
   ```graphql
   subscription {
     messageAdded {
       id
       title
       content
     }
   }
   ```

2. **Сервер создает WebSocket соединение:**
   - Вызывается метод `message_added()`
   - Начинается подписка на канал "messages"
   - Соединение остается открытым

3. **Когда происходит событие:**
   - Мутация создает сообщение
   - Публикует событие в канал "messages"
   - Все подписчики получают событие
   - Клиент получает данные через WebSocket

**Ассоциация:**
Представьте радиостанцию:
- **Подписка** = включили радио, настроили на частоту
- **Событие** = диджей включил песню
- **Получение данных** = вы слышите песню в реальном времени

**Важно:** Subscription - это не запрос, это поток данных. Клиент получает данные по мере их появления, а не один раз.

---

## Слайд 9: Публикация событий в мутациях

**Где публиковать события?**
В тех местах, где происходят изменения данных:
- Создали сообщение → опубликовали в "messages"
- Создали комментарий → опубликовали в "comments:{message_id}"
- Обновили сообщение → опубликовали в "message_updates:{message_id}"

**Пример:**
```python
@strawberry.mutation
async def create_message(...) -> MessageType:
    # Создаем сообщение
    new_message = await create_message_resolver(...)
    
    # Публикуем событие для подписчиков
    await pubsub.publish("messages", {
        "id": new_message.id,
        "title": new_message.title,
        "content": new_message.content,
        # ... остальные поля
    })
    
    return new_message
```

**Ассоциация:**
Представьте новостной канал:
- **Мутация** = журналист написал новость
- **Публикация события** = новость вышла в эфир
- **Подписчики** = зрители, которые смотрят канал

**Важно:** Публикуйте события ПОСЛЕ успешного создания/обновления данных. Если создание не удалось, событие не должно публиковаться. Это как не объявлять новость, если она не подтверждена.

**Что публиковать?**
Публикуйте те же данные, которые возвращает мутация. Это как отправлять копию письма всем подписчикам - они получают те же данные, что и отправитель.

---

## Слайд 10: Структура данных в событиях

**Что публиковать в событиях?**
Те же данные, которые нужны подписчикам. Обычно это те же поля, что и в GraphQL типе.

**Пример:**
```python
# GraphQL тип
@strawberry.type
class MessageType:
    id: int
    title: str
    content: str
    author_id: int
    created_at: datetime

# Публикуем событие с теми же полями
await pubsub.publish("messages", {
    "id": new_message.id,
    "title": new_message.title,
    "content": new_message.content,
    "author_id": new_message.author_id,
    "created_at": new_message.created_at,
})
```

**Важно:** Поля в событии должны совпадать с полями GraphQL типа. Иначе при преобразовании `MessageType(**message_data)` будет ошибка.

**Ассоциация:**
Представьте форму заказа:
- **GraphQL тип** = шаблон формы (какие поля нужны)
- **Событие** = заполненная форма (те же поля, но с данными)

Если в шаблоне есть поле "email", а в форме его нет - ошибка! Нужно, чтобы всё совпадало.

**Преобразование:**
```python
# В Subscription
async for message_data in pubsub.subscribe("messages"):
    yield MessageType(**message_data)  # Преобразуем словарь в тип
```

`**message_data` - это распаковка словаря. Это как передача аргументов функции:
```python
# Вместо
MessageType(id=1, title="Hello", content="World")

# Можно
MessageType(**{"id": 1, "title": "Hello", "content": "World"})
```

---

## Слайд 11: Фильтрация событий по параметрам

**Иногда нужно подписаться не на все события, а на конкретные.**

**Пример:**
```python
@strawberry.subscription
async def comment_added(
    self, 
    message_id: int  # Параметр подписки
) -> AsyncIterator[CommentType]:
    # Формируем канал на основе параметра
    channel = f"comments:{message_id}"
    
    async for comment_data in pubsub.subscribe(channel):
        yield CommentType(**comment_data)
```

**Как это работает:**

1. **Клиент подписывается с параметром:**
   ```graphql
   subscription {
     commentAdded(messageId: 1) {
       id
       content
     }
   }
   ```

2. **Сервер формирует канал:**
   - `message_id = 1` → канал `"comments:1"`
   - Подписывается только на этот канал

3. **Публикация события:**
   ```python
   # Публикуем в канал для конкретного сообщения
   channel = f"comments:{new_comment.message_id}"
   await pubsub.publish(channel, {...})
   ```

**Ассоциация:**
Представьте подписку на YouTube:
- **Без параметра** = подписка на все каналы (получаете все видео)
- **С параметром** = подписка на конкретный канал (получаете только его видео)

**Преимущества:**
- Меньше трафика (получаете только нужные события)
- Меньше обработки (не нужно фильтровать на клиенте)
- Более эффективно (сервер отправляет только нужное)

---

## Слайд 12: Блокировки (Locks) - зачем они нужны?

**Проблема:** Несколько подписчиков могут подписываться/отписываться одновременно. Нужна синхронизация.

**Решение:** Использовать `asyncio.Lock()` для потокобезопасности.

```python
async def subscribe(self, channel: str):
    queue = asyncio.Queue()
    
    # Блокируем доступ к subscribers
    async with self._lock:
        self.subscribers[channel].append(queue)
    
    # Теперь другие подписчики ждут, пока мы закончим
```

**Ассоциация:**
Представьте очередь в банке:
- **Без блокировки** = все пытаются подойти к окошку одновременно (хаос!)
- **С блокировкой** = один подходит, остальные ждут (порядок!)

**Зачем это нужно?**
- Предотвращает race conditions (состояние гонки)
- Гарантирует, что список подписчиков не испортится
- Обеспечивает корректную работу при одновременных операциях

**В коде:**
```python
async with self._lock:
    # Только один поток может выполнять этот блок одновременно
    self.subscribers[channel].append(queue)
    # Остальные ждут, пока этот поток закончит
```

**Важно:** Блокировки нужны только при изменении структуры данных (добавление/удаление подписчиков). При чтении блокировка не нужна.

---

## Слайд 13: Обработка отключений подписчиков

**Проблема:** Подписчик может отключиться (закрыл браузер, потерял соединение). Нужно очистить его очередь.

**Решение:** Используем `try/finally` для автоматической очистки.

```python
async def subscribe(self, channel: str):
    queue = asyncio.Queue()
    
    async with self._lock:
        self.subscribers[channel].append(queue)
    
    try:
        while True:
            message = await queue.get()
            yield message
    finally:
        # Выполнится всегда, даже если произошла ошибка
        async with self._lock:
            if queue in self.subscribers[channel]:
                self.subscribers[channel].remove(queue)
```

**Ассоциация:**
Представьте подписку на журнал:
- **Подписка** = оформили подписку, добавили адрес в список
- **Получение** = получаете журналы по почте
- **Отписка** = отменили подписку, убрали адрес из списка

**finally блок** гарантирует, что адрес будет убран из списка, даже если что-то пошло не так.

**Также при публикации:**
```python
async def publish(self, channel: str, message: dict):
    disconnected = []
    for queue in self.subscribers[channel]:
        try:
            await queue.put(message)
        except Exception:
            # Очередь недоступна (подписчик отключился)
            disconnected.append(queue)
    
    # Удаляем отключенные очереди
    for queue in disconnected:
        self.subscribers[channel].remove(queue)
```

**Важно:** Нужно удалять отключенных подписчиков, иначе они будут накапливаться и занимать память. Это как уборка мусора - нужно регулярно чистить.

---

## Слайд 14: Тестирование подписок

**Как тестировать подписки?**

**1. Проверка схемы:**
- Откройте GraphQL Playground
- Проверьте, что Subscription виден в схеме
- Убедитесь, что поля доступны

**2. Тест подписки:**
- Откройте два окна браузера
- В первом окне создайте подписку
- Во втором окне выполните мутацию
- Проверьте, что событие пришло в первое окно

**3. Тест с параметрами:**
- Подпишитесь на комментарии к посту #1
- Создайте комментарий к посту #1 → должно прийти
- Создайте комментарий к посту #2 → не должно прийти

**Ассоциация:**
Представьте тестирование радио:
- **Проверка схемы** = проверили, что радио включается
- **Тест подписки** = включили радио, включили музыку на другом устройстве, проверили, что слышно
- **Тест с параметрами** = настроили на частоту 100.5, включили музыку на 101.0, проверили, что не слышно

**Инструменты:**
- GraphQL Playground (если поддерживает subscriptions)
- Apollo Studio Sandbox (лучше для subscriptions)
- Свой клиент на WebSocket

**Важно:** Тестируйте в реальных условиях. Подписки работают через WebSocket, поэтому нужен клиент, который поддерживает WebSocket.

---

## Слайд 15: In-Memory vs Redis для Pub/Sub

**In-Memory (текущая реализация):**
- Данные хранятся в памяти процесса
- Просто для разработки
- Не работает при нескольких серверах
- Данные теряются при перезапуске

**Redis:**
- Данные хранятся в Redis
- Работает при нескольких серверах
- Данные сохраняются
- Нужна настройка Redis

**Ассоциация:**
- In-Memory = записная книжка (записали, закрыли, потеряли)
- Redis = облачное хранилище (записали, доступно везде, сохраняется)

**Когда использовать:**
- In-Memory = для разработки, тестирования, простых проектов
- Redis = для продакшена, нескольких серверов, масштабирования

**В STEP_5_GUIDE используется In-Memory**, потому что это проще для обучения. В продакшене лучше использовать Redis.

**Миграция на Redis:**
```python
# Вместо
self.subscribers = defaultdict(list)

# Использовать
import redis
redis_client = redis.Redis()
redis_client.publish("messages", json.dumps(message_data))
```

Но это уже для продвинутых проектов. Для начала In-Memory достаточно.

---

## Слайд 16: Поток данных в Subscriptions

**Полный поток данных:**

1. **Клиент подписывается:**
   ```graphql
   subscription {
     messageAdded {
       id
       title
     }
   }
   ```
   → Открывается WebSocket соединение

2. **Сервер обрабатывает подписку:**
   ```python
   @strawberry.subscription
   async def message_added(self):
       async for event in pubsub.subscribe("messages"):
           yield event
   ```
   → Создается очередь, добавляется в subscribers["messages"]

3. **Клиент создает сообщение:**
   ```graphql
   mutation {
     createMessage(...) {
       id
     }
   }
   ```
   → Выполняется мутация

4. **Мутация публикует событие:**
   ```python
   await pubsub.publish("messages", {...})
   ```
   → Событие добавляется во все очереди подписчиков

5. **Подписчики получают событие:**
   ```python
   async for event in pubsub.subscribe("messages"):
       yield event  # Отправляется клиенту через WebSocket
   ```
   → Клиент получает данные в реальном времени

**Ассоциация:**
Представьте цепочку доставки:
- **Подписка** = оформили доставку, дали адрес
- **Мутация** = отправили посылку
- **Публикация** = посылка попала в систему доставки
- **Получение** = курьер доставил посылку по адресу

**Важно:** Всё происходит асинхронно. Несколько подписчиков могут получать события одновременно, мутации могут выполняться параллельно.

---

## Слайд 17: Ошибки и их обработка

**Что может пойти не так?**

**1. Подписчик отключился:**
```python
try:
    await queue.put(message)
except Exception:
    # Подписчик отключился, удаляем его очередь
    disconnected.append(queue)
```
→ Обрабатывается автоматически, очередь удаляется

**2. Ошибка в Subscription:**
```python
async def message_added(self):
    try:
        async for event in pubsub.subscribe("messages"):
            yield event
    except Exception as e:
        # Ошибка обрабатывается, подписка закрывается
        # finally блок удалит очередь
```
→ Ошибка логируется, подписка закрывается, очередь очищается

**3. Ошибка при публикации:**
```python
await pubsub.publish("messages", {...})
# Если публикация не удалась, событие теряется
# Но это не критично - следующее событие придет
```
→ Событие теряется, но это не критично

**Ассоциация:**
Представьте почтовую службу:
- **Подписчик отключился** = адресат переехал, письмо вернулось
- **Ошибка в Subscription** = почтальон заболел, доставка приостановлена
- **Ошибка при публикации** = письмо потерялось, но следующее дойдет

**Важно:** Обрабатывайте ошибки gracefully. Не падайте при ошибке одного подписчика - остальные должны продолжать работать.

---

## Слайд 18: Производительность и масштабирование

**In-Memory Pub/Sub ограничения:**

**Проблемы:**
- Не работает при нескольких серверах (каждый сервер имеет свой список подписчиков)
- Данные теряются при перезапуске
- Память ограничена размером процесса

**Когда достаточно:**
- Один сервер
- Небольшое количество подписчиков
- Разработка и тестирование

**Когда нужен Redis:**
- Несколько серверов (load balancing)
- Большое количество подписчиков
- Нужна надежность (данные не теряются)

**Ассоциация:**
- In-Memory = один офис с одним телефоном (все звонки идут на один номер)
- Redis = call-центр с несколькими операторами (звонки распределяются между операторами)

**Масштабирование:**
```python
# In-Memory (текущая реализация)
pubsub = PubSubManager()  # Один экземпляр на сервер

# Redis (для продакшена)
import redis
redis_client = redis.Redis()
# Все серверы используют один Redis
# Подписчики на разных серверах получают события
```

**Важно:** Для обучения In-Memory достаточно. Для продакшена нужен Redis или другой брокер сообщений.

---

## Слайд 19: Практический пример - полный цикл

**Сценарий:** Пользователь подписывается на новые сообщения, другой пользователь создает сообщение.

**Шаг 1: Подписка**
```graphql
# Клиент 1 подписывается
subscription {
  messageAdded {
    id
    title
    content
  }
}
```
→ WebSocket соединение открыто, очередь создана

**Шаг 2: Создание сообщения**
```graphql
# Клиент 2 создает сообщение
mutation {
  createMessage(
    authorId: 1
    title: "Новое сообщение"
    content: "Привет всем!"
  ) {
    id
  }
}
```
→ Мутация выполняется, сообщение создается в БД

**Шаг 3: Публикация события**
```python
# В мутации create_message
await pubsub.publish("messages", {
    "id": 1,
    "title": "Новое сообщение",
    "content": "Привет всем!",
    "author_id": 1,
    "created_at": "2025-01-15T10:00:00"
})
```
→ Событие добавлено в очередь Клиента 1

**Шаг 4: Получение события**
```python
# В Subscription message_added
async for message_data in pubsub.subscribe("messages"):
    yield MessageType(**message_data)  # Отправляется Клиенту 1
```
→ Клиент 1 получает данные через WebSocket в реальном времени!

**Ассоциация:**
Представьте чат:
- **Подписка** = вы открыли чат, ждете сообщений
- **Создание** = кто-то написал сообщение
- **Публикация** = сообщение попало в систему
- **Получение** = вы видите сообщение сразу, без обновления страницы

**Время:** Всё происходит мгновенно. Нет задержек, нет опросов сервера, всё в реальном времени!

---

## Слайд 20: Ключевые концепции - резюме

**Что нужно запомнить:**

1. **Pub/Sub паттерн:**
   - Publisher публикует события в каналы
   - Subscriber подписывается на каналы и получает события
   - Канал = группа подписчиков

2. **PubSubManager:**
   - Управляет подписками и публикациями
   - Использует очереди для каждого подписчика
   - Использует блокировки для потокобезопасности

3. **Subscription в GraphQL:**
   - Третий тип операций (после Query и Mutation)
   - Работает через WebSocket
   - Возвращает AsyncIterator (поток данных)

4. **Публикация событий:**
   - Публикуйте в мутациях после успешного изменения данных
   - Используйте каналы для фильтрации событий
   - Публикуйте те же данные, что возвращает мутация

5. **Тестирование:**
   - Проверяйте схему
   - Тестируйте подписки в двух окнах
   - Проверяйте фильтрацию по параметрам

**Ассоциация:**
Представьте систему уведомлений:
- **Pub/Sub** = почтовая служба (отправка и получение писем)
- **PubSubManager** = почтовое отделение (управляет доставкой)
- **Subscription** = подписка на журнал (получаете новые выпуски)
- **Публикация** = отправка журнала (издатель отправляет выпуск)
- **Тестирование** = проверка доставки (получили ли вы журнал?)

**Главное:** Subscriptions - это способ получать данные в реальном времени без постоянных запросов к серверу. Это эффективнее и удобнее для пользователей!

---

## Слайд 21: Типичные ошибки и как их избежать

**Ошибка 1: Забыли опубликовать событие**
```python
# Плохо
async def create_message(...):
    new_message = await create_message_resolver(...)
    return new_message  # Событие не опубликовано!

# Хорошо
async def create_message(...):
    new_message = await create_message_resolver(...)
    await pubsub.publish("messages", {...})  # Событие опубликовано
    return new_message
```
→ Подписчики не получат событие, если не опубликовать его

**Ошибка 2: Неправильный канал**
```python
# Плохо
await pubsub.publish("messages", {...})  # Публикуем в "messages"
# Но подписчик слушает "comments:1"

# Хорошо
channel = f"comments:{message_id}"
await pubsub.publish(channel, {...})  # Публикуем в правильный канал
```
→ Событие не дойдет до подписчика, если канал не совпадает

**Ошибка 3: Неправильная структура данных**
```python
# Плохо
await pubsub.publish("messages", {"id": 1})  # Нет поля "title"

# В Subscription
yield MessageType(**message_data)  # Ошибка! Нет поля "title"

# Хорошо
await pubsub.publish("messages", {
    "id": 1,
    "title": "Hello",
    "content": "World",
    # Все поля, которые есть в MessageType
})
```
→ Ошибка при преобразовании, если структура не совпадает

**Ошибка 4: Забыли добавить Subscription в схему**
```python
# Плохо
schema = strawberry.Schema(query=Query, mutation=Mutation)
# Subscription не добавлен!

# Хорошо
schema = strawberry.Schema(
    query=Query,
    mutation=Mutation,
    subscription=Subscription  # Subscription добавлен
)
```
→ Подписки не будут работать, если не добавить в схему

**Ассоциация:**
Представьте доставку пиццы:
- **Забыли опубликовать** = заказали пиццу, но не отправили курьера
- **Неправильный канал** = отправили курьера по неправильному адресу
- **Неправильная структура** = привезли не ту пиццу (без сыра, хотя заказали с сыром)
- **Забыли добавить в схему** = пиццерия не знает о вашем заказе

**Важно:** Всегда проверяйте, что события публикуются, каналы совпадают, структура данных правильная, и Subscription добавлен в схему.

---

## Слайд 22: Отладка подписок

**Как отлаживать подписки?**

**1. Логирование:**
```python
async def subscribe(self, channel: str):
    print(f"Подписка на канал: {channel}")
    queue = asyncio.Queue()
    async with self._lock:
        self.subscribers[channel].append(queue)
        print(f"Подписчиков на {channel}: {len(self.subscribers[channel])}")
    
    try:
        while True:
            message = await queue.get()
            print(f"Получено событие в {channel}: {message}")
            yield message
```

**2. Проверка подписчиков:**
```python
# Добавьте метод для отладки
def get_subscribers_count(self, channel: str) -> int:
    return len(self.subscribers.get(channel, []))
```

**3. Проверка публикации:**
```python
async def publish(self, channel: str, message: dict):
    print(f"Публикация в канал {channel}: {message}")
    async with self._lock:
        count = len(self.subscribers.get(channel, []))
        print(f"Подписчиков на {channel}: {count}")
        # ... остальной код
```

**Ассоциация:**
Представьте отладку радио:
- **Логирование** = видите, на какую частоту настроились
- **Проверка подписчиков** = видите, сколько слушателей
- **Проверка публикации** = видите, что отправляется в эфир

**Инструменты:**
- Print statements (простой способ)
- Логирование (лучше для продакшена)
- GraphQL Playground (визуальная отладка)
- WebSocket inspector (для проверки соединений)

**Важно:** Отладка подписок сложнее, чем отладка обычных запросов, потому что они асинхронные и работают через WebSocket. Используйте логирование и визуальные инструменты.

---

## Слайд 23: Сравнение с альтернативами

**GraphQL Subscriptions vs другие подходы:**

**1. Polling (постоянные запросы):**
```javascript
// Каждые 5 секунд спрашиваем сервер
setInterval(() => {
    fetch('/api/messages?since=' + lastId)
}, 5000);
```
- ❌ Лишняя нагрузка на сервер
- ❌ Задержка в получении данных
- ✅ Просто реализовать

**2. Server-Sent Events (SSE):**
```javascript
const eventSource = new EventSource('/api/messages/stream');
eventSource.onmessage = (event) => {
    console.log(event.data);
};
```
- ✅ Проще, чем WebSocket
- ✅ Автоматическое переподключение
- ❌ Только сервер → клиент (нельзя отправлять данные)

**3. WebSocket (GraphQL Subscriptions):**
```graphql
subscription {
  messageAdded {
    id
    content
  }
}
```
- ✅ Двусторонняя связь
- ✅ Эффективно
- ✅ Стандарт GraphQL
- ❌ Сложнее в настройке

**Ассоциация:**
- **Polling** = постоянно звоните другу: "Ты написал мне?" (надоедает)
- **SSE** = радио (только слушаете, не можете говорить)
- **WebSocket** = телефон (можете и говорить, и слушать)

**Когда использовать:**
- Polling = простые случаи, не критична задержка
- SSE = только уведомления от сервера
- WebSocket = нужна двусторонняя связь, real-time обновления

---

## Слайд 24: Безопасность подписок

**Проблемы безопасности:**

**1. Авторизация:**
```python
@strawberry.subscription
async def message_added(self, info) -> AsyncIterator[MessageType]:
    # Проверяем авторизацию
    user = info.context.get("user")
    if not user:
        raise Exception("Authentication required")
    
    async for event in pubsub.subscribe("messages"):
        yield MessageType(**event)
```
→ Не позволяйте неавторизованным пользователям подписываться

**2. Фильтрация данных:**
```python
# Публикуйте только публичные данные
await pubsub.publish("messages", {
    "id": message.id,
    "title": message.title,
    # НЕ публикуйте приватные данные!
    # "private_field": message.private_field  # Плохо!
})
```
→ Не публикуйте чувствительные данные

**3. Rate limiting:**
```python
# Ограничьте количество подписок на пользователя
if user.subscription_count > 10:
    raise Exception("Too many subscriptions")
```
→ Предотвратите злоупотребления

**Ассоциация:**
Представьте закрытый клуб:
- **Авторизация** = проверка членства (только члены могут входить)
- **Фильтрация данных** = не показываете секретные документы всем
- **Rate limiting** = ограничение посещений (нельзя приходить 100 раз в день)

**Важно:** Подписки работают через WebSocket, который держит соединение открытым. Нужно проверять авторизацию и ограничивать ресурсы.

---

## Слайд 25: Заключение - ключевые моменты

**Что мы узнали:**

1. **Subscriptions** - это способ получать данные в реальном времени через WebSocket
2. **Pub/Sub паттерн** - это способ передачи событий от издателей к подписчикам
3. **PubSubManager** - это менеджер, который управляет подписками и публикациями
4. **Каналы** - это группы подписчиков (например, "messages", "comments:1")
5. **Очереди** - это структуры данных для каждого подписчика
6. **Публикация событий** - это отправка событий в мутациях после изменения данных

**Как это работает:**
1. Клиент подписывается → создается WebSocket соединение
2. Сервер создает очередь → добавляет в список подписчиков канала
3. Мутация изменяет данные → публикует событие в канал
4. Событие попадает во все очереди подписчиков
5. Подписчики получают событие → отправляется клиенту через WebSocket

**Ассоциация:**
Представьте систему уведомлений в мессенджере:
- **Подписка** = включили уведомления
- **Мутация** = кто-то написал сообщение
- **Публикация** = система отправила уведомление
- **Получение** = вы видите уведомление на телефоне

**Главное:** Subscriptions делают приложения интерактивными и отзывчивыми. Пользователи получают обновления мгновенно, без обновления страницы!

**Следующие шаги:**
1. Изучите STEP_5_GUIDE.md - там пошаговая инструкция
2. Попробуйте реализовать подписки в своем проекте
3. Протестируйте подписки в GraphQL Playground
4. Изучите Redis для масштабирования

**Вопросы?** Давайте обсудим!

---

**Итого: 25 слайдов, примерно 60-70 минут презентации**
