## 2. Практическое занятие: Метрики производительности и измерение производительности

### Теоретическая часть

### 2.1 Основные метрики

#### RPS (Requests Per Second)

**Определение:** Количество запросов, обрабатываемых системой за секунду

**Примеры:**

- Простой сайт: 10-100 RPS
- Средний веб-сервис: 1,000-10,000 RPS
- Высоконагруженная система: 100,000+ RPS

**Формула:** RPS = Общее количество запросов / Время в секундах

#### Latency (Задержка)

**Определение:** Время от отправки запроса до получения ответа

**Типы задержек:**

- **Network Latency:** время передачи по сети
- **Processing Latency:** время обработки на сервере
- **Database Latency:** время выполнения запроса к БД

**Приемлемые значения:**

- Веб-страницы: < 200ms
- API: < 100ms
- Реального времени: < 10ms

#### Throughput (Пропускная способность)

**Определение:** Объем данных, передаваемых за единицу времени

**Измерения:**

- MB/s, GB/s для данных
- Transactions/s для транзакций
- Messages/s для очередей

### 2.2 Дополнительные метрики

#### Percentiles (Процентили)

- **P50 (медиана):** 50% запросов быстрее этого времени
- **P95:** 95% запросов быстрее
- **P99:** 99% запросов быстрее
- **P99.9:** 99.9% запросов быстрее

**Пример:** P95 = 200ms означает, что 95% запросов выполняются быстрее 200ms

#### Availability (Доступность)

**Формула:** Availability = (Uptime / Total Time) × 100%

**SLA уровни:**

- 99% = 3.65 дней простоя в год
- 99.9% = 8.76 часов простоя в год
- 99.99% = 52.56 минут простоя в год
- 99.999% = 5.26 минут простоя в год

### 2.3 CAP-теорема

**Определение:** В распределенной системе невозможно одновременно гарантировать все три свойства:

#### C - Consistency (Согласованность)

Все узлы видят одинаковые данные одновременно

**Пример:** После записи в базу данных все реплики должны показывать новое значение

#### A - Availability (Доступность)

Система остается доступной для операций

**Пример:** Система отвечает на запросы даже при отказе части узлов

#### P - Partition Tolerance (Устойчивость к разделению)

Система продолжает работать при потере связи между узлами

**Пример:** Система работает даже если связь между дата-центрами прервана

#### Практические компромиссы:

- **CP системы:** MongoDB, Redis Cluster (жертвуют доступностью)
- **AP системы:** Cassandra, DynamoDB (жертвуют согласованностью)
- **CA системы:** PostgreSQL, MySQL (не устойчивы к разделению)

### 2.4 ACID свойства

#### A - Atomicity (Атомарность)

Транзакция выполняется полностью или не выполняется вообще

**Пример:** Перевод денег - либо списание И зачисление, либо ничего

#### C - Consistency (Согласованность)

База данных переходит из одного согласованного состояния в другое

**Пример:** Сумма на всех счетах остается неизменной после перевода

#### I - Isolation (Изолированность)

Параллельные транзакции не влияют друг на друга

**Уровни изоляции:**

- Read Uncommitted
- Read Committed
- Repeatable Read
- Serializable

#### D - Durability (Долговечность)

Зафиксированные изменения сохраняются навсегда

**Пример:** После подтверждения транзакции данные не теряются даже при сбое

### Практическая часть

## Измерение производительности 

### Задание 1: Нагрузочное тестирование с Apache Bench (45 мин)

#### Установка инструментов:

```bash
# Ubuntu/Debian
sudo apt-get install apache2-utils

# Windows (через WSL или скачать)
# MacOS
brew install httpie
```

#### Тестирование простого веб-сервера:

```bash
# Запуск 1000 запросов с 10 одновременными соединениями
ab -n 1000 -c 10 http://httpbin.org/get

# Анализ результатов:
# - Requests per second
# - Time per request  
# - Transfer rate
# - Percentiles
```

```
(venv) student:~/Desktop/practice-1$ ab -n 1000 -c 10 http://httpbin.org/get
This is ApacheBench, Version 2.3 <$Revision: 1903618 $>
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking httpbin.org (be patient)
Completed 100 requests
Completed 200 requests
Completed 300 requests
Completed 400 requests
Completed 500 requests
Completed 600 requests
Completed 700 requests
Completed 800 requests
Completed 900 requests
Completed 1000 requests
Finished 1000 requests


Server Software:        awselb/2.0
Server Hostname:        httpbin.org
Server Port:            80

Document Path:          /get
Document Length:        162 bytes

Concurrency Level:      10
Time taken for tests:   30.971 seconds
Complete requests:      1000
Failed requests:        0
Non-2xx responses:      1000
Total transferred:      332000 bytes
HTML transferred:       162000 bytes
Requests per second:    32.29 [#/sec] (mean)
Time per request:       309.708 [ms] (mean)
Time per request:       30.971 [ms] (mean, across all concurrent requests)
Transfer rate:          10.47 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:      144  152   7.6    151     211
Processing:   144  152   7.9    151     222
Waiting:      107  150   7.4    149     217
Total:        290  305  12.1    302     394

Percentage of the requests served within a certain time (ms)
  50%    302
  66%    306
  75%    309
  80%    310
  90%    317
  95%    329
  98%    342
  99%    351
 100%    394 (longest request)

```

Подробный размотр результатов **ApacheBench (ab)**:

## **Общая информация о тесте**

- **Утилита**: ApacheBench 2.3
- **URL**: http://httpbin.org/get
- **Количество запросов**: 1000
- **Уровень параллелизма**: 10 одновременных соединений

## **Параметры сервера**

```
Server Software: awselb/2.0    ← AWS Elastic Load Balancer
Server Hostname: httpbin.org
Server Port: 80                ← HTTP порт
Document Path: /get            ← Тестируемый endpoint
Document Length: 162 bytes     ← Размер ответа
```

## **Ключевые метрики производительности**

### **1. Общее время выполнения**

```
Time taken for tests: 30.971 seconds
```

Весь тест из 1000 запросов занял ~31 секунду

### **2. Пропускная способность**

```
Requests per second: 32.29 [#/sec] (mean)
```

**32.29 запросов в секунду** - это основная метрика производительности сервера

### **3. Время обработки запросов**

```
Time per request: 309.708 [ms] (mean)        ← Время на один запрос при параллелизме
Time per request: 30.971 [ms] (mean, across) ← Среднее время на запрос
```

### **4. Статистика соединений**

```
Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:      144  152   7.6    151     211
Processing:   144  152   7.9    151     222
Waiting:      107  150   7.4    149     217
Total:        290  305  12.1    302     394
```

**Расшифровка:**

- **Connect**: Время установки TCP-соединения (144-211 мс)
- **Processing**: Время обработки запроса сервером (144-222 мс)
- **Waiting**: Время от отправки запроса до получения первого байта (107-217 мс)
- **Total**: Общее время запроса (290-394 мс)

## **Перцентили времени ответа**

```
50%    302    ← Медиана - половина запросов быстрее 302 мс
66%    306
75%    309
80%    310
90%    317    ← 90% запросов выполнены за 317 мс или быстрее
95%    329
98%    342
99%    351
100%   394    ← Самый медленный запрос
```

## **Анализ качества**

```
Failed requests: 0          ← Ошибок нет
Non-2xx responses: 1000     ← Все ответы не 2xx статус (возможно 3xx редиректы)
Total transferred: 332000 bytes
HTML transferred: 162000 bytes
Transfer rate: 10.47 [Kbytes/sec]
```

## **Выводы о производительности**

1. **Стабильность**: Низкое стандартное отклонение (7-12 мс) - стабильная работа
2. **Производительность**: 32 запроса/секунду - умеренная нагрузка
3. **Задержки**: Среднее время ответа ~305 мс - типично для географически удаленного сервера
4. **Надежность**: 0 неудачных запросов - сервер стабилен
5. **Масштабируемость**: 90% запросов в пределах 317 мс - хорошая предсказуемость

## **Рекомендации для улучшения**

- Оптимизировать можно за счет кеширования
- Рассмотреть CDN для уменьшения задержек
- Увеличить параллелизм для проверки пределов сервера

Это хороший результат для публичного сервиса с географической удаленностью.

#### Задача для студентов:

1. Протестировать 3 разных сайта
2. Сравнить их производительность
3. Построить график зависимости RPS от количества одновременных соединений

### Задание 2: Мониторинг системных ресурсов (30 мин)

#### Использование htop/top:

```bash
# Мониторинг CPU, памяти, процессов
htop

# Мониторинг сетевой активности  
iftop

# Мониторинг дискового I/O
iotop
```

#### Задача:

Запустить нагрузочный тест и одновременно мониторить:

- Загрузку CPU
- Использование памяти
- Сетевой трафик
- Дисковые операции

### Задание 3: Анализ логов веб-сервера (25 мин)

#### Пример лога Apache:

```
127.0.0.1 - - [25/Dec/2023:10:00:01 +0000] "GET /api/users HTTP/1.1" 200 1234 0.150
127.0.0.1 - - [25/Dec/2023:10:00:02 +0000] "POST /api/orders HTTP/1.1" 201 567 0.300
```

#### Задача:

Написать скрипт для анализа:

- Среднее время ответа
- Количество запросов по статус-кодам
- Топ самых медленных запросов

---

## Практическое занятие 2: CAP-теорема на практике (2 ч)

### Задание 1: Эксперимент с Redis Cluster (45 мин)

#### Настройка кластера:

```bash
# Запуск 3 узлов Redis
redis-server --port 7000 --cluster-enabled yes
redis-server --port 7001 --cluster-enabled yes  
redis-server --port 7002 --cluster-enabled yes

# Создание кластера
redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002
```

#### Тестирование CAP свойств:

```python
import redis
import time

# Подключение к кластеру
r = redis.Redis(host='127.0.0.1', port=7000)

# Тест согласованности
r.set('key1', 'value1')
print(r.get('key1'))  # Проверка на всех узлах

# Тест доступности при отказе узла
# Остановить один узел и проверить доступность
```

### Задание 2: ACID vs BASE сравнение (30 мин)

#### ACID транзакция (PostgreSQL):

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

#### BASE операция (MongoDB):

```javascript
// Eventual consistency пример
db.accounts.updateOne({id: 1}, {$inc: {balance: -100}});
db.accounts.updateOne({id: 2}, {$inc: {balance: 100}});
// Согласованность достигается со временем
```

### Задание 3: Измерение latency в микросервисах (25 мин)

#### Простой HTTP сервер с задержками:

```python
from flask import Flask
import time
import random

app = Flask(__name__)

@app.route('/fast')
def fast_endpoint():
    return {'response': 'fast', 'latency': '10ms'}

@app.route('/slow')  
def slow_endpoint():
    time.sleep(random.uniform(0.1, 0.5))  # 100-500ms задержка
    return {'response': 'slow', 'latency': '100-500ms'}

if __name__ == '__main__':
    app.run(port=5000)
```

#### Измерение latency:

```bash
# Тестирование быстрого endpoint
ab -n 100 -c 5 http://localhost:5000/fast

# Тестирование медленного endpoint  
ab -n 100 -c 5 http://localhost:5000/slow

# Сравнение percentiles
```

---

## Домашнее задание:

### Задача: Анализ производительности реального сервиса

1. **Выберите публичный API** (например, JSONPlaceholder, GitHub API, OpenWeatherMap)
2. **Проведите нагрузочное тестирование:**

   - Измерьте RPS при разной нагрузке (1, 5, 10, 20 одновременных соединений)
   - Постройте график зависимости latency от нагрузки
   - Определите точку деградации производительности
3. **Проанализируйте результаты:**

   - При какой нагрузке система начинает деградировать?
   - Какие percentiles (P95, P99) показывают проблемы?
   - Есть ли признаки rate limiting?
4. **Предложите улучшения:**

   - Какие узкие места вы видите?
   - Как можно улучшить производительность?
   - Какие компромиссы CAP-теоремы делает система?

**Формат отчета:** 3-4 страницы с графиками и выводами
**Срок сдачи:** К следующему занятию

---

## Критерии оценки:

- **Отлично (5):** Понимание всех концепций, правильные измерения, обоснованные выводы
- **Хорошо (4):** Хорошее понимание основных концепций, небольшие неточности в измерениях
- **Удовлетворительно (3):** Базовое понимание, ошибки в интерпретации результатов
- **Неудовлетворительно (2):** Непонимание основных концепций, неверные измерения

## Литература:

- Клеппман М. "Высоконагруженные приложения"
- Фаулер М. "Архитектура корпоративных программных приложений"
- Документация Apache Bench, Redis, PostgreSQL
