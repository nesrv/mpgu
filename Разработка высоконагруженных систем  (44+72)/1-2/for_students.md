## 2. Практическое занятие: Метрики производительности и измерение производительности
студент {фио} группа {группа} {дата}

### Теоретическая часть

### 2.1 Основные метрики

#### RPS (Requests Per Second)

**Определение:** Количество запросов, обрабатываемых системой за секунду

**Примеры:**

- Простой сайт: 10-100 RPS
- Средний веб-сервис: 1,000-10,000 RPS
- Высоконагруженная система: 100,000+ RPS

**Формула:** RPS = Общее количество запросов / Время в секундах

#### Latency (Задержка)

**Определение:** Время от отправки запроса до получения ответа

**Типы задержек:**

- **Network Latency:** время передачи по сети
- **Processing Latency:** время обработки на сервере
- **Database Latency:** время выполнения запроса к БД

**Приемлемые значения:**

- Веб-страницы: < 200ms
- API: < 100ms
- Реального времени: < 10ms

#### Throughput (Пропускная способность)

**Определение:** Объем данных, передаваемых за единицу времени

**Измерения:**

- MB/s, GB/s для данных
- Transactions/s для транзакций
- Messages/s для очередей

### 2.2 Дополнительные метрики

#### Percentiles (Процентили)

- **P50 (медиана):** 50% запросов быстрее этого времени
- **P95:** 95% запросов быстрее
- **P99:** 99% запросов быстрее
- **P99.9:** 99.9% запросов быстрее

**Пример:** P95 = 200ms означает, что 95% запросов выполняются быстрее 200ms

#### Availability (Доступность)

**Формула:** Availability = (Uptime / Total Time) × 100%

**SLA уровни:**

- 99% = 3.65 дней простоя в год
- 99.9% = 8.76 часов простоя в год
- 99.99% = 52.56 минут простоя в год
- 99.999% = 5.26 минут простоя в год

### 2.3 CAP-теорема

**Определение:** В распределенной системе невозможно одновременно гарантировать все три свойства:

#### C - Consistency (Согласованность)

Все узлы видят одинаковые данные одновременно

**Пример:** После записи в базу данных все реплики должны показывать новое значение

#### A - Availability (Доступность)

Система остается доступной для операций

**Пример:** Система отвечает на запросы даже при отказе части узлов

#### P - Partition Tolerance (Устойчивость к разделению)

Система продолжает работать при потере связи между узлами

**Пример:** Система работает даже если связь между дата-центрами прервана

#### Практические компромиссы:

- **CP системы:** MongoDB, Redis Cluster (жертвуют доступностью)
- **AP системы:** Cassandra, DynamoDB (жертвуют согласованностью)
- **CA системы:** PostgreSQL, MySQL (не устойчивы к разделению)

### 2.4 ACID свойства

#### A - Atomicity (Атомарность)

Транзакция выполняется полностью или не выполняется вообще

**Пример:** Перевод денег - либо списание И зачисление, либо ничего

#### C - Consistency (Согласованность)

База данных переходит из одного согласованного состояния в другое

**Пример:** Сумма на всех счетах остается неизменной после перевода

#### I - Isolation (Изолированность)

Параллельные транзакции не влияют друг на друга

**Уровни изоляции:**

- Read Uncommitted
- Read Committed
- Repeatable Read
- Serializable

#### D - Durability (Долговечность)

Зафиксированные изменения сохраняются навсегда

**Пример:** После подтверждения транзакции данные не теряются даже при сбое

### Практическая часть

## Измерение производительности 

### Задание 1: Нагрузочное тестирование с Apache Bench (45 мин)

#### Установка инструментов:

```bash
# Ubuntu/Debian
sudo apt-get install apache2-utils

# Windows (через WSL или скачать)
# MacOS
brew install httpie
```

#### Тестирование простого веб-сервера:

```bash
# Запуск 1000 запросов с 10 одновременными соединениями
ab -n 1000 -c 10 http://httpbin.org/get

# Анализ результатов:
# - Requests per second
# - Time per request  
# - Transfer rate
# - Percentiles
```

Опишите полученный результат
``


Подробный размотр результатов **ApacheBench (ab)**:

## **Общая информация о тесте**

- **Утилита**: ApacheBench 2.3
- **URL**: http://httpbin.org/get
- **Количество запросов**: 1000
- **Уровень параллелизма**: 10 одновременных соединений

## **Параметры сервера**

```
Server Software: awselb/2.0    ← AWS Elastic Load Balancer
Server Hostname: httpbin.org
Server Port: 80                ← HTTP порт
Document Path: /get            ← Тестируемый endpoint
Document Length: 162 bytes     ← Размер ответа
```

## **Ключевые метрики производительности**

### **1. Общее время выполнения**

```
Time taken for tests: {textbox}
```

Весь тест из 1000 запросов занял {textbox}

### **2. Пропускная способность**

```
Requests per second: 32.29 [#/sec] (mean)
```

**{textbox} запросов в секунду** - это основная метрика производительности сервера

### **3. Время обработки запросов**

```
Time per request: {textbox} [ms] (mean)        ← Время на один запрос при параллелизме
Time per request: {textbox} [ms] (mean, across) ← Среднее время на запрос
```

### **4. Статистика соединений**

```
Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:      {textbox}  {textbox}  {textbox}   {textbox}     {textbox}
Processing:   {textbox}  {textbox}  {textbox}   {textbox}     {textbox}
Waiting:      {textbox}  {textbox}  {textbox}   {textbox}     {textbox}
Total:        {textbox}  {textbox}  {textbox}   {textbox}     {textbox}
```

**Расшифровка:**

- **Connect**: Время установки TCP-соединения {textbox}
- **Processing**: Время обработки запроса сервером {textbox}
- **Waiting**: Время от отправки запроса до получения первого байта {textbox}
- **Total**: Общее время запроса {textbox}

## **Перцентили времени ответа**

```
50%    {textbox}    ← Медиана - половина запросов быстрее {textbox} мс
66%    {textbox}
75%    {textbox}
80%    {textbox}
90%    {textbox}    ← 90% запросов выполнены за {textbox} мс или быстрее
95%    {textbox}
98%    {textbox}
99%    {textbox}
100%   {textbox}    ← Самый медленный запрос
```

## **Анализ качества**

```
Failed requests: 0          ← Ошибок нет
Non-2xx responses: 1000     ← Все ответы не 2xx статус (возможно 3xx редиректы)
Total transferred: {textbox} bytes
HTML transferred: {textbox} bytes
Transfer rate: {textbox} [Kbytes/sec]
```

## **Выводы о производительности**

1. **Стабильность**: Низкое стандартное отклонение ({textbox} мс) - стабильная работа
2. **Производительность**: {textbox} запроса/секунду - умеренная нагрузка
3. **Задержки**: Среднее время ответа ~{textbox} мс - типично для географически удаленного сервера
4. **Надежность**: 0 неудачных запросов - сервер стабилен
5. **Масштабируемость**: 90% запросов в пределах {textbox} мс - хорошая предсказуемость

## **Рекомендации для улучшения**

- Оптимизировать можно за счет кеширования
- Рассмотреть CDN для уменьшения задержек
- Увеличить параллелизм для проверки пределов сервера

Это хороший результат для публичного сервиса с географической удаленностью.

#### Задача для студентов:

1. Протестировать 3 разных сайта
2. Сравнить их производительность
3. Построить график зависимости RPS от количества одновременных соединений


### Задание 2: Измерение задержек (latency) в микросервисах (25 мин)

#### Простой HTTP сервер с задержками:

```python
from flask import Flask
import time
import random

app = Flask(__name__)

@app.route('/fast')
def fast_endpoint():
    return {'response': 'fast', 'latency': '10ms'}

@app.route('/slow')  
def slow_endpoint():
    time.sleep(random.uniform(0.1, 0.5))  # 100-500ms задержка
    return {'response': 'slow', 'latency': '100-500ms'}

if __name__ == '__main__':
    app.run(port=5000)
```

#### Измерение latency:

```bash
# Тестирование быстрого endpoint
ab -n 100 -c 5 http://localhost:5000/fast

# Тестирование медленного endpoint  
ab -n 100 -c 5 http://localhost:5000/slow

# Сравнение результов 
```

## Самостоятельная работа

#### Создайте простые HTTP сервера с таким же эндпоиниами и задержками на:

* Fastapi (на порту 8000) и протестируй latency
{код на python}
краткие выводы
{выводы}
* Django  (на порту 8001) и протестируй latency
{код на python}
краткие выводы
{выводы}
* Django REST Framework  (на порту 8002) и протестируй latency
{код на python}
краткие выводы
{выводы}
* LiteStar (на порту 8003) и протестируй latency
{код на python}
краткие выводы
{выводы}

Напишите выводы о производительности веб-фрейморков 

{ textarea}
{кнопка сохранить в pdf}

## Домашнее задание:

### Задача: Доделать задания

**Срок сдачи:** К следующему занятию

---

## Критерии оценки:

- **Отлично (5):** Понимание всех концепций, правильные измерения, обоснованные выводы
- **Хорошо (4):** Хорошее понимание основных концепций, небольшие неточности в измерениях
- **Удовлетворительно (3):** Базовое понимание, ошибки в интерпретации результатов
- **Неудовлетворительно (2):** Непонимание основных концепций, неверные измерения

## Литература:

- Клеппман М. "Высоконагруженные приложения"
- Фаулер М. "Архитектура корпоративных программных приложений"

