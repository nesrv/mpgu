# Занятие 1-2: Основы высоконагруженных систем
## Лекция (4 ч) + Практика (4 ч)

---

## Лекция 1: Определение высоких нагрузок (2 ч)

### 1.1 Что такое высоконагруженная система?

**Определение:** Высоконагруженная система - это система, которая должна обрабатывать большое количество одновременных запросов при сохранении приемлемого времени отклика и надежности.

#### Критерии высокой нагрузки:
- **RPS (Requests Per Second):** > 1000 запросов/сек
- **Concurrent Users:** > 10,000 одновременных пользователей  
- **Data Volume:** > 1TB данных
- **Availability:** > 99.9% (менее 8.76 часов простоя в год)

### 1.2 Примеры высоконагруженных систем

#### Российские примеры:
- **Яндекс.Поиск:** 100+ млн запросов/день
- **ВКонтакте:** 97 млн активных пользователей/месяц
- **Wildberries:** 50+ млн заказов/месяц
- **Сбербанк Онлайн:** 70+ млн пользователей

#### Мировые примеры:
- **Google Search:** 8.5 млрд запросов/день
- **Facebook:** 2.9 млрд активных пользователей
- **Netflix:** 230+ млн подписчиков

### 1.3 Проблемы высоконагруженных систем

#### Технические вызовы:
1. **Производительность** - медленный отклик при росте нагрузки
2. **Масштабируемость** - невозможность добавить ресурсы
3. **Надежность** - частые сбои и недоступность
4. **Консистентность данных** - проблемы синхронизации

#### Бизнес-последствия:
- Потеря пользователей (1 сек задержки = -7% конверсии)
- Репутационные риски
- Финансовые потери (Amazon теряет $1.6 млрд при часе простоя)

---

## Лекция 2: Метрики производительности (2 ч)

### 2.1 Основные метрики

#### RPS (Requests Per Second)
**Определение:** Количество запросов, обрабатываемых системой за секунду

**Примеры:**
- Простой сайт: 10-100 RPS
- Средний веб-сервис: 1,000-10,000 RPS  
- Высоконагруженная система: 100,000+ RPS

**Формула:** RPS = Общее количество запросов / Время в секундах

#### Latency (Задержка)
**Определение:** Время от отправки запроса до получения ответа

**Типы задержек:**
- **Network Latency:** время передачи по сети
- **Processing Latency:** время обработки на сервере
- **Database Latency:** время выполнения запроса к БД

**Приемлемые значения:**
- Веб-страницы: < 200ms
- API: < 100ms
- Реального времени: < 10ms

#### Throughput (Пропускная способность)
**Определение:** Объем данных, передаваемых за единицу времени

**Измерения:**
- MB/s, GB/s для данных
- Transactions/s для транзакций
- Messages/s для очередей

### 2.2 Дополнительные метрики

#### Percentiles (Процентили)
- **P50 (медиана):** 50% запросов быстрее этого времени
- **P95:** 95% запросов быстрее
- **P99:** 99% запросов быстрее
- **P99.9:** 99.9% запросов быстрее

**Пример:** P95 = 200ms означает, что 95% запросов выполняются быстрее 200ms

#### Availability (Доступность)
**Формула:** Availability = (Uptime / Total Time) × 100%

**SLA уровни:**
- 99% = 3.65 дней простоя в год
- 99.9% = 8.76 часов простоя в год  
- 99.99% = 52.56 минут простоя в год
- 99.999% = 5.26 минут простоя в год

### 2.3 CAP-теорема

**Определение:** В распределенной системе невозможно одновременно гарантировать все три свойства:

#### C - Consistency (Согласованность)
Все узлы видят одинаковые данные одновременно

**Пример:** После записи в базу данных все реплики должны показывать новое значение

#### A - Availability (Доступность)  
Система остается доступной для операций

**Пример:** Система отвечает на запросы даже при отказе части узлов

#### P - Partition Tolerance (Устойчивость к разделению)
Система продолжает работать при потере связи между узлами

**Пример:** Система работает даже если связь между дата-центрами прервана

#### Практические компромиссы:
- **CP системы:** MongoDB, Redis Cluster (жертвуют доступностью)
- **AP системы:** Cassandra, DynamoDB (жертвуют согласованностью)  
- **CA системы:** PostgreSQL, MySQL (не устойчивы к разделению)

### 2.4 ACID свойства

#### A - Atomicity (Атомарность)
Транзакция выполняется полностью или не выполняется вообще

**Пример:** Перевод денег - либо списание И зачисление, либо ничего

#### C - Consistency (Согласованность)
База данных переходит из одного согласованного состояния в другое

**Пример:** Сумма на всех счетах остается неизменной после перевода

#### I - Isolation (Изолированность)
Параллельные транзакции не влияют друг на друга

**Уровни изоляции:**
- Read Uncommitted
- Read Committed  
- Repeatable Read
- Serializable

#### D - Durability (Долговечность)
Зафиксированные изменения сохраняются навсегда

**Пример:** После подтверждения транзакции данные не теряются даже при сбое

---

## Практическое занятие 1: Измерение производительности (2 ч)

### Задание 1: Нагрузочное тестирование с Apache Bench (45 мин)

#### Установка инструментов:
```bash
# Ubuntu/Debian
sudo apt-get install apache2-utils

# Windows (через WSL или скачать)
# MacOS
brew install httpie
```

#### Тестирование простого веб-сервера:
```bash
# Запуск 1000 запросов с 10 одновременными соединениями
ab -n 1000 -c 10 http://httpbin.org/get

# Анализ результатов:
# - Requests per second
# - Time per request  
# - Transfer rate
# - Percentiles
```

#### Задача для студентов:
1. Протестировать 3 разных сайта
2. Сравнить их производительность
3. Построить график зависимости RPS от количества одновременных соединений

### Задание 2: Мониторинг системных ресурсов (30 мин)

#### Использование htop/top:
```bash
# Мониторинг CPU, памяти, процессов
htop

# Мониторинг сетевой активности  
iftop

# Мониторинг дискового I/O
iotop
```

#### Задача:
Запустить нагрузочный тест и одновременно мониторить:
- Загрузку CPU
- Использование памяти
- Сетевой трафик
- Дисковые операции

### Задание 3: Анализ логов веб-сервера (25 мин)

#### Пример лога Apache:
```
127.0.0.1 - - [25/Dec/2023:10:00:01 +0000] "GET /api/users HTTP/1.1" 200 1234 0.150
127.0.0.1 - - [25/Dec/2023:10:00:02 +0000] "POST /api/orders HTTP/1.1" 201 567 0.300
```

#### Задача:
Написать скрипт для анализа:
- Среднее время ответа
- Количество запросов по статус-кодам
- Топ самых медленных запросов

---

## Практическое занятие 2: CAP-теорема на практике (2 ч)

### Задание 1: Эксперимент с Redis Cluster (45 мин)

#### Настройка кластера:
```bash
# Запуск 3 узлов Redis
redis-server --port 7000 --cluster-enabled yes
redis-server --port 7001 --cluster-enabled yes  
redis-server --port 7002 --cluster-enabled yes

# Создание кластера
redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002
```

#### Тестирование CAP свойств:
```python
import redis
import time

# Подключение к кластеру
r = redis.Redis(host='127.0.0.1', port=7000)

# Тест согласованности
r.set('key1', 'value1')
print(r.get('key1'))  # Проверка на всех узлах

# Тест доступности при отказе узла
# Остановить один узел и проверить доступность
```

### Задание 2: ACID vs BASE сравнение (30 мин)

#### ACID транзакция (PostgreSQL):
```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

#### BASE операция (MongoDB):
```javascript
// Eventual consistency пример
db.accounts.updateOne({id: 1}, {$inc: {balance: -100}});
db.accounts.updateOne({id: 2}, {$inc: {balance: 100}});
// Согласованность достигается со временем
```

### Задание 3: Измерение latency в микросервисах (25 мин)

#### Простой HTTP сервер с задержками:
```python
from flask import Flask
import time
import random

app = Flask(__name__)

@app.route('/fast')
def fast_endpoint():
    return {'response': 'fast', 'latency': '10ms'}

@app.route('/slow')  
def slow_endpoint():
    time.sleep(random.uniform(0.1, 0.5))  # 100-500ms задержка
    return {'response': 'slow', 'latency': '100-500ms'}

if __name__ == '__main__':
    app.run(port=5000)
```

#### Измерение latency:
```bash
# Тестирование быстрого endpoint
ab -n 100 -c 5 http://localhost:5000/fast

# Тестирование медленного endpoint  
ab -n 100 -c 5 http://localhost:5000/slow

# Сравнение percentiles
```

---

## Домашнее задание:

### Задача: Анализ производительности реального сервиса

1. **Выберите публичный API** (например, JSONPlaceholder, GitHub API, OpenWeatherMap)

2. **Проведите нагрузочное тестирование:**
   - Измерьте RPS при разной нагрузке (1, 5, 10, 20 одновременных соединений)
   - Постройте график зависимости latency от нагрузки
   - Определите точку деградации производительности

3. **Проанализируйте результаты:**
   - При какой нагрузке система начинает деградировать?
   - Какие percentiles (P95, P99) показывают проблемы?
   - Есть ли признаки rate limiting?

4. **Предложите улучшения:**
   - Какие узкие места вы видите?
   - Как можно улучшить производительность?
   - Какие компромиссы CAP-теоремы делает система?

**Формат отчета:** 3-4 страницы с графиками и выводами
**Срок сдачи:** К следующему занятию

---

## Критерии оценки:

- **Отлично (5):** Понимание всех концепций, правильные измерения, обоснованные выводы
- **Хорошо (4):** Хорошее понимание основных концепций, небольшие неточности в измерениях  
- **Удовлетворительно (3):** Базовое понимание, ошибки в интерпретации результатов
- **Неудовлетворительно (2):** Непонимание основных концепций, неверные измерения

## Литература:
- Клеппман М. "Высоконагруженные приложения"
- Фаулер М. "Архитектура корпоративных программных приложений"  
- Документация Apache Bench, Redis, PostgreSQL