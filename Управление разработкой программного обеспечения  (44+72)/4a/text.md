# Занятие 2: Процессы разработки ПО

**Продолжительность:** 2 академических часа (лекция)

## 1. Введение в процессы разработки ПО (20 мин)

### Определение процесса разработки ПО

**Процесс разработки ПО** - это структурированный набор действий, методов и практик, используемых для создания программного продукта от идеи до внедрения и сопровождения.

**На программистском сленге:** Это как рецепт приготовления кода - без него получается "спагетти-код" вместо нормального продукта. Процесс помогает не "наговнокодить" и не попасть в "dependency hell".

### Цели процессов разработки:

- **Управляемость** - контроль над ходом разработки
- **Предсказуемость** - возможность планирования сроков и ресурсов
- **Качество** - обеспечение соответствия требованиям
- **Повторяемость** - возможность воспроизведения успешного опыта
- **Масштабируемость** - адаптация под размер команды и проекта

### Характеристики эффективного процесса:

- **Понятность** - все участники понимают свои роли
- **Видимость** - прогресс проекта отслеживается
- **Поддержка** - процесс поддерживается инструментами
- **Приемлемость** - команда принимает процесс
- **Надежность** - процесс не зависит от отдельных людей
- **Устойчивость** - процесс адаптируется к изменениям
- **Быстрота** - процесс не замедляет разработку

## 2. Классификация процессов разработки ПО (30 мин)

### По подходу к планированию:

#### Предиктивные (Plan-Driven) процессы

**Характеристики:**

- Детальное планирование на начальных этапах
- Последовательное выполнение фаз
- Обширная документация
- Формальные процедуры контроля изменений

**Примеры:** Waterfall, V-Model, RUP

**Преимущества:**

- Четкое планирование и контроль
- Подходит для больших команд
- Хорошо документированные требования
- Предсказуемые сроки и бюджет

**Недостатки:**

- Низкая адаптивность к изменениям
- Поздняя обратная связь от пользователей
- Высокие риски при неточных требованиях

**Реальный кейс:** В 2013 году Healthcare.gov (сайт Obamacare) провалился именно из-за Waterfall подхода. Потратили $600 млн, 3 года разработки, а в итоге сайт "лег" в первый же день запуска. Пользователи не могли зарегистрироваться, система не выдерживала нагрузку. Пришлось экстренно переписывать на Agile подходе.

#### Адаптивные (Agile) процессы

**Характеристики:**

- Итеративная разработка
- Быстрая адаптация к изменениям
- Минимальная документация
- Тесное взаимодействие с заказчиком

**Примеры:** Scrum, Kanban, XP, Crystal

**Преимущества:**

- Быстрая реакция на изменения
- Ранняя и частая обратная связь
- Высокое качество кода
- Мотивированная команда

**Недостатки:**

- Сложность планирования
- Требует опытную команду
- Может не подходить для больших проектов

**Жизненный кейс:** Spotify использует модифицированный Agile ("Spotify Model") с автономными командами ("сквадами"). Результат - они могут деплоить код до 10,000 раз в день! Но это работает только потому, что у них культура "fail fast" и очень опытные девелоперы.

### По структуре выполнения:

#### Линейные модели

- **Waterfall (Каскадная модель)**
- **V-Model**
- Последовательное выполнение фаз
- Переход к следующей фазе только после завершения предыдущей

#### Итеративные модели

- **Iterative Development**
- **Spiral Model**
- Повторение циклов разработки
- Постепенное наращивание функциональности

#### Инкрементальные модели

- **Incremental Development**
- **RAD (Rapid Application Development)**
- Поставка работающих частей системы
- Параллельная разработка компонентов

#### Эволюционные модели

- **Прототипирование (Prototyping)**
- **Эволюционная разработка (Evolutionary Development)**
- Развитие системы через прототипы
- Уточнение требований в процессе разработки

## 3. Анализ требований (30 мин)

### Определение и важность

**Анализ требований** - процесс выявления, документирования и управления требованиями к программной системе.

### Типы требований:

#### Функциональные требования

**Определение:** Описывают, что система должна делать

**Примеры:**

- Система должна позволять пользователям регистрироваться
- Система должна отправлять email-уведомления
- Система должна генерировать отчеты в формате PDF

**Программистский перевод:**

- "Нужна регистрация" = делаем форму + валидацию + хеширование паролей
- "Отправка емейлов" = интеграция с SMTP + очереди + retry логика
- "PDF отчеты" = либа для PDF + шаблоны + возможно headless браузер

**Характеристики качественных функциональных требований:**

- **Полнота** - покрывают все необходимые функции
- **Корректность** - точно отражают потребности пользователей
- **Однозначность** - имеют единственную интерпретацию
- **Проверяемость** - можно проверить их выполнение
- **Трассируемость** - связаны с бизнес-целями

#### Нефункциональные требования

**Определение:** Описывают качественные характеристики системы

**Категории:**

1. **Производительность**

   - Время отклика < 2 секунд
   - Пропускная способность > 1000 RPS
   - Время загрузки страницы < 3 секунд
2. **Надежность**

   - Доступность 99.9%
   - Среднее время восстановления < 1 час
   - Частота отказов < 0.1%
3. **Безопасность**

   - Аутентификация пользователей
   - Шифрование данных
   - Аудит действий пользователей
4. **Удобство использования**

   - Интуитивный интерфейс
   - Поддержка мобильных устройств
   - Многоязычность
5. **Масштабируемость**

   - Поддержка до 10,000 одновременных пользователей
   - Горизонтальное масштабирование
   - Автоматическое масштабирование нагрузки

### Процесс анализа требований:

#### 1. Выявление требований (Requirements Elicitation)

**Методы:**

- **Интервью** - структурированные беседы с заинтересованными сторонами
- **Анкетирование** - сбор информации от большого числа пользователей
- **Наблюдение** - изучение текущих рабочих процессов
- **Мозговой штурм** - генерация идей в группе
- **Анализ документов** - изучение существующей документации
- **Прототипирование** - создание макетов для уточнения требований

**Пример интервью:**

```
Вопросы для интервью с пользователем CRM системы:
1. Какие задачи вы выполняете ежедневно?
2. Какие проблемы возникают в текущем процессе?
3. Какую информацию вам нужно видеть на главном экране?
4. Как часто вы генерируете отчеты?
5. С какими системами должна интегрироваться новая система?
```

**Реальность интервью:**

- Пользователь: "Хочу как в Excel, но лучше"
- Аналитик: "А что именно лучше?"
- Пользователь: "Ну чтобы все было удобно"
- Аналитик: *внутренне плачет*

**Лайфхак:** Всегда спрашивайте "А что будет, если этой функции не будет?" - так отсеиваются "хотелки" от реальных потребностей.

#### 2. Анализ и моделирование требований

**Техники моделирования:**

- **Диаграммы вариантов использования (Use Case)** - описание взаимодействия пользователей с системой
- **Пользовательские истории (User Stories)** - краткое описание функциональности с точки зрения пользователя
- **Диаграммы потоков данных** - моделирование обработки информации
- **Диаграммы состояний** - описание поведения системы
- **Каркасы интерфейса (Wireframes)** - макеты пользовательского интерфейса

**Пример пользовательской истории (User Story):**

```
Как менеджер по продажам,
Я хочу видеть список всех моих клиентов с их контактной информацией,
Чтобы быстро связаться с ними при необходимости.

Критерии приемки:
- Список отображается в табличном виде
- Доступна сортировка по имени и дате последнего контакта
- Есть поиск по имени клиента
- Клик по клиенту открывает детальную информацию
```

**Как пользовательская история выглядит в реальности:**

```
Как менеджер по продажам,
Я хочу видеть список клиентов,
Чтобы не искать их в Excel'е по 20 минут.

Критерии приемки:
- Таблица должна грузиться быстрее чем за 3 секунды (иначе менеджеры будут ныть)
- Поиск должен работать даже при опечатках (менеджеры не умеют печатать)
- Мобильная версия обязательна (все сидят в телефонах)
- Экспорт в Excel (потому что от Excel'я никуда не деться)
```

#### 3. Документирование требований

**Структура документа требований:**

1. **Введение** - цели и область применения
2. **Общее описание** - контекст и ограничения
3. **Функциональные требования** - детальное описание функций
4. **Нефункциональные требования** - качественные характеристики
5. **Интерфейсы** - взаимодействие с внешними системами
6. **Приложения** - дополнительная информация

#### 4. Валидация и верификация требований

**Валидация** - проверка правильности требований (строим правильный продукт?)
**Верификация** - проверка соответствия требованиям (строим продукт правильно?)

**Методы валидации:**

- Обзоры требований с заинтересованными сторонами
- Прототипирование
- Тестирование приемки
- Моделирование и симуляция

### Управление требованиями:

- **Трассируемость** - связь требований с дизайном и тестами
- **Управление изменениями** - контролируемое внесение изменений
- **Версионирование** - отслеживание изменений требований
- **Приоритизация** - определение важности требований

**Техники приоритизации:**

- **MoSCoW** (Must have, Should have, Could have, Won't have)
- **Kano Model** - классификация по влиянию на удовлетворенность
- **Value vs Effort Matrix** - оценка по ценности и трудозатратам

**Программистская версия MoSCoW:**

- **Must have** - "Без этого продукт не работает" (авторизация, основной функционал)
- **Should have** - "Заказчик будет недоволен без этого" (уведомления, отчеты)
- **Could have** - "Nice to have" (темная тема, анимации)
- **Won't have** - "Фича для галочки" (интеграция с блокчейном "на всякий случай")

**Реальный кейс:** В одном проекте заказчик требовал интеграцию с 15 различными CRM системами. После анализа оказалось, что реально используются только 3. Остальные 12 были в категории "а вдруг понадобится".

## 4. Проектирование (25 мин)

### Определение архитектурного проектирования

**Архитектурное проектирование** - процесс определения структуры системы, ее компонентов и их взаимодействий.

### Уровни проектирования:

#### 1. Архитектурное проектирование (High-level Design)

**Цели:**

- Определение общей структуры системы
- Выбор архитектурных паттернов
- Определение основных компонентов
- Планирование интеграций

**Архитектурные стили:**

- **Layered Architecture** - слоистая архитектура ("слоеный пирог")
  ```
  Presentation Layer (UI) ← "Красивости для юзеров"
  ↓
  Business Logic Layer ← "Тут вся магия происходит"
  ↓
  Data Access Layer ← "Говорим с базой данных"
  ↓
  Database Layer ← "Тут данные живут"
  ```

**Жизненный пример:** Netflix начинал как монолит на Java, но когда стали расти, перешли на микросервисы. Сейчас у них больше 1000 микросервисов! Каждый отвечает за свою фичу - рекомендации, стриминг, биллинг и т.д.

- **Microservices Architecture** - микросервисная архитектура ("каждый сам за себя")
  ```
  User Service ← API Gateway → Order Service
       ↓           ("швейцар")        ↓
  User Database              Order Database
  ```

**Программистская правда:** Микросервисы это круто, но готовьтесь к "distributed monolith" - когда сервисы так связаны, что один падает и все остальные тоже ложатся. Плюс debugging превращается в квест "найди, какой из 50 сервисов сломался".

- **Event-Driven Architecture** - событийная архитектура
  ```
  Event Producer → Event Bus → Event Consumer
  ```

#### 2. Детальное проектирование (Low-level Design)

**Цели:**

- Проектирование классов и интерфейсов
- Определение алгоритмов
- Проектирование структур данных
- Планирование обработки ошибок

**Принципы проектирования:**

- **SOLID принципы**

  - **S** - Принцип единственной ответственности (Single Responsibility Principle)
  - **O** - Принцип открытости/закрытости (Open/Closed Principle)
  - **L** - Принцип подстановки Лисков (Liskov Substitution Principle)
  - **I** - Принцип разделения интерфейса (Interface Segregation Principle)
  - **D** - Принцип инверсии зависимостей (Dependency Inversion Principle)
- **DRY** - Не повторяйся (Don't Repeat Yourself)
- **KISS** - Делай проще (Keep It Simple, Stupid)
- **YAGNI** - Тебе это не понадобится (You Aren't Gonna Need It)

### Проектирование пользовательского интерфейса:

#### UX/UI Design Process:

1. **User Research** - исследование пользователей
2. **Information Architecture** - структура информации
3. **Wireframing** - создание каркасов
4. **Prototyping** - интерактивные прототипы
5. **Visual Design** - визуальное оформление
6. **Usability Testing** - тестирование удобства

#### Принципы UX дизайна:

- **Usability** - удобство использования
- **Accessibility** - доступность для всех пользователей
- **Consistency** - единообразие интерфейса
- **Feedback** - обратная связь с пользователем
- **Error Prevention** - предотвращение ошибок

**Реальный кейс UX провала:** Когда Snapchat в 2018 году кардинально изменил интерфейс, пользователи взбунтовались. Петицию за возврат старого дизайна подписали 1.2 млн человек! Акции компании упали на 6%. Урок: не меняйте кардинально то, к чему пользователи привыкли.

**Программистский перевод UX принципов:**

- **Usability** = "Даже твоя бабушка должна разобраться"
- **Accessibility** = "Работает даже на Internet Explorer" (шутка, IE уже умер)
- **Consistency** = "Кнопки везде выглядят одинаково, а не как новогодняя елка"
- **Feedback** = "Юзер должен понимать, что происходит, а не гадать"

### Проектирование базы данных:

#### Этапы проектирования БД:

1. **Концептуальное проектирование** - ER-диаграммы
2. **Логическое проектирование** - нормализация
3. **Физическое проектирование** - индексы, партиционирование

#### Пример ER-диаграммы для интернет-магазина:

```
Customer ||--o{ Order : places
Order ||--o{ OrderItem : contains
Product ||--o{ OrderItem : included_in
Category ||--o{ Product : categorizes
```

### Документирование проектирования:

- **Архитектурные диаграммы** - общая структура системы
- **Диаграммы компонентов** - взаимодействие модулей
- **Диаграммы последовательности** - временные взаимодействия
- **Диаграммы классов** - структура объектов
- **API документация** - описание интерфейсов

## 5. Кодирование (25 мин)

### Процесс кодирования

**Кодирование** - процесс реализации проектных решений в виде исходного кода программы.

### Стандарты кодирования:

#### Соглашения о наименованиях:

```python
# Переменные и функции - snake_case
user_name = 'john_doe'
def calculate_total_price():
    pass

# Константы - UPPER_SNAKE_CASE  
MAX_RETRY_ATTEMPTS = 3

# Классы - PascalCase
class UserService:
    pass

# Файлы - snake_case
user_service.py
```

**Программистская реальность:**

```python
# Как должно быть:
user_account_balance = 1000

# Как часто бывает:
bal = 1000  # какой bal? balance? ball? кто знает...
temp = get_data()  # temp что? временные данные? температура?
data = process_data(temp)  # какие data?

# Классика жанра:
thing = do_stuff(data)  # "thing" - это вершина креатива
```

**Лайфхак:** Если через месяц ты не понимаешь свой код - значит, имена переменных отстой.

#### Структура кода:

```python
# 1. Импорты
from user_service import UserService

# 2. Константы
DEFAULT_TIMEOUT = 5000

# 3. Основной код
class OrderProcessor:
    def __init__(self, user_service):
        self.user_service = user_service
    
    # Методы с комментариями
    async def process_order(self, order):
        # Валидация входных данных
        if not order or not order.get('items'):
            raise ValueError('Invalid order data')
        
        # Основная логика
        user = await self.user_service.get_user(order['user_id'])
        return self.calculate_total(order['items'])
```

### Практики качественного кодирования:

#### 1. Читаемость кода

**Принципы:**

- Осмысленные имена переменных и функций
- Короткие функции (< 20 строк)
- Минимальная вложенность (< 3 уровней)
- Комментарии для сложной логики

**Пример плохого кода ("говнокод"):**

```python
def calc(a, b, c):
    if a > 0:
        if b > 0:
            if c > 0:
                return a * b * c * 0.1  # что это за 0.1?
    return 0
```

**Программистские комментарии к такому коду:**

- "Кто это писал? Обезьяна с клавиатурой?"
- "Магические числа - зло!"
- "Пирамида смерти из if'ов"
- "Имена переменных a, b, c - это не информативно, это издевательство"

**Пример хорошего кода ("чистый код"):**

```python
def calculate_discounted_price(original_price, discount_percent, quantity):
    DISCOUNT_MULTIPLIER = 0.01
    
    if original_price <= 0 or discount_percent <= 0 or quantity <= 0:
        return 0
    
    discount_amount = original_price * discount_percent * DISCOUNT_MULTIPLIER
    return (original_price - discount_amount) * quantity
```

**Программистские плюсы:**

- "Сразу понятно, что функция делает"
- "Константа вынесена - магических чисел нет"
- "Early return - красота!"
- "Через год прочитаешь и поймешь без комментариев"
- "Code review пройдет без замечаний"

#### 2. Обработка ошибок

```python
# Явная обработка ошибок
async def fetch_user_data(user_id):
    try:
        response = await api.get_user(user_id)
        
        if not response.ok:
            raise Exception(f'HTTP error! status: {response.status}')
        
        return await response.json()
    except Exception as error:
        logger.error('Failed to fetch user data', {'user_id': user_id, 'error': str(error)})
        raise UserFetchError(f'Unable to fetch user {user_id}') from error
```

#### 3. Рефакторинг

**Признаки необходимости рефакторинга ("code smells"):**

- Дублирование кода ("copy-paste programming")
- Длинные методы (> 20 строк) - "простыня кода"
- Большие классы (> 200 строк) - "класс-монстр"
- Длинные списки параметров (> 3) - "parameter hell"
- Сложные условные выражения - "спагетти-логика"

**Программистские "ароматы" плохого кода:**

- **"Shotgun Surgery"** - одно изменение требует правок в 10 местах
- **"God Object"** - класс, который все знает и все делает
- **"Dead Code"** - код, который никто не использует, но боятся удалить
- **"Magic Numbers"** - числа без объяснения (42, 3.14159, 1000)
- **"Primitive Obsession"** - использование примитивов вместо объектов

**Реальный кейс:** В одном проекте нашли метод на 2000 строк. Он делал все - валидацию, бизнес-логику, работу с БД, отправку емейлов. Рефакторинг занял 2 недели, но потом багов стало в 3 раза меньше.

**Техники рефакторинга:**

- **Extract Method** - выделение метода
- **Extract Class** - выделение класса
- **Rename** - переименование
- **Move Method** - перемещение метода
- **Replace Conditional with Polymorphism** - замена условий полиморфизмом

### Инструменты разработки:

#### Системы контроля версий:

```bash
# Git workflow ("гит-фу")
git checkout -b feature/user-authentication
git add .
git commit -m "Add user authentication logic"
git push origin feature/user-authentication
# Create Pull Request
```

**Программистская реальность Git:**

```bash
# Как должно быть:
git commit -m "Fix user authentication bug"

# Как часто бывает:
git commit -m "fix"
git commit -m "fix fix"
git commit -m "actually fix"
git commit -m "fuck this shit"
git commit -m "sorry for previous commit message"
```

**Классические Git ситуации:**

- **"Git blame"** - поиск виноватого в багах (обычно это ты сам 6 месяцев назад)
- **"Merge hell"** - когда конфликты в каждом файле
- **"Force push"** - ядерная опция ("я все сломал, но исправлю")
- **"Detached HEAD"** - "помогите, я не знаю где я"

#### Линтеры и форматтеры:

```ini
# .flake8
[flake8]
max-line-length = 88
ignore = E203, W503
exclude = .git,__pycache__,venv

# pyproject.toml (для black)
[tool.black]
line-length = 88
target-version = ['py38']
```

#### IDE и редакторы:

- **Visual Studio Code** - популярный редактор
- **IntelliJ IDEA** - мощная IDE для Java
- **WebStorm** - IDE для веб-разработки
- **Vim/Neovim** - консольные редакторы

### Совместная разработка:

#### Code Review процесс ("ревьюхи"):

1. **Создание Pull Request**
2. **Автоматические проверки** (тесты, линтеры)
3. **Ревью кода** коллегами
4. **Исправление замечаний**
5. **Merge в основную ветку**

**Реальность Code Review:**

```
// Комментарий ревьюера:
"Почему здесь используется var вместо const?"

// Ответ автора:
"Потому что я привык к старому JS"

// Ревьюер:
"Это 2025 год, var это зло"

// Автор:
"Окей, исправлю... *внутренне закатывает глаза*"
```

**Типы ревьюеров:**

- **"Nitpicker"** - придирается к каждой запятой
- **"LGTM Bot"** - ставит "Looks Good To Me" не читая
- **"Perfectionist"** - требует переписать все с нуля
- **"Mentor"** - дает конструктивные советы

**Золотое правило:** Критикуй код, а не программиста. "Этот код плохой" вместо "Ты плохо кодишь".

#### Критерии качественного Code Review:

- Соответствие требованиям
- Читаемость и поддерживаемость
- Производительность
- Безопасность
- Тестируемость

## 6. Тестирование (20 мин)

### Определение и цели тестирования

**Тестирование ПО** - процесс исследования программного продукта с целью получения информации о его качестве.

**Цели тестирования:**

- Обнаружение дефектов
- Подтверждение соответствия требованиям
- Оценка качества продукта
- Снижение рисков
- Повышение уверенности в продукте

### Уровни тестирования:

#### 1. Модульное тестирование (Unit Testing)

**Определение:** Тестирование отдельных компонентов или модулей программы

**Характеристики:**

- Тестируются изолированные единицы кода
- Быстрое выполнение
- Автоматизированное
- Пишется разработчиками

**Пример unit теста:**

```python
# Тестируемая функция
def calculate_tax(price, tax_rate):
    if price < 0 or tax_rate < 0:
        raise ValueError('Price and tax rate must be positive')
    return price * tax_rate

# Unit тест
import pytest

class TestCalculateTax:
    def test_should_calculate_tax_correctly(self):
        assert calculate_tax(100, 0.1) == 10
    
    def test_should_throw_error_for_negative_price(self):
        with pytest.raises(ValueError, match='Price and tax rate must be positive'):
            calculate_tax(-100, 0.1)
    
    def test_should_handle_zero_values(self):
        assert calculate_tax(0, 0.1) == 0
        assert calculate_tax(100, 0) == 0
```

**Программистская философия тестирования:**

- **"Red-Green-Refactor"** - сначала тест падает (красный), потом пишем код чтобы прошел (зеленый), потом улучшаем (рефакторинг)
- **"Test-Driven Development (TDD)"** - сначала тест, потом код. Звучит странно, но работает
- **"Happy Path vs Edge Cases"** - тестируем не только "все хорошо", но и "все плохо"

**Реальный кейс:** В 2012 году Knight Capital потеряла $440 млн за 45 минут из-за бага в торговом алгоритме. Проблема была в том, что старый код не удалили, и он активировался при определенных условиях. Хорошие тесты могли бы это предотвратить.

#### 2. Интеграционное тестирование (Integration Testing)

**Определение:** Тестирование взаимодействия между компонентами системы

**Подходы:**

- **Big Bang** - одновременное тестирование всех компонентов
- **Incremental** - постепенное добавление компонентов
  - **Top-down** - от верхнего уровня к нижнему
  - **Bottom-up** - от нижнего уровня к верхнему

**Пример интеграционного теста:**

```python
import pytest

class TestUserRegistrationIntegration:
    @pytest.mark.asyncio
    async def test_should_register_user_and_send_welcome_email(self):
        # Arrange
        user_data = {'email': 'test@example.com', 'password': 'password123'}
        
        # Act
        result = await user_service.register_user(user_data)
        
        # Assert
        assert result['success'] is True
        assert result['user']['email'] == user_data['email']
        
        # Проверяем, что email был отправлен
        sent_emails = await email_service.get_sent_emails()
        assert len(sent_emails) == 1
        assert sent_emails[0]['to'] == user_data['email']
        assert 'Welcome' in sent_emails[0]['subject']
```

#### 3. Системное тестирование (System Testing)

**Определение:** Тестирование полной интегрированной системы

**Типы системного тестирования:**

- **Функциональное** - проверка функциональных требований
- **Производительности** - нагрузочное тестирование
- **Безопасности** - проверка уязвимостей
- **Удобства использования** - UX тестирование

#### 4. Приемочное тестирование (Acceptance Testing)

**Определение:** Тестирование системы на соответствие бизнес-требованиям

**Виды:**

- **User Acceptance Testing (UAT)** - тестирование пользователями
- **Business Acceptance Testing (BAT)** - тестирование бизнес-процессов
- **Alpha Testing** - внутреннее тестирование
- **Beta Testing** - тестирование ограниченной группой пользователей

### Виды тестирования по подходу:

#### Функциональное тестирование

**Техники:**

- **Equivalence Partitioning** - разбиение на классы эквивалентности
- **Boundary Value Analysis** - анализ граничных значений
- **Decision Table Testing** - тестирование таблиц решений

**Пример граничных значений:**

```python
# Функция принимает возраст от 18 до 65
def validate_age(age):
    return 18 <= age <= 65

# Тестовые случаи для граничных значений:
# 17 (невалидно), 18 (валидно), 19 (валидно)
# 64 (валидно), 65 (валидно), 66 (невалидно)
```

#### Нефункциональное тестирование

**Типы:**

- **Performance Testing** - тестирование производительности
- **Load Testing** - тестирование нагрузки
- **Stress Testing** - стресс-тестирование
- **Security Testing** - тестирование безопасности
- **Usability Testing** - тестирование удобства использования

### Автоматизация тестирования:

#### Пирамида тестирования ("тестовая пирамида"):

```
    /\
   /  \    E2E Tests (мало, медленные, дорогие)
  /____\   "Тесты от пользователя"
 /      \   Integration Tests (средне)
/  "API"  \  "Компоненты дружат?"
/__________\
Unit Tests (много, быстрые, дешевые)
"Функция работает?"
```

**Программистская интерпретация:**

- **Unit тесты** - "Моя функция не сломана?"
- **Integration тесты** - "Мои компоненты не ругаются друг с другом?"
- **E2E тесты** - "Пользователь может купить товар, не сломав сайт?"

**Анти-паттерн "Ice Cream Cone"** (перевернутая пирамида):

```
/__________\
 \        /  E2E Tests (много, медленные)
  \____/    Integration Tests (мало)
    \/      Unit Tests (почти нет)
```

**Результат:** Тесты работают час, падают от любого чиха, никто не знает в чем проблема.

#### Инструменты автоматизации:

- **Unit Testing:** Jest, Mocha, JUnit, pytest
- **Integration Testing:** Postman, REST Assured
- **E2E Testing:** Selenium, Cypress, Playwright
- **Performance Testing:** JMeter, LoadRunner, k6

#### Пример E2E теста:

```python
# Selenium E2E тест
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

class TestUserLoginFlow:
    def test_should_allow_user_to_login_with_valid_credentials(self):
        driver = webdriver.Chrome()
        driver.get('/login')
        
        driver.find_element(By.CSS_SELECTOR, '[data-testid=email-input]').send_keys('user@example.com')
        driver.find_element(By.CSS_SELECTOR, '[data-testid=password-input]').send_keys('password123')
        driver.find_element(By.CSS_SELECTOR, '[data-testid=login-button]').click()
        
        WebDriverWait(driver, 10).until(EC.url_contains('/dashboard'))
        welcome_message = driver.find_element(By.CSS_SELECTOR, '[data-testid=welcome-message]')
        assert 'Welcome' in welcome_message.text
        
        driver.quit()
```

### Управление дефектами:

#### Жизненный цикл дефекта ("баг-трекинг"):

1. **New** - новый дефект ("нашли косяк")
2. **Assigned** - назначен разработчику ("твоя очередь разгребать")
3. **In Progress** - в работе ("копаюсь в коде")
4. **Fixed** - исправлен ("вроде починил")
5. **Testing** - на тестировании ("тестеры проверяют")
6. **Closed** - закрыт ("все довольны")
7. **Reopened** - переоткрыт ("опять сломалось, блин!")

**Дополнительные статусы в реальной жизни:**

- **"Won't Fix"** - "это не баг, это фича"
- **"Can't Reproduce"** - "у меня работает" ¯\_(ツ)_/¯
- **"Duplicate"** - "уже есть такой баг"
- **"Works As Designed"** - "так и задумано" (спорный статус)

**Классические отговорки разработчиков:**

- "У меня на локалке работает"
- "Это не баг, это особенность"
- "Пользователи используют систему неправильно"
- "Это проблема окружения, а не кода"

#### Приоритеты дефектов:

- **Critical** - блокирует основную функциональность
- **High** - серьезно влияет на функциональность
- **Medium** - умеренное влияние
- **Low** - минимальное влияние

## 7. Интеграция процессов в жизненном цикле ПО (10 мин)

### Взаимосвязь процессов:

```
Требования → Проектирование → Кодирование → Тестирование
     ↑              ↑              ↑              ↓
     ←──────────── Обратная связь ←──────────────
```

### Современные подходы к интеграции:

#### DevOps подход:

- **Continuous Integration (CI)** - непрерывная интеграция
- **Continuous Delivery (CD)** - непрерывная доставка
- **Infrastructure as Code** - инфраструктура как код
- **Monitoring and Logging** - мониторинг и логирование

#### Agile интеграция:

- **Sprint Planning** - планирование спринта включает все процессы
- **Daily Standups** - ежедневная синхронизация команды
- **Sprint Review** - демонстрация результатов
- **Retrospective** - анализ и улучшение процессов

### Метрики качества процессов:

- **Lead Time** - время от идеи до внедрения
- **Cycle Time** - время выполнения задачи
- **Defect Density** - количество дефектов на единицу кода
- **Code Coverage** - покрытие кода тестами
- **Customer Satisfaction** - удовлетворенность клиентов

## Заключение и вопросы для обсуждения (10 мин)

### Ключевые выводы:

1. Процессы разработки ПО обеспечивают структурированный подход к созданию качественного программного продукта
2. Выбор процесса зависит от размера проекта, команды, требований и ограничений
3. Все процессы взаимосвязаны и должны работать как единая система
4. Качество процессов напрямую влияет на качество конечного продукта

### Вопросы для обсуждения:

1. **Какой процесс разработки лучше выбрать для стартапа с неопределенными требованиями?**
   *Подсказка: когда не знаешь что строить, Waterfall = самоубийство*
2. **Как обеспечить качество требований при работе с заказчиком, который не может четко сформулировать свои потребности?**
   *Классика: "Хочу сайт как у Apple, но дешевле и за неделю"*
3. **В каких случаях стоит жертвовать качеством кода ради скорости разработки?**
   *Технический долг vs время на рынок - вечная дилемма*
4. **Как найти баланс между автоматизированным и ручным тестированием?**
   *"Автоматизируй все!" vs "Человек лучше найдет баги"*

**Бонусные вопросы для продвинутых:**
5. **Что делать, если заказчик просит "небольшую правочку" за день до релиза?**
6. **Как объяснить менеджменту, что рефакторинг это не "переписывание рабочего кода"?**
7. **Стоит ли покрывать тестами legacy код, который "работает уже 5 лет"?**

### Домашнее задание:

1. Проанализировать процессы разработки в известной IT-компании (по публичным материалам)
2. Создать пример User Story для выбранной предметной области
3. Написать unit-тест для простой функции на любом языке программирования

### Литература для изучения:

- **Обязательная:**

  - Sommerville I. "Software Engineering" - Chapters 4-8
  - Pressman R. "Software Engineering: A Practitioner's Approach" - Part 2
- **Дополнительная:**

  - Beck K. "Test Driven Development: By Example"
  - Martin R. "Clean Code: A Handbook of Agile Software Craftsmanship"
  - Fowler M. "Refactoring: Improving the Design of Existing Code"
