# Текст для лектора: ORM и продвинутая работа с БД

## Слайд 1: OLAP и OLTP

**Начало:**
Окей, народ, сегодня разбираем базы данных, но не просто "создать таблицу и запихнуть туда данные", а как настоящие архитекторы систем. Представьте: вы пришли на собес, и вас спрашивают "чем OLTP отличается от OLAP?" — если молчите, то привет, джуниор навсегда.

**OLTP — это ваш боевой конь:**
- Это когда юзер кликает "купить айфон" — бац, INSERT в базу
- Или меняет адрес доставки — UPDATE
- Удаляет товар из корзины — DELETE
- Короче, все что происходит ПРЯМО СЕЙЧАС, в реальном времени
- Примеры: банковские переводы (списали с одного, зачислили на другой), интернет-магазины, CRM

**Ассоциация:** OLTP — это как кассир в Пятёрочке. Пробил товар, взял деньги, выдал чек. Быстро, четко, по одной операции.

**OLAP — это ваш аналитик:**
- Это когда директор магазина вечером смотрит: "А сколько мы сегодня продали?"
- Или маркетолог: "Какие товары лучше продаются в Москве?"
- Куча SELECT'ов с GROUP BY, SUM, AVG
- Обрабатываем миллионы строк, строим отчеты
- Примеры: дашборды в Power BI, отчеты для руководства

**Ассоциация:** OLAP — это как бухгалтер в конце месяца. Сидит, считает, анализирует, строит графики. Медленно, но глубоко.

---

## Слайд 2: СУБД для OLAP и OLTP

**Переход:**
Теперь вопрос: на чем это все крутить? Нельзя же на одной базе и кассу вести, и отчеты строить — она просто ляжет.

**OLTP базы:**
- PostgreSQL — наш любимчик, надежный как танк
- MySQL/MariaDB — быстрый, но с нюансами
- Oracle — для корпоратов с деньгами
- MS SQL Server — если вы в экосистеме Microsoft

**Почему они для OLTP?** Потому что заточены под транзакции: ACID, индексы, блокировки. Вставил запись — она сразу видна. Откатил — как будто ничего не было.

**OLAP базы:**
- ClickHouse — монстр от Яндекса, жрет миллиарды строк на завтрак
- Apache Druid — для real-time аналитики
- Greenplum — если нужна распределенная система
- Vertica — колоночная база для больших данных

**Почему они для OLAP?** Колоночное хранение. Представьте: у вас таблица с 100 колонками, а вам нужна только одна — "цена". PostgreSQL прочитает ВСЕ 100 колонок, а ClickHouse — только "цену". Разница в 100 раз по скорости!

**Ассоциация:** OLTP база — это спринтер (быстро, коротко). OLAP база — это марафонец (долго, но выносливо).

---

## Слайд 3: Российский рынок

**Переход:**
Окей, а что у нас в России? Импортозамещение же, санкции, все дела.

**OLTP решения:**
- PostgresPro — это наш PostgreSQL, но с поддержкой на русском и сертификацией
- Tarantool — in-memory база, очень быстрая, от Mail.ru
- YDB — распределенная база от Яндекса, как Google Spanner

**OLAP решения:**
- ClickHouse — гордость Яндекса, open source, весь мир использует
- Greenplum — есть российская поддержка от Arenadata
- 1C:Enterprise — для бизнес-аналитики, если вы в мире 1С

**Импортозамещение:**
- Oracle уходит → ставим PostgresPro
- MS SQL Server → тоже PostgresPro или YDB
- Главное — не паниковать, аналоги есть

**Ассоциация:** Российский рынок — это как переезд из съемной квартиры в свою. Сначала непривычно, но потом понимаешь, что даже лучше.

---

## Слайд 4: PostgreSQL как OLAP или OLTP

**Переход:**
Вопрос на миллион: можно ли PostgreSQL использовать для OLAP? Спойлер: можно, но с костылями.

**PostgreSQL для OLTP — идеально:**
- ACID транзакции — как швейцарские часы
- Индексы на любой вкус: B-tree, Hash, GiST, GIN
- Надежность — данные не потеряются даже при падении сервера

**PostgreSQL для OLAP — так себе:**
- Строковое хранение — читаем все колонки, даже если нужна одна
- Медленные агрегации на больших данных
- Нет распределенности из коробки

**Решение — расширения:**
- Citus — шардирование, разбиваем данные по серверам
- TimescaleDB — для временных рядов (метрики, логи)
- pg_analytics — колоночное хранение прямо в PostgreSQL

**Ассоциация:** PostgreSQL — это швейцарский нож. Можно и гвоздь забить, и суп сварить, но для каждой задачи есть специализированный инструмент.


## Слайд 4.1: Расширения PostgreSQL

**Переход:**
Давайте детальнее про расширения, потому что это реально мощная штука.

**Citus — горизонтальное масштабирование:**
- Представьте: у вас 10 миллионов пользователей, и все в одной базе — тормозит
- Citus берет и разбивает таблицу по tenant_id на 10 серверов
- Запрос к пользователю 12345 идет только на нужный сервер
- Применение: SaaS приложения, где каждый клиент — отдельный tenant

**Ассоциация:** Citus — это как пиццу разрезать на куски. Каждый ест свой кусок, никто не мешает.

**TimescaleDB — временные ряды:**
- У вас IoT датчики шлют данные каждую секунду — миллионы записей в день
- TimescaleDB автоматически партиционирует по времени: январь в одной таблице, февраль в другой
- Запрос за последний час — читаем только одну партицию, а не весь год
- Применение: метрики серверов, логи, финансовые данные

**Ассоциация:** TimescaleDB — это как архив документов по годам. Нужен 2024 год — достаем только эту папку.

**pg_analytics — колоночное хранение:**
- Обычный PostgreSQL: строка = [id=1, name="Иван", age=25, city="Москва"]
- pg_analytics: колонка age = [25, 30, 22, 28, ...] — все возрасты подряд
- SELECT AVG(age) — читаем только колонку age, а не все данные
- Ускорение в 10-100 раз на аналитических запросах

**Ассоциация:** pg_analytics — это как в Excel выделить один столбец вместо всей таблицы.

---

## Слайд 5: Хранилища и витрины данных

**Переход:**
Окей, теперь про архитектуру данных. Представьте: у вас компания с 10 отделами, каждый хочет свои отчеты. Как это организовать?

**Data Warehouse (Хранилище данных):**
- Это как огромный склад Amazon — все данные компании в одном месте
- Собираем из PostgreSQL, CRM, ERP, логов, API
- Храним историю за годы — можно сравнить 2020 и 2024
- Зарубежные: Snowflake (дорого), Amazon Redshift, Google BigQuery
- Российские: Yandex DataLens + ClickHouse, Arenadata DB, Postgres Pro Enterprise

**Ассоциация:** Data Warehouse — это Ленинская библиотека. Все книги мира, но найти нужную — квест.

**Data Mart (Витрина данных):**
- Это подмножество хранилища для конкретного отдела
- Отдел продаж: только данные о клиентах, заказах, выручке
- Маркетинг: только метрики кампаний, конверсии, ROI
- Быстрый доступ, потому что данных меньше

**Ассоциация:** Data Mart — это как отдел в магазине. Хочешь молоко — идешь в молочный отдел, а не бегаешь по всему гипермаркету.

**ETL процесс:**
- Extract — вытаскиваем данные из PostgreSQL, API, файлов
- Transform — чистим, нормализуем, агрегируем
- Load — загружаем в ClickHouse или витрину

**Инструменты:**
- Apache Airflow — оркестрация, расписание, мониторинг
- Apache NiFi — потоковая обработка
- Loginom — российский ETL
- Talend — open source

**Ассоциация:** ETL — это как готовка борща. Достал продукты (Extract), почистил и порезал (Transform), сварил (Load).

---

## Слайд 5.1: Как устроен ClickHouse

**Переход:**
Все говорят "ClickHouse быстрый", но почему? Давайте разберем под капотом.

**Что такое ClickHouse?**
- Колоночная СУБД от Яндекса, open source
- Обрабатывает миллиарды строк за секунды
- Используется в Яндекс.Метрике — там петабайты данных

**Колоночное vs Строковое хранение:**
- PostgreSQL (строковое): [id=1, name="Иван", age=25] [id=2, name="Петр", age=30]
- ClickHouse (колоночное): [id: 1,2,3...] [name: "Иван","Петр"...] [age: 25,30...]
- Запрос SELECT AVG(age) — PostgreSQL читает ВСЕ данные, ClickHouse только колонку age

**Ассоциация:** Строковое хранение — это книга, читаешь страницу за страницей. Колоночное — это словарь, сразу открываешь нужную букву.

**Ключевые особенности:**
- Сжатие данных — в 10-100 раз меньше места (LZ4, ZSTD)
- Векторизация — обрабатывает данные блоками, а не по одной строке
- Распределенность — шардирование и репликация из коробки
- Движки таблиц: MergeTree (основной), ReplicatedMergeTree (с репликацией), Distributed (распределенный)

**Когда использовать ClickHouse:**
- ✅ Аналитические запросы (GROUP BY, SUM, AVG)
- ✅ Логи и метрики (миллионы записей в секунду)
- ✅ Real-time дашборды
- ❌ OLTP (много UPDATE/DELETE — ClickHouse не любит)
- ❌ Транзакции — их тут нет

**Ассоциация:** ClickHouse — это Формула-1. Быстро, но только на гоночной трассе. На бездорожье (OLTP) не поедет.


## Слайд 6: Data Mart и ETL — детальный разбор

**Переход:**
Теперь копнем глубже: когда реально нужны витрины данных и как их строить?

**Когда нужны Data Mart?**
- Проблема: хранилище на 10 терабайт, запрос "выручка за месяц" идет 5 минут
- Решение: создаем витрину для отдела продаж — только нужные данные, запрос за 2 секунды

**Примеры использования:**
- Отдел продаж: клиенты, заказы, выручка за последний год (не за 10 лет!)
- Маркетинг: метрики кампаний, конверсии, ROI — без данных о складе
- Финансы: транзакции, балансы, отчетность — без логов приложений
- HR: сотрудники, зарплаты, KPI — без данных о клиентах

**Ассоциация:** Data Mart — это как личный холодильник в офисе. Не бегаешь на склад за каждым йогуртом.

**ETL процесс — зачем и как?**
- Данные разбросаны: CRM (клиенты), ERP (заказы), логи (клики), Excel (прайсы)
- Форматы разные: даты в одном формате, в другом — по-другому
- Дубликаты и ошибки: один клиент записан 3 раза с разными email
- Нужна агрегация: не храним каждый клик, а считаем сумму за день

**Ассоциация:** ETL — это как уборка квартиры перед приходом гостей. Собрал мусор, помыл, расставил по местам.

---

## Слайд 6.1: ETL — этапы процесса

**Переход:**
Разберем ETL по шагам, как в рецепте.

**1. Extract (Извлечение):**
- Из PostgreSQL — заказы, клиенты (SELECT * FROM orders)
- Из API — платежи от банка, статусы доставки
- Из файлов — CSV с прайсами от поставщиков
- Из логов — JSON с кликами пользователей

**Ассоциация:** Extract — это как собрать ингредиенты для борща. Картошка из погреба, мясо из холодильника, свекла с рынка.

**2. Transform (Преобразование):**
- Очистка: удалили дубликаты, исправили опечатки в email
- Нормализация: все даты в формат YYYY-MM-DD, все цены в рубли
- Обогащение: добавили регион по городу (Москва → Центральный ФО)
- Агрегация: посчитали сумму заказов по дням

**Ассоциация:** Transform — это готовка. Почистил картошку, порезал, обжарил.

**3. Load (Загрузка):**
- В ClickHouse — для аналитики
- В витрины данных — для отделов
- Инкрементальная загрузка — только новые данные (быстро)
- Полная загрузка — все данные заново (медленно, но надежно)

**Ассоциация:** Load — это подача на стол. Разлил борщ по тарелкам.

**Пример: Интернет-магазин**
- Extract: заказы из PostgreSQL, клики из логов, платежи из банка
- Transform: объединили по ID клиента, посчитали LTV (сколько клиент принес денег), сегментировали (VIP, обычные, новички)
- Load: в витрину маркетинга для анализа эффективности рекламы

**Ассоциация:** ETL для интернет-магазина — это как сборка пазла. Кусочки из разных коробок, но в итоге получается картина.

---

## Слайд 7: DWH — логическая структура

**Переход:**
Теперь про архитектуру хранилища. Это не просто "свалили все данные в одну базу".

**1. Staging Area (Промежуточная зона):**
- Сырые данные из источников, без обработки
- Зачем: буфер для ETL, если что-то пошло не так — можно перезапустить
- Пример: загрузили данные из PostgreSQL ночью, храним до утра

**Ассоциация:** Staging Area — это как черновик курсовой. Накидал мысли, потом причешешь.

**2. ODS (Operational Data Store):**
- Оперативное хранилище для текущих данных
- Данные в реальном времени, интеграция из разных OLTP систем
- Пример: объединенные данные о клиентах из CRM и ERP

**Ассоциация:** ODS — это как сводка новостей. Что происходит прямо сейчас.

**3. Core DWH (Ядро хранилища):**
- Исторические данные за все время
- Анализ трендов: сравнить 2020 и 2024
- Схемы: Star Schema (звезда), Snowflake Schema (снежинка)
- Пример: все заказы за 5 лет с историей изменений

**Ассоциация:** Core DWH — это как архив газет. Можно посмотреть, что было 10 лет назад.

**4. Data Marts (Витрины данных):**
- Тематические подмножества для отделов
- Быстрый доступ к агрегированным данным
- Пример: витрина продаж с выручкой по регионам

**Ассоциация:** Data Marts — это как разделы в газете. Спорт, политика, экономика — каждый читает свое.


## Слайд 7.1: Схемы данных в DWH

**Переход:**
Теперь про схемы данных. Это как планировка квартиры — можно студию, можно трешку.

**Star Schema (Звезда):**
- Центр — таблица фактов (продажи)
- Лучи — таблицы измерений (товары, клиенты, время, регион)
- Преимущества: простота, быстрые запросы (мало JOIN'ов)
- Недостатки: дублирование данных

**Ассоциация:** Star Schema — это как пицца. В центре начинка (факты), по краям корочка (измерения).

**Snowflake Schema (Снежинка):**
- Нормализованные таблицы измерений
- Товары → Категории → Подкатегории (цепочка)
- Преимущества: меньше дублирования, экономия места
- Недостатки: больше JOIN'ов, медленнее запросы

**Ассоциация:** Snowflake Schema — это как матрешка. Одна в другой, красиво, но достать сложно.

**Galaxy Schema (Галактика):**
- Несколько таблиц фактов с общими измерениями
- Факты_Продаж + Факты_Возвратов → общие Товары, Клиенты
- Применение: сложные бизнес-процессы

**Ассоциация:** Galaxy Schema — это как солнечная система. Несколько планет (фактов) вокруг солнца (измерений).

---

## Слайд 8: DWH — физическая архитектура

**Переход:**
Окей, логику поняли. Теперь на чем это все крутится физически?

**1. Источники данных:**
- OLTP базы: PostgreSQL, MySQL — транзакционные данные
- CRM/ERP: 1C, SAP, Salesforce — бизнес-данные
- Логи: JSON, CSV — события приложений
- API: внешние сервисы (платежи, доставка)
- Файлы: S3, HDFS — большие объемы

**Ассоциация:** Источники данных — это как ингредиенты в холодильнике. Разные полки, разные упаковки.

**2. ETL сервер:**
- Apache Airflow — оркестрация, DAG (граф задач), расписание
- Apache NiFi — потоковая обработка, drag-and-drop интерфейс
- Loginom — российский ETL, визуальный редактор
- Talend, Pentaho — open source решения

**Ассоциация:** ETL сервер — это как кухонный комбайн. Загрузил продукты, нажал кнопку, получил результат.

**3. Хранилище (Storage):**
- OLAP СУБД: ClickHouse, Greenplum, Vertica
- Колоночные форматы: Parquet, ORC — для Hadoop
- Распределенное: HDFS, S3 — масштабируемое
- Кэш: Redis, Memcached — ускорение запросов

**Ассоциация:** Хранилище — это как склад Amazon. Огромный, распределенный, с роботами.

**4. Слой доступа:**
- BI: Tableau, Power BI, Yandex DataLens — дашборды
- SQL: DBeaver, DataGrip — для аналитиков
- API: REST, GraphQL — для приложений

**Ассоциация:** Слой доступа — это как витрина магазина. Красиво, понятно, удобно.

**Диаграмма:**
```
[PostgreSQL] ──┐
[MySQL]      ──┤
[API]        ──┼──> [ETL Server] ──> [ClickHouse] ──> [Data Marts] ──> [BI Tools]
[Logs]       ──┤      (Airflow)         (DWH)          (Витрины)      (DataLens)
[Files]      ──┘
```

---

## Слайд 8.1: BI инструменты и Power BI

**Переход:**
Данные собрали, обработали. Теперь надо показать красиво — тут на сцену выходит BI.

**Что такое BI (Business Intelligence)?**
- Инструменты для визуализации и анализа данных
- Дашборды, отчеты, графики, KPI
- Пользователи: аналитики, менеджеры, руководители

**Ассоциация:** BI — это как Instagram для данных. Красивые картинки вместо цифр.

**Популярные BI инструменты:**
- Power BI (Microsoft) — интеграция с Excel, Azure, Windows
- Tableau — мощная визуализация, дорого
- Yandex DataLens — российское решение, бесплатно для малого бизнеса
- Apache Superset — open source, для гиков
- Metabase — простой и бесплатный, для стартапов

**Power BI — особенности:**
- Интеграция: Excel, SQL Server, Azure, SharePoint — все Microsoft
- DAX — язык формул для расчетов (как Excel, но мощнее)
- Визуализация: графики, карты, таблицы, фильтры
- Power Query — ETL прямо в Power BI (можно без Airflow)
- Публикация: Power BI Service (облако), доступ по ссылке

**Пример использования:**
1. Подключились к ClickHouse или PostgreSQL
2. Создали дашборд с графиками продаж
3. Добавили фильтры (дата, регион, категория)
4. Опубликовали в Power BI Service
5. Отдел продаж открывает по ссылке и видит актуальные данные

**Ассоциация:** Power BI — это как конструктор Lego. Собираешь дашборд из блоков (графиков, таблиц, фильтров).


## Слайд 9: SQL против ORM

**Переход:**
Окей, теперь переходим к коду. Вопрос на миллион: писать SQL руками или использовать ORM?

**Чистый SQL — преимущества:**
- Полный контроль над запросами — видишь, что происходит
- Максимальная производительность — никаких прослоек
- Специфичные функции СУБД — можешь использовать все фишки PostgreSQL

**Ассоциация:** Чистый SQL — это как водить машину на механике. Полный контроль, но надо уметь.

**Чистый SQL — недостатки:**
- Больше кода — каждый запрос руками
- Риск SQL-инъекций — если забыл параметризацию
- Сложность поддержки — изменил структуру таблицы, переписывай все запросы

**ORM — преимущества:**
- Работа с объектами вместо SQL — student.name вместо SELECT name FROM students
- Защита от SQL-инъекций — ORM сам параметризует
- Быстрая разработка — меньше кода, больше фич

**Ассоциация:** ORM — это как автомат в машине. Проще, но меньше контроля.

**ORM — недостатки:**
- Overhead производительности — прослойка между кодом и БД
- Неэффективные сложные запросы — ORM может сгенерировать плохой SQL
- Абстракция скрывает детали — не понимаешь, что происходит под капотом

**Когда использовать SQL:**
- Сложные аналитические запросы с GROUP BY, JOIN, подзапросами
- Оптимизация производительности — каждая миллисекунда важна
- Специфичные функции БД — window functions, CTE, JSON операции

**Когда использовать ORM:**
- Типовые CRUD операции — создать, прочитать, обновить, удалить
- Быстрая разработка — MVP, прототипы
- Команда без SQL экспертов — джуниоры справятся

**Рекомендация:**
Используйте ORM для типовых операций, SQL для сложных запросов. Это не религия, это инструменты.

**Ассоциация:** SQL vs ORM — это как молоток и шуруповерт. Для гвоздя — молоток, для шурупа — шуруповерт.

---

## Слайд 10: PL/pgSQL

**Переход:**
Теперь про PL/pgSQL — это как JavaScript для PostgreSQL. Логика прямо в базе.

**Что такое PL/pgSQL?**
- Процедурный язык для PostgreSQL
- Функции, процедуры, триггеры
- Логика на уровне БД, а не в приложении

**Пример функции:**
```sql
CREATE OR REPLACE FUNCTION get_student_count()
RETURNS INTEGER AS $$
DECLARE student_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO student_count FROM students;
    RETURN student_count;
END;
$$ LANGUAGE plpgsql;
```

**Зачем это нужно?**
- Производительность — логика выполняется в БД, без сетевых задержек
- Переиспользование — одна функция для всех приложений
- Безопасность — можно дать доступ к функции, но не к таблице

**Ассоциация:** PL/pgSQL — это как макросы в Excel. Автоматизируешь рутину.

**Когда использовать:**
- Сложные вычисления на больших данных
- Бизнес-логика, которая не меняется часто
- Триггеры для автоматических действий

**Когда НЕ использовать:**
- Бизнес-логика, которая часто меняется — лучше в приложении
- Сложная логика — PL/pgSQL не Python, отладка сложнее

---

## Слайд 11: PL/pgSQL триггеры

**Переход:**
Триггеры — это как автоматические действия. Изменил запись — триггер сработал.

**Пример триггера:**
```sql
CREATE OR REPLACE FUNCTION update_modified_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER student_update_trigger
BEFORE UPDATE ON students
FOR EACH ROW
EXECUTE FUNCTION update_modified_timestamp();
```

**Что происходит:**
- Обновили студента — триггер автоматически ставит updated_at = NOW()
- Не надо помнить в коде — база сама следит

**Зачем триггеры:**
- Автоматизация — не забудешь обновить timestamp
- Аудит — логировать все изменения
- Валидация — проверить данные перед вставкой

**Ассоциация:** Триггеры — это как умный дом. Открыл дверь — свет включился автоматически.

**Осторожно:**
- Триггеры скрыты — можно забыть, что они есть
- Производительность — триггер на каждую строку может тормозить
- Отладка — сложнее понять, почему данные изменились


## Слайд 12: Современные ORM

**Переход:**
Теперь про ORM в разных языках. Каждый язык — свой подход.

**Python — SQLAlchemy, Django ORM:**
- SQLAlchemy — гибкий, мощный, поддержка сырого SQL
- Django ORM — простой, быстрый старт, часть фреймворка
- Особенности: миграции, relationships, query builder

**JavaScript — Prisma, TypeORM:**
- Prisma — типобезопасность, автогенерация типов TypeScript
- TypeORM — декораторы, Active Record / Data Mapper
- Особенности: async/await, поддержка MongoDB

**Java — Hibernate:**
- Стандарт JPA (Java Persistence API)
- Кэширование первого и второго уровня
- Особенности: lazy loading, dirty checking

**C# — Entity Framework:**
- Интеграция с .NET, LINQ запросы
- Code First / Database First подходы
- Особенности: миграции, навигационные свойства

**Ruby — ActiveRecord:**
- Convention over configuration — минимум настроек
- Часть Rails фреймворка
- Особенности: callbacks, validations, scopes

**Go — GORM:**
- Простой API, автоматические миграции
- Поддержка hooks, preloading
- Особенности: легковесный, быстрый

**PHP — Eloquent:**
- Часть Laravel фреймворка
- Выразительный синтаксис, relationships
- Особенности: eager loading, query scopes

**Ассоциация:** ORM в разных языках — это как кофемашины. Принцип один, но кнопки разные.

---

## Слайд 13: SQLAlchemy vs Django ORM

**Переход:**
В Python два главных ORM. Какой выбрать?

**SQLAlchemy:**
- Тип: независимая библиотека, можно использовать с любым фреймворком
- Подход: Data Mapper pattern — модели отделены от БД
- Гибкость: высокая, поддержка сырого SQL, сложных запросов
- Сложность: выше, больше контроля, больше кода
- Использование: любые Python-проекты (FastAPI, Flask, standalone)

**Django ORM:**
- Тип: часть Django framework
- Подход: Active Record pattern — модель = строка в БД
- Гибкость: средняя, ориентирован на простоту
- Сложность: ниже, быстрый старт, меньше кода
- Использование: Django-проекты

**Плюсы SQLAlchemy:**
- Полный контроль над запросами
- Мощь для сложных сценариев
- Async поддержка (SQLAlchemy 2.0)

**Плюсы Django ORM:**
- Простота и скорость разработки
- Интеграция с Django (admin, migrations, forms)
- Меньше boilerplate кода

**Рекомендация:**
- SQLAlchemy — для сложных проектов, микросервисов, FastAPI
- Django ORM — для быстрой разработки, монолитов, Django

**Ассоциация:** SQLAlchemy — это профессиональная камера (много настроек). Django ORM — это iPhone (просто и быстро).

---

## Слайд 14: Определение моделей

**Переход:**
Окей, теперь код. Как определить модель студента?

**SQLAlchemy:**
```python
class Student(Base):
    __tablename__ = 'students'
    id = Column(Integer, primary_key=True)
    name = Column(String(100))
```

**Django ORM:**
```python
class Student(models.Model):
    name = models.CharField(max_length=100)
```

**Что видим:**
- SQLAlchemy — явно указываем таблицу, типы колонок
- Django ORM — короче, id создается автоматически

**Ассоциация:** SQLAlchemy — это как собрать компьютер из деталей. Django ORM — это купить готовый Mac.

---

## Слайд 15: Создание записей

**Переход:**
Создаем студента Ивана.

**SQLAlchemy:**
```python
student = Student(name="Иван")
session.add(student)
session.commit()
```

**Django ORM:**
```python
student = Student.objects.create(name="Иван")
```

**Что видим:**
- SQLAlchemy — явно добавляем в сессию, явно коммитим
- Django ORM — одна строка, автоматический commit

**Ассоциация:** SQLAlchemy — это механическая коробка (контроль). Django ORM — это автомат (удобство).

---

## Слайд 16: Чтение данных

**Переход:**
Читаем студентов из базы.

**SQLAlchemy:**
```python
students = session.query(Student).all()
student = session.query(Student).filter(
    Student.email == "ivan@example.com"
).first()
```

**Django ORM:**
```python
students = Student.objects.all()
student = Student.objects.filter(
    email="ivan@example.com"
).first()
```

**Что видим:**
- Синтаксис похож, но SQLAlchemy использует query(), Django — objects
- SQLAlchemy — Student.email (атрибут класса), Django — email (строка)

**Ассоциация:** Оба — это как поиск в Google. Ввел запрос, получил результаты.


## Слайд 17: Обновление и удаление

**Переход:**
Меняем имя студента и удаляем.

**SQLAlchemy:**
```python
student = session.query(Student).filter_by(id=1).first()
student.name = "Петр"
session.commit()
```

**Django ORM:**
```python
Student.objects.filter(id=1).update(name="Петр")
Student.objects.filter(id=1).delete()
```

**Что видим:**
- SQLAlchemy — загружаем объект, меняем, коммитим
- Django ORM — обновляем напрямую в БД (быстрее)

**Ассоциация:** SQLAlchemy — это редактирование документа Word (открыл, изменил, сохранил). Django ORM — это sed в Linux (изменил прямо в файле).

---

## Слайд 18: Связи

**Переход:**
Студент учится на курсе. Как связать?

**SQLAlchemy:**
```python
class Student(Base):
    course_id = Column(Integer, ForeignKey('courses.id'))
    course = relationship("Course")
```

**Django ORM:**
```python
class Student(models.Model):
    course = models.ForeignKey(Course, on_delete=models.CASCADE)
```

**Что видим:**
- SQLAlchemy — явно указываем ForeignKey и relationship
- Django ORM — ForeignKey автоматически создает связь

**on_delete=models.CASCADE:**
- Удалили курс — автоматически удалятся все студенты
- Другие варианты: SET_NULL, PROTECT, SET_DEFAULT

**Ассоциация:** Связи — это как контакты в телефоне. Удалил человека — удалились все чаты с ним (CASCADE).

---

## Слайд 19: Агрегация

**Переход:**
Считаем количество студентов.

**SQLAlchemy:**
```python
from sqlalchemy import func
count = session.query(func.count(Student.id)).scalar()
```

**Django ORM:**
```python
from django.db.models import Count
count = Student.objects.count()
```

**Что видим:**
- SQLAlchemy — используем func.count()
- Django ORM — метод count() из коробки

**Ассоциация:** Агрегация — это как калькулятор. Ввел данные, получил результат.

---

## Слайд 20: JOIN и Eager Loading

**Переход:**
Теперь важная тема — проблема N+1 и как ее решить.

**Проблема N+1:**
- Загрузили 100 студентов — 1 запрос
- Для каждого студента загружаем курс — 100 запросов
- Итого: 101 запрос вместо 1

**Ассоциация:** Проблема N+1 — это как ходить в магазин за каждым продуктом отдельно. Нужны хлеб, молоко, яйца — сходил 3 раза вместо одного.

**Решение: Eager Loading**

**SQLAlchemy — joinedload:**
```python
from sqlalchemy.orm import joinedload
students = session.query(Student).options(
    joinedload(Student.course)  # 1 запрос с JOIN
).all()
```

**Django ORM — select_related:**
```python
# select_related - для ForeignKey, OneToOne
students = Student.objects.select_related('course')

# prefetch_related - для ManyToMany
courses = Course.objects.prefetch_related('students')
```

**Что происходит:**
- Вместо 101 запроса — 1-2 запроса
- Ускорение в 50-100 раз
- Меньше нагрузка на БД

**Ассоциация:** Eager Loading — это как оптовая закупка. Один раз съездил, купил все.

**Когда использовать:**
- Всегда, когда обращаетесь к связанным объектам в цикле
- Проверяйте через Django Debug Toolbar или логи SQL

---

## Слайд 21: Сложные условия (Q объекты)

**Переход:**
Нужно найти студента по имени ИЛИ по email. Как?

**Зачем нужны Q объекты:**
- Для сложных условий с OR, AND, NOT
- Обычный filter() работает только с AND

**Django Q:**
```python
from django.db.models import Q
students = Student.objects.filter(
    Q(name__icontains='Ivan') | Q(email__icontains='ivan')
)  # Найти по имени ИЛИ email
```

**SQLAlchemy:**
```python
from sqlalchemy import or_, select
stmt = select(Student).where(
    or_(
        Student.name.ilike('%Ivan%'), 
        Student.email.ilike('%ivan%')
    )
)
```

**SQL эквивалент:**
```sql
SELECT * FROM students 
WHERE name ILIKE '%Ivan%' OR email ILIKE '%ivan%'
```

**Ассоциация:** Q объекты — это как логические операторы в программировании. if (a || b) — то же самое.

**Примеры использования:**
- Поиск по нескольким полям
- Сложные фильтры в админке
- Динамические запросы (пользователь выбирает условия)


## Слайд 22: Операции с полями (F объекты)

**Переход:**
Нужно увеличить баллы всем студентам на 10. Как сделать эффективно?

**Зачем нужны F объекты:**
- Для операций с полями на уровне БД (без загрузки в Python)
- Атомарность — избежание race conditions
- Производительность — операции в БД, не в Python

**Плохой способ (без F):**
```python
students = Student.objects.filter(status='active')
for student in students:
    student.grade += 10
    student.save()
# 1000 студентов = 1000 запросов UPDATE
```

**Хороший способ (с F):**

**Django F:**
```python
from django.db.models import F
Student.objects.filter(status='active').update(
    grade=F('grade') + 10  # grade = grade + 10 в SQL
)
# 1 запрос UPDATE для всех студентов
```

**SQLAlchemy:**
```python
from sqlalchemy import update
stmt = update(Student).where(
    Student.status == 'active'
).values(grade=Student.grade + 10)
session.execute(stmt)
session.commit()
```

**SQL эквивалент:**
```sql
UPDATE students 
SET grade = grade + 10 
WHERE status = 'active'
```

**Что происходит:**
- Без F: загрузить 1000 студентов в Python → изменить → сохранить (1000 запросов)
- С F: 1 запрос UPDATE в БД (ускорение в 1000 раз)

**Ассоциация:** F объекты — это как массовая рассылка email. Отправил один раз всем, а не каждому по отдельности.

**Примеры использования:**
- Увеличить счетчик просмотров
- Обновить цены на процент
- Перенести данные из одного поля в другое

---

## Слайд 23: Raw SQL и транзакции

**Переход:**
Иногда ORM не справляется. Тогда пишем SQL руками.

**Raw SQL — когда нужен:**
- Сложные запросы — ORM не может сгенерировать
- Оптимизация — нужен контроль над SQL
- Специфичные функции — уникальные для СУБД (window functions, CTE)

**SQLAlchemy:**
```python
from sqlalchemy import text
result = session.execute(
    text("SELECT * FROM students WHERE id = :id"),
    {"id": 1}  # Защита от SQL-инъекций
).fetchall()
```

**Django ORM:**
```python
from django.db import connection
with connection.cursor() as cursor:
    cursor.execute(
        "SELECT * FROM students WHERE id = %s",
        [1]
    )
    result = cursor.fetchall()
```

**Важно:**
- Всегда используйте параметры (:id, %s) вместо f-string
- f"SELECT * FROM students WHERE id = {user_input}" — это SQL-инъекция!

**Ассоциация:** Raw SQL — это как ручная настройка двигателя. Опасно, но мощно.

**Транзакции — зачем:**
- Атомарность — все или ничего
- Пример: перевод денег — списать И зачислить
- Rollback — отмена при ошибке

**SQLAlchemy:**
```python
try:
    session.add(student)
    session.add(course)
    session.commit()  # Сохранить
except:
    session.rollback()  # Отменить
finally:
    session.close()
```

**Django ORM:**
```python
from django.db import transaction
with transaction.atomic():
    student.save()
    course.save()
    # Автоматический rollback при ошибке
```

**Ассоциация:** Транзакции — это как Ctrl+Z в редакторе. Ошибся — откатил.

---

## Слайд 24: SQLAlchemy 1.x vs 2.x

**Переход:**
SQLAlchemy 2.0 вышел в 2023 году. Что изменилось?

**Ключевые отличия:**

**Query API:**
- 1.x: session.query(Student) — старый ORM-стиль
- 2.x: session.execute(select(Student)) — SQL Expression стиль

**Типизация:**
- 1.x: слабая типизация, IDE не помогает
- 2.x: сильная типизация, type hints, автодополнение

**Async:**
- 1.x: нет поддержки async/await
- 2.x: полная поддержка async (AsyncSession, async_sessionmaker)

**Производительность:**
- 2.x: на 20-30% быстрее за счет оптимизаций

**Ассоциация:** SQLAlchemy 1.x — это Python 2. SQLAlchemy 2.x — это Python 3. Переходить надо, но не спешить.

---

## Слайд 24.1: Почему переходить на 2.x?

**Переход:**
Окей, убедил. Почему стоит переходить?

**Причины:**
1. Современный синтаксис и лучшая типизация для IDE
2. Поддержка async/await для высоконагруженных систем
3. Более предсказуемое поведение и меньше подводных камней
4. Активная поддержка и обновления (1.x — legacy)

**Важно:**
- SQLAlchemy 1.4 поддерживает оба стиля (переходная версия)
- Можно мигрировать постепенно

**Ассоциация:** Переход на 2.x — это как переезд в новую квартиру. Сначала хлопотно, но потом комфортнее.

---

## Слайд 25: SQLAlchemy синтаксис

**Переход:**
Давайте сравним синтаксис всех версий.

**SQLAlchemy 1.x (legacy):**
```python
students = session.query(Student).all()  # Простой, но устаревший
```

**SQLAlchemy 2.x (синхронный):**
```python
from sqlalchemy import select

stmt = select(Student)                    # Создаем SQL запрос
result = session.execute(stmt)            # Выполняем
students = result.scalars().all()         # Получаем объекты
```

**SQLAlchemy 2.x (асинхронный):**
```python
from sqlalchemy.ext.asyncio import AsyncSession

async with AsyncSession(engine) as session:
    stmt = select(Student)                # Тот же синтаксис
    result = await session.execute(stmt)  # Асинхронное выполнение
    students = result.scalars().all()     # Список объектов
```

**Что видим:**
- 1.x — короче, но устарел
- 2.x синхронный — явный, понятный
- 2.x асинхронный — для высоконагруженных систем (FastAPI, aiohttp)

**Ассоциация:** 1.x — это велосипед. 2.x синхронный — это машина. 2.x асинхронный — это самолет.

---

## Заключение

**Переход:**
Окей, подводим итоги.

**Выбор подхода:**
- SQL — максимальная производительность, полный контроль
- PL/pgSQL — логика на уровне БД, триггеры, функции
- ORM — быстрая разработка, безопасность, удобство

**Рекомендации:**
- ✅ ORM для типовых операций (CRUD)
- ⚡ SQL для сложных запросов (аналитика, отчеты)
- 📊 Профилируйте и оптимизируйте (Django Debug Toolbar, EXPLAIN)

**Главное:**
- Не религия, а инструменты
- Выбирайте под задачу
- Учитесь и тому, и другому

**Ассоциация:** Разработка — это как готовка. Можно микроволновкой (ORM), можно на плите (SQL). Главное — вкусно.

**Финал:**
Вопросы? Или все понятно и можно идти писать код?
