# Билеты для экзамена

## Билет 1: FastAPI + SQLAlchemy - API для задач

### Теоретическая часть:

1. Что такое FastAPI и каковы его основные преимущества?
2. В чем разница между синхронным и асинхронным SQLAlchemy?
3. Как работает dependency injection в FastAPI?

### Практическая часть:

**Тестовые данные:**

```sql
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200),
    description TEXT,
    status VARCHAR(20),
    user_id INTEGER,
    created_at TIMESTAMP DEFAULT NOW()
);

INSERT INTO tasks (title, description, status, user_id) VALUES
('Изучить FastAPI', 'Пройти документацию', 'done', 1),
('Настроить БД', 'PostgreSQL + SQLAlchemy', 'in_progress', 1),
('Написать тесты', 'Pytest для API', 'todo', 2),
('Деплой', 'Docker + CI/CD', 'todo', 2);
```

**Задание:**
Создайте REST API с эндпоинтами:

- GET /tasks - список задач с фильтром по статусу
- POST /tasks - создание задачи
- PUT /tasks/{id} - обновление статуса
- DELETE /tasks/{id} - удаление

**Требования:** async SQLAlchemy, Pydantic валидация, обработка ошибок

---

## Билет 2: PostgreSQL - Функция расчета скидки

### Теоретическая часть:

1. Что такое хранимые функции (stored functions) в PostgreSQL?
2. Какие типы данных можно возвращать из функции PostgreSQL?
3. В чем разница между функциями и процедурами в PostgreSQL?

### Практическая часть:

**Тестовые данные:**

```sql
CREATE TABLE user_orders (
    user_id INTEGER,
    order_amount DECIMAL(10,2),
    order_date DATE
);

INSERT INTO user_orders VALUES
(1, 5000, '2025-01-01'),
(1, 8000, '2025-01-05'),
(1, 12000, '2025-01-10'),
(2, 3000, '2025-01-02'),
(2, 4000, '2025-01-08');
```

**Задание:**
Создайте функцию `get_discount(user_id INT, amount DECIMAL)`:

- Если сумма покупок > 20000 → скидка 10%
- Если сумма покупок > 10000 → скидка 5%
- Иначе → скидка 0%

Функция должна вернуть итоговую сумму со скидкой.

---

## Билет 3: Redis - Счетчик просмотров и кэш

### Теоретическая часть:

1. Что такое Redis и для чего он используется?
2. В чем разница между обычными ключами (strings) и отсортированными множествами (ZSET) в Redis?
3. Что такое TTL (Time To Live) в Redis и как он работает?

### Практическая часть:

**Задание:**
Реализуйте в FastAPI:

1. Эндпоинт GET /articles/{id} - возвращает статью
2. Кэширование статьи в Redis (TTL 5 минут)
3. Счетчик просмотров (INCR) для каждой статьи
4. Эндпоинт GET /articles/popular - топ-5 по просмотрам (ZSET)

**Тестовые данные:**

```python
articles = {
    1: {"title": "Python tips", "content": "..."},
    2: {"title": "FastAPI guide", "content": "..."},
    3: {"title": "Redis cache", "content": "..."}
}
```

---

## Билет 4: Docker Compose - Полный стек

### Теоретическая часть:

1. Что такое Docker Compose и для чего он используется?
2. В чем разница между volumes и bind mounts в Docker Compose?
3. Как работает depends_on и чем он отличается от healthcheck?

### Практическая часть:

**Задание:**
Создайте docker-compose.yml:

1. FastAPI приложение (порт 8000)
2. PostgreSQL (порт 5432)
3. Redis (порт 6379)
4. Nginx как reverse proxy (порт 80)

**Требования:**

- Volumes для данных БД
- Healthcheck для всех сервисов
- Environment variables через .env
- Зависимости между сервисами (depends_on)

---

## Билет 5: SQLAlchemy - Связи один-ко-многим

### Теоретическая часть:

1. Что такое relationship в SQLAlchemy?
2. Разница между lazy='select' и lazy='joined'
3. Что такое back_populates?

### Практическая часть:

**Тестовые данные:**

```sql
CREATE TABLE authors (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100)
);

CREATE TABLE books (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200),
    author_id INTEGER REFERENCES authors(id),
    published_date DATE
);

INSERT INTO authors (name, email) VALUES
('Пушкин', 'pushkin@mail.ru'),
('Толстой', 'tolstoy@mail.ru');

INSERT INTO books (title, author_id, published_date) VALUES
('Евгений Онегин', 1, '1833-01-01'),
('Капитанская дочка', 1, '1836-01-01'),
('Война и мир', 2, '1869-01-01');
```

**Задание:**
Создайте модели SQLAlchemy:

1. Author с relationship к Book
2. Book с relationship к Author
3. Эндпоинт GET /authors/{id}/books - список книг автора
4. Эндпоинт POST /books - создание книги с привязкой к автору

**Требования:** использовать relationship, back_populates, async SQLAlchemy

---

## Билет 6: SQLAlchemy - Агрегация и группировка

### Теоретическая часть:

1. Как использовать func в SQLAlchemy?
2. Что такое group_by и having?
3. Разница между filter и filter_by

### Практическая часть:

**Тестовые данные:**

```sql
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    product_name VARCHAR(100),
    quantity INTEGER,
    price DECIMAL(10,2),
    order_date DATE
);

INSERT INTO orders (product_name, quantity, price, order_date) VALUES
('Товар A', 5, 1000, '2025-01-10'),
('Товар B', 3, 1500, '2025-01-10'),
('Товар A', 2, 1000, '2025-01-11'),
('Товар C', 10, 500, '2025-01-11'),
('Товар B', 1, 1500, '2025-01-12');
```

**Задание:**
Используя SQLAlchemy создайте эндпоинты:

1. GET /orders/stats - общая сумма и количество заказов
2. GET /orders/by-product - группировка по товарам (название, количество, сумма)
3. GET /orders/by-date - группировка по дням
4. GET /orders/top-products?limit=3 - топ товаров по выручке

**Требования:** использовать func.sum(), func.count(), group_by(), order_by()

---

## Билет 7: PostgreSQL - Представления (Views)

### Теоретическая часть:

1. Что такое представление (view) в PostgreSQL?
2. Разница между обычным и материализованным представлением
3. Когда использовать представления?

### Практическая часть:

**Тестовые данные:**

```sql
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    department VARCHAR(50),
    salary DECIMAL(10,2),
    hire_date DATE
);

CREATE TABLE projects (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    employee_id INTEGER REFERENCES employees(id),
    budget DECIMAL(10,2),
    status VARCHAR(20)
);

INSERT INTO employees (name, department, salary, hire_date) VALUES
('Иванов', 'IT', 100000, '2020-01-15'),
('Петров', 'IT', 120000, '2019-03-20'),
('Сидорова', 'HR', 80000, '2021-06-10');

INSERT INTO projects (name, employee_id, budget, status) VALUES
('Проект A', 1, 500000, 'active'),
('Проект B', 1, 300000, 'completed'),
('Проект C', 2, 800000, 'active');
```

**Задание:**

1. Создайте представление employee_stats с полями: name, department, salary, projects_count, total_budget
2. Создайте материализованное представление department_summary: department, avg_salary, employees_count, total_projects
3. Напишите SQL для обновления материализованного представления
4. Создайте эндпоинт FastAPI GET /stats/employees - данные из представления

**Требования:** использовать CREATE VIEW, CREATE MATERIALIZED VIEW, REFRESH MATERIALIZED VIEW

---

## Билет 8: Pydantic - Валидация и сериализация в FastAPI

### Теоретическая часть:

1. Что такое Pydantic и для чего он нужен?
2. Разница между BaseModel и dataclass
3. Что такое Field и для чего используются валидаторы?

### Практическая часть:

**Тестовые данные:**

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE,
    email VARCHAR(100) UNIQUE,
    age INTEGER,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW()
);

INSERT INTO users (username, email, age) VALUES
('ivan123', 'ivan@mail.ru', 25),
('maria_p', 'maria@mail.ru', 30),
('alex_dev', 'alex@mail.ru', 22);
```

**Задание:**
Создайте Pydantic модели и эндпоинты:

1. UserCreate - валидация при создании:
   - username: 3-50 символов, только буквы и цифры
   - email: валидный email
   - age: от 18 до 100
   - password: минимум 8 символов, обязательно
2. UserResponse - для ответа (без password)
3. UserUpdate - для обновления (все поля опциональные)
4. POST /users - создание с валидацией
5. GET /users/{id} - получение пользователя
6. PATCH /users/{id} - частичное обновление

**Требования:** использовать Field, validator, EmailStr, constr, model_validator

---

## Билет 9: FastAPI - Маршрутизация и APIRouter

### Теоретическая часть:

1. Что такое APIRouter и зачем он нужен?
2. Как работают префиксы и теги в роутерах?
3. Что такое dependencies в FastAPI?

### Практическая часть:

**Тестовые данные:**

```sql
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10,2),
    category VARCHAR(50)
);

CREATE TABLE reviews (
    id SERIAL PRIMARY KEY,
    product_id INTEGER REFERENCES products(id),
    rating INTEGER,
    comment TEXT
);

INSERT INTO products (name, price, category) VALUES
('Ноутбук', 50000, 'electronics'),
('Книга', 500, 'books'),
('Наушники', 3000, 'electronics');

INSERT INTO reviews (product_id, rating, comment) VALUES
(1, 5, 'Отличный товар'),
(1, 4, 'Хорошо'),
(3, 5, 'Супер звук');
```

**Задание:**
Создайте структуру с роутерами:

1. products_router.py:
   - GET /products - список товаров с фильтром по категории
   - GET /products/{id} - товар по ID
   - POST /products - создание товара
2. reviews_router.py:
   - GET /products/{product_id}/reviews - отзывы товара
   - POST /products/{product_id}/reviews - добавить отзыв
3. main.py - подключить роутеры с префиксами /api/v1/products и /api/v1/reviews
4. Добавить dependency для проверки существования товара
5. Добавить теги для документации

**Требования:** использовать APIRouter, prefix, tags, dependencies, include_router

---

## Билет 10: SQLAlchemy - Связи многие-ко-многим 

### Теоретическая часть:

1. Что такое связь многие-ко-многим (many-to-many) в SQLAlchemy?
2. Зачем нужна промежуточная таблица (association table)?
3. Разница между relationship с secondary и Table в SQLAlchemy?
4. Что такое back_populates в контексте many-to-many?

### Практическая часть:

**Тестовые данные:**

```sql
CREATE TABLE actors (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    birth_date DATE,
    nationality VARCHAR(50)
);

CREATE TABLE movies (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200),
    release_year INTEGER,
    genre VARCHAR(50),
    director VARCHAR(100)
);

CREATE TABLE actor_movie (
    actor_id INTEGER REFERENCES actors(id) ON DELETE CASCADE,
    movie_id INTEGER REFERENCES movies(id) ON DELETE CASCADE,
    role_name VARCHAR(100),
    PRIMARY KEY (actor_id, movie_id)
);

INSERT INTO actors (name, birth_date, nationality) VALUES
('Леонардо ДиКаприо', '1974-11-11', 'USA'),
('Кейт Уинслет', '1975-10-05', 'UK'),
('Том Хэнкс', '1956-07-09', 'USA'),
('Мэрил Стрип', '1949-06-22', 'USA');

INSERT INTO movies (title, release_year, genre, director) VALUES
('Титаник', 1997, 'drama', 'Джеймс Кэмерон'),
('Форрест Гамп', 1994, 'drama', 'Роберт Земекис'),
('Дьявол носит Prada', 2006, 'comedy', 'Дэвид Френкел');

INSERT INTO actor_movie (actor_id, movie_id, role_name) VALUES
(1, 1, 'Джек Доусон'),
(2, 1, 'Роза Дьюитт Бьюкейтер'),
(3, 2, 'Форрест Гамп'),
(1, 2, 'Бенджамин Баффет'),
(4, 3, 'Миранда Пристли'),
(2, 3, 'Эмили Чарлтон');
```

**Задание:**
Создайте модели SQLAlchemy:

1. Actor с relationship к Movie через промежуточную таблицу
2. Movie с relationship к Actor через промежуточную таблицу
3. Association table для связи с дополнительным полем role_name
4. Эндпоинт GET /actors/{id}/movies - список фильмов актера
5. Эндпоинт GET /movies/{id}/actors - список актеров фильма
6. Эндпоинт POST /movies/{movie_id}/actors/{actor_id} - добавить актера в фильм с указанием роли
7. Эндпоинт DELETE /movies/{movie_id}/actors/{actor_id} - удалить актера из фильма

**Требования:**

- Использовать relationship с параметром secondary
- Использовать Table для промежуточной таблицы
- Использовать back_populates для двусторонней связи
- Поддержка дополнительных полей в association table (role_name)
- Async SQLAlchemy
- Обработка ошибок (актер/фильм не найден, дублирование связи)

---

## Билет 11: PostgreSQL - Хранимые процедуры

### Теоретическая часть:

1. В чем разница между функцией (FUNCTION) и процедурой (PROCEDURE) в PostgreSQL?
2. Что такое транзакции в процедурах и как они работают?
3. Для чего используются параметры IN, OUT и INOUT в процедурах?

### Практическая часть:

**Тестовые данные:**

```sql
CREATE TABLE accounts (
    id SERIAL PRIMARY KEY,
    account_number VARCHAR(20) UNIQUE,
    balance DECIMAL(10,2) DEFAULT 0,
    owner_name VARCHAR(100)
);

CREATE TABLE transactions (
    id SERIAL PRIMARY KEY,
    from_account_id INTEGER REFERENCES accounts(id),
    to_account_id INTEGER REFERENCES accounts(id),
    amount DECIMAL(10,2),
    transaction_date TIMESTAMP DEFAULT NOW(),
    status VARCHAR(20)
);

INSERT INTO accounts (account_number, balance, owner_name) VALUES
('ACC001', 10000.00, 'Иванов Иван'),
('ACC002', 5000.00, 'Петров Петр'),
('ACC003', 15000.00, 'Сидорова Мария');
```

**Задание:**
Создайте хранимую процедуру `transfer_money`:

1. Параметры: `from_account VARCHAR`, `to_account VARCHAR`, `amount DECIMAL`
2. Логика:
   - Проверить существование обоих счетов
   - Проверить достаточность средств на счете отправителя
   - Выполнить перевод (уменьшить баланс отправителя, увеличить баланс получателя)
   - Создать запись в таблице transactions со статусом 'completed'
   - Если ошибка - откатить транзакцию и записать статус 'failed'
3. Использовать транзакции (BEGIN/COMMIT/ROLLBACK)
4. Обработать ошибки с помощью EXCEPTION

**Требования:**

- Использовать CREATE PROCEDURE
- Обработка ошибок через EXCEPTION
- Валидация входных данных
