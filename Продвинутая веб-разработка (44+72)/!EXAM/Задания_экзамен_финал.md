# Практические задания для экзамена

## Билет 1: FastAPI + SQLAlchemy - API для задач

### Теоретическая часть:


### Практическая часть:

**Тестовые данные:**
```sql
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200),
    description TEXT,
    status VARCHAR(20),
    user_id INTEGER,
    created_at TIMESTAMP DEFAULT NOW()
);

INSERT INTO tasks (title, description, status, user_id) VALUES
('Изучить FastAPI', 'Пройти документацию', 'done', 1),
('Настроить БД', 'PostgreSQL + SQLAlchemy', 'in_progress', 1),
('Написать тесты', 'Pytest для API', 'todo', 2),
('Деплой', 'Docker + CI/CD', 'todo', 2);
```

**Задание:**
Создайте REST API с эндпоинтами:
- GET /tasks - список задач с фильтром по статусу
- POST /tasks - создание задачи
- PUT /tasks/{id} - обновление статуса
- DELETE /tasks/{id} - удаление

**Требования:** async SQLAlchemy, Pydantic валидация, обработка ошибок

---

## Билет 2: PostgreSQL - Оконные функции для рейтинга

### Теоретическая часть:


### Практическая часть:

**Тестовые данные:**
```sql
CREATE TABLE students (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    subject VARCHAR(50),
    score INTEGER,
    exam_date DATE
);

INSERT INTO students (name, subject, score, exam_date) VALUES
('Иванов', 'Математика', 85, '2025-01-10'),
('Петров', 'Математика', 92, '2025-01-10'),
('Сидоров', 'Математика', 78, '2025-01-10'),
('Иванов', 'Физика', 88, '2025-01-11'),
('Петров', 'Физика', 95, '2025-01-11'),
('Сидоров', 'Физика', 82, '2025-01-11');
```

**Задание:**
Напишите запросы:
1. Ранг студента по баллам в каждом предмете (RANK)
2. Разница баллов с предыдущим студентом (LAG)
3. Средний балл по предмету и отклонение каждого студента
4. Топ-2 студента в каждом предмете

---

## Билет 3: PostgreSQL - Функция расчета скидки

### Теоретическая часть:

### Практическая часть:

**Тестовые данные:**
```sql
CREATE TABLE user_orders (
    user_id INTEGER,
    order_amount DECIMAL(10,2),
    order_date DATE
);

INSERT INTO user_orders VALUES
(1, 5000, '2025-01-01'),
(1, 8000, '2025-01-05'),
(1, 12000, '2025-01-10'),
(2, 3000, '2025-01-02'),
(2, 4000, '2025-01-08');
```

**Задание:**
Создайте функцию `get_discount(user_id INT, amount DECIMAL)`:
- Если сумма покупок > 20000 → скидка 10%
- Если сумма покупок > 10000 → скидка 5%
- Иначе → скидка 0%

Функция должна вернуть итоговую сумму со скидкой.

---

## Билет 4: PostgreSQL - Полнотекстовый поиск товаров

### Теоретическая часть:

### Практическая часть:

**Тестовые данные:**
```sql
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(200),
    description TEXT
);

INSERT INTO products (name, description) VALUES
('iPhone 15 Pro', 'Смартфон Apple с процессором A17'),
('Samsung Galaxy S24', 'Флагманский смартфон Samsung'),
('MacBook Pro', 'Ноутбук Apple для профессионалов'),
('Наушники AirPods', 'Беспроводные наушники Apple');
```

**Задание:**
1. Добавьте tsvector колонку для поиска
2. Создайте GIN индекс
3. Напишите запрос поиска по слову "Apple" с ранжированием
4. Добавьте подсветку найденных слов (ts_headline)

---

## Билет 5: Redis - Счетчик просмотров и кэш

### Теоретическая часть:

### Практическая часть:

**Задание:**
Реализуйте в FastAPI:
1. Эндпоинт GET /articles/{id} - возвращает статью
2. Кэширование статьи в Redis (TTL 5 минут)
3. Счетчик просмотров (INCR) для каждой статьи
4. Эндпоинт GET /articles/popular - топ-5 по просмотрам (ZSET)

**Тестовые данные:**
```python
articles = {
    1: {"title": "Python tips", "content": "..."},
    2: {"title": "FastAPI guide", "content": "..."},
    3: {"title": "Redis cache", "content": "..."}
}
```

---

## Билет 6: MongoDB - Агрегация заказов

### Теоретическая часть:

### Практическая часть:

**Тестовые данные:**
```javascript
db.orders.insertMany([
  {customer: "Иванов", items: [{name: "Товар1", price: 1000, qty: 2}], date: ISODate("2025-01-10")},
  {customer: "Петров", items: [{name: "Товар2", price: 500, qty: 3}], date: ISODate("2025-01-10")},
  {customer: "Иванов", items: [{name: "Товар1", price: 1000, qty: 1}], date: ISODate("2025-01-11")},
  {customer: "Сидоров", items: [{name: "Товар3", price: 2000, qty: 1}], date: ISODate("2025-01-11")}
])
```

**Задание:**
Напишите агрегации:
1. Общая сумма заказов по каждому клиенту
2. Средний чек по дням
3. Топ-3 товара по количеству продаж ($unwind)
4. Клиенты с суммой заказов > 2000

---

## Билет 7: MongoDB + FastAPI - API категорий

### Теоретическая часть:


### Практическая часть:

**Тестовые данные:**
```javascript
db.categories.insertMany([
  {name: "Электроника", products: ["Телефон", "Ноутбук"], count: 150},
  {name: "Одежда", products: ["Куртка", "Джинсы"], count: 320},
  {name: "Книги", products: ["Роман", "Учебник"], count: 89}
])
```

**Задание:**
Создайте API с Motor:
- GET /categories - список с пагинацией (skip, limit)
- GET /categories/{name} - поиск по имени
- POST /categories - создание категории
- PUT /categories/{id} - обновление count

---

## Билет 8: OpenSearch - Индекс для поиска статей

### Теоретическая часть:

### Практическая часть:

**Тестовые данные:**
```json
[
  {"title": "Python для начинающих", "content": "Основы языка Python", "views": 1500},
  {"title": "FastAPI tutorial", "content": "Создание API на FastAPI", "views": 2300},
  {"title": "PostgreSQL guide", "content": "Работа с PostgreSQL", "views": 890}
]
```

**Задание:**
1. Создайте индекс с mapping (title: text, content: text, views: integer)
2. Загрузите данные
3. Поиск по слову "Python" с фильтром views > 1000
4. Агрегация: средний views по результатам поиска

---

## Билет 9: OpenSearch + FastAPI - Поиск с фильтрами

### Теоретическая часть:

### Практическая часть:

**Задание:**
Создайте эндпоинт GET /search:
- Параметры: q (текст), min_views, max_views
- Bool query: must (текст), filter (диапазон views)
- Сортировка по релевантности и views
- Highlight для найденных слов

**Используйте данные из задания 8**

---

## Билет 10: FastAPI + GraphQL - API пользователей

### Теоретическая часть:


### Практическая часть:

**Тестовые данные:**
```sql
CREATE TABLE users (id SERIAL PRIMARY KEY, name VARCHAR(100), email VARCHAR(100));
CREATE TABLE posts (id SERIAL PRIMARY KEY, title VARCHAR(200), user_id INTEGER);

INSERT INTO users VALUES (1, 'Иван', 'ivan@mail.ru'), (2, 'Мария', 'maria@mail.ru');
INSERT INTO posts VALUES (1, 'Первый пост', 1), (2, 'Второй пост', 1), (3, 'Пост Марии', 2);
```

**Задание:**
Создайте GraphQL схему:
- Query: user(id), users, post(id)
- Mutation: createPost(title, userId)
- Nested: user { posts { title } }

---

## Билет 11: GraphQL Subscriptions - Чат

### Теоретическая часть:

### Практическая часть:

**Задание:**
Реализуйте:
1. Mutation sendMessage(room, text, user)
2. Subscription messageAdded(room) - новые сообщения в комнате
3. Query messages(room, limit) - история сообщений

**Тестовые данные:**
```python
messages = []  # in-memory хранилище
```

---

## Билет 12: FastAPI + PostgreSQL + Redis - Корзина

### Теоретическая часть:

### Практическая часть:

**Тестовые данные:**
```sql
CREATE TABLE products (id SERIAL PRIMARY KEY, name VARCHAR(100), price DECIMAL(10,2));
INSERT INTO products VALUES (1, 'Товар1', 1000), (2, 'Товар2', 1500), (3, 'Товар3', 2000);
```

**Задание:**
1. POST /cart/add - добавить товар в корзину (Redis Hash)
2. GET /cart/{user_id} - получить корзину
3. POST /cart/checkout - создать заказ в PostgreSQL, очистить корзину
4. GET /orders/{user_id} - история заказов

**Пояснения:**
- Корзина хранится в Redis как Hash: `cart:{user_id}` → {product_id: quantity}
- При checkout: начать транзакцию в PostgreSQL, создать заказ, удалить корзину из Redis
- Если транзакция не удалась - корзина остается в Redis

---

## Билет 13: PostgreSQL - Процедура отчета продаж

### Теоретическая часть:

### Практическая часть:

**Тестовые данные:**
```sql
CREATE TABLE sales (product_id INT, amount DECIMAL, sale_date DATE);
INSERT INTO sales VALUES
(1, 5000, '2025-01-10'), (2, 3000, '2025-01-10'),
(1, 4000, '2025-01-11'), (3, 8000, '2025-01-11');
```

**Задание:**
Создайте процедуру `daily_sales_report()`:
1. Рассчитывает сумму продаж по дням (оконная функция)
2. Ранг товаров по продажам
3. Сохраняет в таблицу reports
4. Возвращает количество записей

**Пояснения:**
- Используйте SUM() OVER (ORDER BY sale_date) для нарастающего итога
- RANK() OVER (PARTITION BY sale_date ORDER BY amount DESC) для ранжирования
- CREATE TABLE reports (sale_date DATE, product_id INT, total DECIMAL, rank INT)
- Процедура должна очищать старые данные перед вставкой

---

## Билет 14: MongoDB + Redis - Кэш агрегаций

### Теоретическая часть:


### Практическая часть:

**Тестовые данные:**
```javascript
db.sales.insertMany([
  {product: "A", category: "Electronics", amount: 5000},
  {product: "B", category: "Electronics", amount: 3000},
  {product: "C", category: "Books", amount: 1000}
])
```

**Задание:**
1. Агрегация: сумма продаж по категориям
2. Кэширование результата в Redis (TTL 10 минут)
3. Middleware: проверка кэша перед запросом к MongoDB
4. Инвалидация при добавлении новой продажи

**Пояснения:**
- Ключ кэша: `sales:by_category`
- Агрегация: `db.sales.aggregate([{$group: {_id: "$category", total: {$sum: "$amount"}}}])`
- Middleware проверяет Redis → если нет, запрос к MongoDB → сохранить в Redis
- При POST /sales - удалить ключ `sales:by_category` из Redis

---

## Билет 15: Docker Compose - Полный стек

### Теоретическая часть:

### Практическая часть:

**Задание:**
Создайте docker-compose.yml:
1. FastAPI приложение (порт 8000)
2. PostgreSQL (порт 5432)
3. Redis (порт 6379)
4. MongoDB (порт 27017)
5. Nginx как reverse proxy (порт 80)

**Требования:**
- Volumes для данных БД
- Healthcheck для всех сервисов
- Environment variables через .env
- Зависимости между сервисами (depends_on)
