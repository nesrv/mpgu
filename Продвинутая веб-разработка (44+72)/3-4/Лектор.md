# Комментарии лектора к презентации "Архитектуры высоконагруженных систем"

## Слайд 1: Титульный
Добро пожаловать на первое занятие по архитектурам высоконагруженных систем. Сегодня разберем основы сетевых протоколов и API - фундамент, без которого невозможно строить современные веб-приложения. Это не просто теория - вы будете использовать эти знания каждый день в работе.

## Слайд 2: Web-API
Web-API - это способ общения между клиентом и сервером через интернет. Представьте, что вы заказываете еду в ресторане - вы не идете на кухню, а говорите официанту что хотите. API работает так же: клиент запрашивает данные, сервер их возвращает. Существует несколько основных подходов: REST - самый популярный, используется в 65% проектов, GraphQL - для гибких запросов когда клиенту нужны разные наборы данных, SOAP - для корпоративных систем где критична безопасность и транзакции, gRPC - для высокой производительности в микросервисах. Каждый протокол решает свои задачи, и важно выбрать правильный инструмент.

## Слайд 3: Учебные вопросы
Сегодня пройдемся по базовым понятиям без лишней воды. Разберем модель OSI - она поможет понять, почему что-то не работает и где искать проблему. Изучим сетевые протоколы TCP и UDP - они обеспечивают передачу данных по сети. А также API-протоколы для построения веб-сервисов - это то, что вы будете использовать для создания своих приложений.

## Слайд 4: Модель OSI
Модель OSI - это 7 уровней абстракции сетевого взаимодействия. Это как слои в торте - каждый выполняет свою функцию. Зачем разработчику это знать? Во-первых, для дебаггинга - когда всё падает, нужно понять на каком уровне проблема. DNS не отвечает - это уровень 7 приложений, TCP соединение разорвалось - уровень 4 транспортный. Во-вторых, для выбора правильных инструментов - HTTP-библиотеки работают на уровне 7, сокеты на уровне 4. В-третьих, для оптимизации - переход с HTTP/1.1 на HTTP/2 дает прирост производительности за счет мультиплексирования. Когда всё упало, вы сможете сказать "Это не я, это DNS" или "Проблема на уровне TCP" - и это будет правда, а не отмазка.

## Слайд 5: Уровни OSI (таблица)
Давайте разберем каждый уровень подробнее. Уровень 7 Приложений - это HTTP, REST API, WebSockets - то, с чем вы работаете каждый день, когда пишете код. Уровень 6 Представления - SSL/TLS для шифрования трафика, JSON/XML для форматов данных - здесь данные преобразуются в понятный формат. Уровень 5 Сеансовый - управление сессиями, например WebSockets поддерживают постоянное соединение. Уровень 4 Транспортный - TCP и UDP, обеспечивают доставку данных от процесса к процессу. Уровень 3 Сетевой - IP-адресация и маршрутизация, здесь решается как пакет доберется от одного компьютера к другому. Уровни 2 и 1 - это уже железо: Ethernet, Wi-Fi, кабели, сигналы - физическая передача битов.

## Слайд 6: Мнемоника OSI
Как запомнить порядок уровней? Есть простая фраза сверху вниз: "Все Программисты Спят, Только Сетевые Калеки Фиксируют" - В это Приложений, П это Представления, С это Сеансовый, Т это Транспортный, С это Сетевой, К это Канальный, Ф это Физический. Или снизу вверх: "Физики Канают, Сетевики Транспортируют, Сеансы Представляют Приложения". Выберите что вам ближе и повторите несколько раз - это реально помогает на собеседованиях.

## Слайд 7: Примеры работы с уровнями
Давайте проверим понимание на практических примерах. Команда curl https://api.github.com - какой уровень? Правильно, уровень 7 - HTTP, мы работаем с готовым API. Команда telnet google.com 80 и отправка GET запроса - это уровень 4, работа с TCP напрямую, мы сами формируем HTTP-запрос. Команда ping 8.8.8.8 - уровень 3, протокол ICMP для проверки доступности хоста, здесь даже TCP не используется. Видите разницу? Чем ниже уровень, тем больше контроля, но и больше работы.

## Слайд 8: Типичные проблемы
Теперь о практике - типичные проблемы и где копать. "Connection refused" - порт закрыт на уровне 4 или сервер отклонил запрос на уровне 7, проверьте firewall и логи сервера. "SSL certificate failed" - проблема с сертификатом на уровне 6, возможно истек срок действия или неправильный домен. "Всё тормозит" - может быть маленький TCP-буфер на уровне 4 или забыли включить gzip на уровне 7, проверьте настройки сервера. "DNS resolution failed" - DNS не работает, это уровень 7, попробуйте другой DNS-сервер типа 8.8.8.8.

## Слайд 9: Кто на каких уровнях работает
Разные специалисты работают на разных уровнях OSI. Уровни 1-2 - это сетевые инженеры и сисадмины, они настраивают роутеры, свитчи, прокладывают кабели. Уровень 3 - сетевые инженеры настраивают маршрутизацию между сетями, DevOps работают с Kubernetes networking для связи контейнеров. Уровень 4 - backend-разработчики работают с сокетами для WebSocket или custom протоколов, DevOps настраивают балансировщики нагрузки. Уровни 5-6 - backend работает с сессиями и шифрованием данных, security-инженеры настраивают SSL/TLS сертификаты. Уровень 7 - это все разработчики: frontend делает HTTP-запросы, backend создает API, QA тестирует эндпоинты. DevOps и SRE работают на всех уровнях - от настройки сети до мониторинга приложений.

## Слайд 10: Вывод по OSI
Подведем итог по модели OSI. Уровни 1-2 - для системных программистов и сетевых инженеров, вы туда редко полезете. Уровни 3-7 - зона ответственности разработчика. Уровень 7 - HTTP-библиотеки типа requests, axios, fetch - это 99% ваших задач, просто делаете запросы. Уровень 4 - сокеты, когда нужен контроль над соединением для WebSocket или custom протоколов. Уровень 3 - низкоуровневые инструменты для диагностики типа ping, traceroute. Запомните: чем выше уровень, тем проще разработка, чем ниже - тем больше контроля.

## Слайд 11: Основные протоколы
Основные протоколы, с которыми вы будете работать ежедневно. HTTP/HTTPS - для веб-запросов и REST API, инструменты curl для командной строки, wget для скачивания файлов, библиотеки requests в Python, axios в JavaScript. WebSocket - для чатов, онлайн-игр, всего что работает в реальном времени и требует двустороннего общения, библиотеки Socket.io, ws. FTP/SFTP - для передачи файлов на сервер, используйте FileZilla с графическим интерфейсом или командную строку для автоматизации.

## Слайд 12: HTTP/HTTPS
HTTP работает на порту 80, данные передаются в открытом виде - это небезопасно, любой может перехватить трафик. HTTPS работает на порту 443, данные шифруются через SSL/TLS - это обязательный стандарт в 2025 году. Google понижает HTTP-сайты в поиске, браузеры Chrome и Firefox помечают их как "Небезопасные" красным значком, а HTTP/2 работает только поверх HTTPS. Плюс HTTP быстрее на миллисекунды, но это не оправдывает риски безопасности. Всегда используйте HTTPS, сертификаты можно получить бесплатно через Let's Encrypt.

## Слайд 13: WebSocket
WebSocket - это протокол полнодуплексной связи поверх TCP, то есть сервер и клиент могут отправлять данные друг другу одновременно. Не подходит для статического контента типа картинок и обычных REST API где клиент просто запрашивает данные. Идеален для чатов где сообщения приходят мгновенно, live-дашбордов с биржевыми котировками которые обновляются каждую секунду, многопользовательских редакторов типа Google Docs где изменения синхронизируются в реальном времени, игр в реальном времени где важна низкая задержка, стриминга данных от IoT-устройств типа GPS-трекеров.

## Слайд 14: WebSocket vs HTTP
Сравним WebSocket и HTTP по ключевым параметрам. WebSocket и��еет минимальную задержку потому что соединение постоянное, всего 2-14 байт на сообщение против 200-800 байт заголовков HTTP при каждом запросе. Сервер и клиент равноправны - оба могут инициировать отправку данных, в HTTP только клиент инициирует. Соединение постоянное - устанавливается один раз и живет долго, HTTP stateless - каждый запрос независим. Но настройка WebSocket сложнее, чем у HTTP - нужно обрабатывать разрывы соединения, реконнекты, heartbeat для проверки что соединение живо.

## Слайд 15: WebSocket vs UDP
WebSocket работает поверх TCP - это надежный транспорт с гарантией доставки каждого пакета и сохранением порядка сообщений. UDP - ненадежный, пакеты могут потеряться или прийти не по порядку, но быстрый потому что нет подтверждений. WebSocket - это протокол прикладного уровня поверх HTTP, UDP - транспортного уровня. WebSocket имеет встроенное управление потоком и контроль перегрузки через TCP, UDP этого не имеет. Выбор: WebSocket когда важна надежность и работа через браузер, UDP когда важна скорость и можно потерять пакеты типа видеостримов.

## Слайд 16: TCP vs UDP
TCP гарантирует доставку через подтверждения и повторную отправку, но медленнее из-за этих проверок. Используется для HTTP где важно получить все данные, FTP для передачи файлов, SSH для удаленного доступа. UDP ненадежный - отправил и забыл, но быстрый потому что нет накладных расходов. Используется для DNS где запрос короткий и можно повторить, стримов видео где потеря кадра не критична, игр где важна низкая задержка. TCP - как письмо с уведомлением о вручении, UDP - как крик в толпе, может кто-то услышит.

## Слайд 17: FTP vs SFTP
FTP - старый протокол 1971 года, разработан когда интернет был маленьким и все друг другу доверяли. SFTP - современный безопасный протокол, работает поверх SSH. Инструменты: FileZilla - графический клиент для Windows/Mac/Linux, командная строка sftp для автоматизации и скриптов, библиотеки paramiko в Python для программного доступа.

## Слайд 18: Ключевые различия FTP/SFTP
FTP передает пароли в открытом виде - это опасно, любой в сети может перехватить. Использует порт 21 для команд плюс отдельный случайный порт для данных - проблемы с firewall. Нет проверки целостности - файл может повредиться при передаче. SFTP шифрует всё через SSH включая пароли и данные, работает на порту 22 SSH - один порт для всего, проверяет целостность данных через хеши. FTP поддерживается для совместимости со старыми системами, но использовать опасно в 2025 году.

## Слайд 19: Рекомендация FTP/SFTP
FTP устаревший и опасный - избегайте для новых проектов. SFTP современный и безопасный - ваш выбор по умолчанию. В FileZilla просто смените тип соединения с FTP на SFTP в настройках сайта - всё остальное работает так же. Если сервер поддерживает только FTP, попросите администратора включить SFTP или используйте VPN для шифрования канала.

## Слайд 20: Как выбрать протокол
Для веб-API используйте HTTP/HTTPS - это 99% задач, простой и понятный. Для реального времени - WebSocket когда нужен постоянный коннект и двусторонняя связь. Для файлообмена - SFTP безопасная передача файлов на сервер. Для надежной передачи - TCP когда каждый байт важен и нельзя потерять данные. Для быстрой передачи стримов - UDP когда скорость важнее надежности. Для проверки доступности хоста - ICMP команда ping для диагностики сети.

## Слайд 21: Виды API
Посмотрим на связь API-протоколов и транспортных протоколов - это важно понимать. REST работает поверх HTTP/TCP, формат JSON, особенность - stateless каждый запрос независим и кэширование через HTTP-заголовки. GraphQL - тоже HTTP/TCP и JSON, но с гибкими запросами клиент сам выбирает какие поля нужны. SOAP - HTTP/TCP и XML, строгая типизация через WSDL схемы. gRPC - HTTP/2 и Protobuf бинарный формат, высокая скорость за счет сжатия. WebSocket - TCP напрямую, любой формат данных, реальное время. Webhook - HTTP/TCP и JSON для пуш-уведомлений когда сервер сам вызывает ваш API.

## Слайд 22: REST API
REST используется для публичных API типа GitHub, Twitter и CRUD-операций создание-чтение-обновление-удаление. Плюсы: простота понимания и использования, кеширование через HTTP-заголовки Cache-Control, поддержка браузерами можно тестировать прямо в адресной строке. Минусы: over-fetching получаете больше данных чем нужно, нет строгой типизации можно получить неожиданную структуру. Пример запроса: GET /api/users/1 возвращает пользователя. Стек протоколов снизу вверх: Физическая среда кабели → IP маршрутизация → TCP надежная доставка → HTTP/1.1 запросы-ответы → REST API логика приложения.

## Слайд 23: SOAP
SOAP используется в enterprise-системах, банках, госструктурах где критична надежность. Плюсы: безопасность через WS-Security стандарты, строгая типизация через WSDL схемы знаете что ожидать, ACID-транзакции можно откатить изменения. Минусы: сложность много XML и конфигурации, низкая производительность из-за размера сообщений. Стек: SOAP логика → HTTP или SMTP для передачи → TCP → IP → Физическая среда. Используйте когда работаете с банковскими API или государственными системами.

## Слайд 24: gRPC
gRPC для микросервисов и высоконагруженных систем где важна скорость. Плюсы: высокая скорость за счет бинарного формата Protobuf, поддержка потоков можно стримить данные в обе стороны. Минусы: сложная отладка нельзя просто посмотреть запрос в браузере, нет поддержки в браузерах нужен прокси. Стек: gRPC сервисы и методы → HTTP/2 мультиплексирование → TLS шифрование обязательно → TCP → IP. Используйте для внутренней коммуникации между сервисами где контролируете обе стороны.

## Слайд 25: GraphQL
GraphQL для сложных клиентов и динамических запросов когда разные экраны нужны разные данные. Плюсы: гибкость клиент запрашивает только нужные поля, единый эндпоинт обычно /graphql для всего API. Минусы: сложность кеширования нельзя использовать HTTP-кеш, N+1 проблема можно случайно сделать много запросов к БД. Стек: GraphQL гибкие запросы → HTTP/1.1 → TCP → IP → Физическая среда. Используйте когда у вас сложный фронтенд на React/Vue и требования к данным часто меняются.

## Слайд 26: Сравнение API
Сравним API по ключевым требованиям. Для публичного API подходят REST простота для потребителей и GraphQL гибкость запросов. Для высокой скорости - gRPC бинарный протокол. Для гибкости запросов - GraphQL клиент выбирает поля. Для безопасности - SOAP встроенные стандарты и gRPC обязательный TLS. Выбор зависит от ваших приоритетов и ограничений.

## Слайд 27: Выбор протокола по задаче
Статистика использования в реальных проектах. Веб-API для браузеров - REST или GraphQL, это 65% всего ПО потому что большинство приложений веб-ориентированные. Внутренняя коммуникация сервисов - gRPC, 15% микросервисы общаются между собой. Real-time уведомления - WebSocket, 8% чаты и live-обновления. Корпоративные системы - SOAP, 7% банки и госсектор. Высокочастотные данные - gRPC или WebSocket, 3% биржи и IoT. Простая интеграция - REST, 2% webhook и простые интеграции.

## Слайд 28: Практические кейсы
Для социальной сети используйте REST для фиксированных данных типа профиля или GraphQL для гибкости когда лента новостей требует разные данные. Для банковских транзакций - SOAP из-за безопасности встроенные стандарты и транзакций ACID гарантии. Для микросервисов - gRPC из-за скорости бинарный протокол и потоков стриминг данных между сервисами.

## Слайд 29: TCP-сервер
Как поднять простейший TCP-сервер на Python чтобы понять как это работает изнутри. Создаем сокет socket.socket для IPv4 AF_INET и TCP SOCK_STREAM. Привязываем к localhost:8080 через bind. Слушаем входящие соединения через listen с очередью 1. В бесконечном цикле принимаем клиента через accept это блокирующий вызов, читаем данные через recv до 1024 байт, отправляем HTTP-ответ через send, закрываем соединение через close. Ограничения: обрабатывает только одного клиента одновременно блокирующий, не парсит HTTP-заголовки и методы, всегда возвращает одно и то же, нет маршрутизации по URL.

## Слайд 30: Почему сокеты
Сокеты - это интерфейс к сетевому стеку операционной системы, API для работы с сетью. Стек снизу вверх: Сетевая карта физическая передача → IP маршрутизация пакетов → TCP/UDP надежность или скорость → Сокеты API для приложений → Приложение ваш Python код. Преимущества: абстракция скрывает сложность протоколов не нужно знать как работает TCP, стандартный API одинаковый для всех языков и ОС, прямой доступ минимальные накладные расходы, полный контроль можно настроить все параметры соединения таймауты буферы.

## Слайд 31: FastAPI vs aiohttp
FastAPI требует меньше кода благодаря автовалидации через Pydantic модели проверяются автоматически. Автодокументация Swagger UI из коробки не нужно писать документацию вручную. Type hints для IDE автодополнение и проверка типов. Меньше кода за счет декораторов просто @app.get вместо роутеров. aiohttp лучше когда нужен полный контроль над каждым аспектом, не только REST но и WebSocket статика, минимальные зависимости легкий фреймворк. Для большинства REST API выбирайте FastAPI, для сложных кастомных решений aiohttp.

## Слайд 32: RESTful vs GraphQL
REST требует много запросов для связанных данных - сначала GET /users/1 потом GET /users/1/posts потом GET /posts/1/comments три запроса. GraphQL позволяет получить всё одним запросом - в query указываете user posts comments вложенно. REST проще кешировать через HTTP-заголовки и отлаживать через curl или браузер. GraphQL более гибкий клиент выбирает поля, но сложнее в кешировании нужны специальные решения и отладке нужны специальные инструменты.

## Слайд 33: REST vs GraphQL - Идеальные сценарии 2025
REST идеален для публичных API Яндекс VK Сбер Тинькофф потому что простота для потребителей, микросервисной архитектуры каждый сервис управляет своим ресурсом, простых data-моделей где избыточная загрузка не проблема, когда критично HTTP-кеширование для CDN контентные сайты. GraphQL идеален для сложных клиентских приложений на React Vue Angular Flutter React Native где представления данных часто меняются, агрегации данных из множества источников GraphQL-шлюз как точка входа, мобильных приложений с ограниченным каналом связи экономия трафика, систем реального времени через Subscriptions push-обновления.

## Слайд 34: Тренды 2025 года
Гибридная архитектура BFF Backend For Frontend становится стандартом - GraphQL как шлюз перед микросервисами, несколько внутренних сервисов с REST или gRPC общаются с GraphQL который агрегирует данные для клиента. gRPC доминирует во внутренней коммуникации благодаря производительности, tRPC популярен в TypeScript-приложениях бесшовная типизация без CodeGen. API-сетка API Mesh позволяет управлять разными API через единую точку Apollo Federation Hasura. Фокус на Developer Experience улучшение инструментов OpenAPI для REST Apollo Studio для GraphQL.

## Слайд 35: REST(ful)
REST - это архитектурный стиль, определенный Роем Филдингом в 2000 году в диссертации. Характеристики RESTful API: использует HTTP и протокол клиент-сервер разделение ответственности, не имеет состояния stateless каждый запрос содержит всю информацию, кэшируема ответы можно кешировать через заголовки, основана на ресурсах URL представляют сущности не действия.

## Слайд 36: CRUD операции
CRUD - Create Read Update Delete базовые операции с данными. POST для создания новой записи возвращает 201 Created, GET для получения данных возвращает 200 OK, PUT для полной модификации заменяет всю запись, PATCH для частичной модификации обновляет только указанные поля, DELETE для удаления возвращает 204 No Content. Это стандартная семантика HTTP-методов.

## Слайд 37: Коды состояния HTTP
1xx информационные коды продолжение выполнения редко используются. 2xx успех операция выполнена 200 OK 201 Created 204 No Content. 3xx перенаправление нужны дополнительные действия 301 Moved Permanently 302 Found. 4xx ошибка клиента проблема в запросе 400 Bad Request 401 Unauthorized 404 Not Found. 5xx ошибка сервера проблема на сервере 500 Internal Server Error 503 Service Unavailable. Пасхалка: код 418 I'm a teapot шутка из RFC про чайник отказывается варить кофе.

## Слайд 38: Архитектура уровней
Типичная архитектура веб-приложения разделена на уровни. Веб-уровень ввод/вывод поверх HTTP обработка запросов маршрутизация валидация. Сервис бизнес-логика приложения обращения к уровню данных оркестрация операций. Данные доступ к хранилищам БД кеш файловая система. Модель определения данных классы структуры схемы общие для всех уровней. Разделение упрощает тестирование и поддержку.

## Слайд 39: Преимущества FastAPI
Высокая производительность работает так же быстро как Node.js и Go благодаря асинхронности. Ускоренная разработка в 2-3 раза быстрее без острых углов и странностей. Качество кода благодаря подсказкам типов и Pydantic моделям уменьшают ошибки на 40%. Автодокументация OpenAPI Swagger UI генерируется автоматически из кода не нужно писать вручную.

## Слайд 40: Технологии FastAPI
FastAPI построен на современных технологиях. Подсказки типов Python 3.6+ для поддержки IDE автодополнение и проверка. Starlette пакет для веб-машин включая асинхронность WebSocket middleware. Pydantic пакет для определения и проверки данных валидация сериализация. Специальная интеграция с SQLAlchemy для БД Celery для задач Jinja2 для шаблонов.
