# Комментарии лектора к презентации "Архитектуры высоконагруженных систем"

## Слайд 1: Титульный
**Что говорить:** Добро пожаловать на первое занятие по архитектурам высоконагруженных систем. Сегодня разберем основы сетевых протоколов и API - фундамент, без которого невозможно строить современные веб-приложения.

---

## Слайд 2: Web-API
**Комментарий:** Покажите анимацию с плавающими протоколами. Объясните, что API - это интерфейс для взаимодействия между системами.

**Что говорить:** Web-API - это способ общения между клиентом и сервером. Существует несколько основных подходов: REST (самый популярный), GraphQL (для гибких запросов), SOAP (для корпоративных систем) и gRPC (для высокой производительности). Каждый решает свои задачи.

---

## Слайд 3: Учебные вопросы
**Что говорить:** Сегодня пройдемся по базовым понятиям без лишней воды. Разберем модель OSI - она поможет понять, почему что-то не работает. Изучим сетевые протоколы TCP и UDP, а также API-протоколы для построения веб-сервисов.

---

## Слайд 4: Модель OSI
**Комментарий:** Покажите GIF с моделью OSI. Это ключевой слайд для понимания сетевой архитектуры.

**Что говорить:** Модель OSI - это 7 уровней абстракции сетевого взаимодействия. Зачем разработчику это знать? Во-первых, для дебаггинга - когда всё падает, нужно понять на каком уровне проблема. DNS не отвечает - это уровень 7, TCP соединение разорвалось - уровень 4. Во-вторых, для выбора правильных инструментов. В-третьих, для оптимизации - переход с HTTP/1.1 на HTTP/2 дает прирост производительности.

**Важно подчеркнуть:** Когда всё упало, вы сможете сказать "Это не я, это DNS" или "Проблема на уровне TCP".

---

## Слайд 5: Уровни OSI (таблица)
**Что говорить:** Давайте разберем каждый уровень. Уровень 7 (Приложений) - это HTTP, REST API, WebSockets - то, с чем вы работаете каждый день. Уровень 6 (Представления) - SSL/TLS для шифрования, JSON/XML для форматов данных. Уровень 5 (Сеансовый) - управление сессиями, например WebSockets. Уровень 4 (Транспортный) - TCP и UDP, обеспечивают доставку данных. Уровень 3 (Сетевой) - IP-адресация и маршрутизация. Уровни 2 и 1 - это уже железо: Ethernet, Wi-Fi, кабели.

---

## Слайд 6: Мнемоника OSI
**Комментарий:** Покажите второй GIF с OSI. Студенты любят мнемонические правила.

**Что говорить:** Как запомнить порядок уровней? Есть простая фраза: "Все Программисты Спят, Только Сетевые Калеки Фиксируют". Или снизу вверх: "Физики Канают, Сетевики Транспортируют, Сеансы Представляют Приложения". Выберите что вам ближе.

---

## Слайд 7: Примеры работы с уровнями
**Комментарий:** Интерактивный слайд с вопросами. Дайте студентам время подумать перед показом ответа.

**Что говорить:** Давайте проверим понимание. Команда `curl https://api.github.com` - какой уровень? Правильно, уровень 7 - HTTP. Команда `telnet google.com 80` - это уровень 4, работа с TCP напрямую. Команда `ping 8.8.8.8` - уровень 3, протокол ICMP для проверки доступности хоста.

---

## Слайд 8: Типичные проблемы
**Что говорить:** Теперь о практике. "Connection refused" - порт закрыт на уровне 4 или сервер отклонил запрос на уровне 7. "SSL certificate failed" - проблема с сертификатом на уровне 6. "Всё тормозит" - может быть маленький TCP-буфер на уровне 4 или забыли включить gzip на уровне 7. "DNS resolution failed" - DNS не работает, это уровень 7.

---

## Слайд 9: Кто на каких уровнях работает
**Что говорить:** Разные специалисты работают на разных уровнях. Уровни 1-2 - это сетевые инженеры и сисадмины, они настраивают железо. Уровень 3 - сетевые инженеры настраивают маршрутизацию, DevOps работают с Kubernetes networking. Уровень 4 - backend-разработчики работают с сокетами, DevOps настраивают балансировщики. Уровни 5-6 - backend работает с сессиями и шифрованием, security-инженеры настраивают SSL/TLS. Уровень 7 - это все разработчики: frontend, backend, QA. DevOps и SRE работают на всех уровнях.

---

## Слайд 10: Вывод по OSI
**Что говорить:** Подведем итог. Уровни 1-2 - для системных программистов. Уровни 3-7 - зона ответственности разработчика. Уровень 7 - HTTP-библиотеки, это 99% ваших задач. Уровень 4 - сокеты, когда нужен контроль. Уровень 3 - низкоуровневые инструменты для диагностики.

---

## Слайд 11: Основные протоколы
**Комментарий:** Покажите GIF с протоколами.

**Что говорить:** Основные протоколы, с которыми вы будете работать: HTTP/HTTPS - для веб-запросов и REST API, инструменты curl, wget. WebSocket - для чатов, онлайн-игр, всего что работает в реальном времени. FTP/SFTP - для передачи файлов, используйте FileZilla.

---

## Слайд 12: HTTP/HTTPS
**Что говорить:** HTTP работает на порту 80, данные передаются в открытом виде - это небезопасно. HTTPS работает на порту 443, данные шифруются - это обязательный стандарт. Google понижает HTTP-сайты в поиске, браузеры помечают их как небезопасные, а HTTP/2 работает только поверх HTTPS.

---

## Слайд 13: WebSocket
**Что говорить:** WebSocket - это протокол полнодуплексной связи поверх TCP. Не подходит для статического контента и обычных REST API. Идеален для чатов, live-дашбордов с биржевыми котировками, многопользовательских редакторов типа Google Docs, игр в реальном времени, стриминга данных от IoT-устройств.

---

## Слайд 14: WebSocket vs HTTP
**Что говорить:** Сравним WebSocket и HTTP. WebSocket имеет минимальную задержку, всего 2-14 байт на сообщение против 200-800 байт заголовков HTTP. Сервер и клиент равноправны - оба могут инициировать отправку. Соединение постоянное. Но настройка сложнее, чем у HTTP.

---

## Слайд 15: WebSocket vs UDP
**Что говорить:** WebSocket работает поверх TCP - это надежный транспорт с гарантией доставки и сохранением порядка. UDP - ненадежный, но быстрый. WebSocket - это протокол прикладного уровня, UDP - транспортного.

---

## Слайд 16: TCP vs UDP
**Что говорить:** TCP гарантирует доставку, но медленнее. Используется для HTTP, FTP, SSH. UDP ненадежный, но быстрый. Используется для DNS, стримов, игр. TCP - как письмо с уведомлением, UDP - как крик в толпе.

---

## Слайд 17: FTP vs SFTP
**Что говорить:** FTP - старый протокол 1971 года. SFTP - современный безопасный протокол. Инструменты: FileZilla, командная строка.

---

## Слайд 18: Ключевые различия FTP/SFTP
**Что говорить:** FTP передает пароли в открытом виде - это опасно. Использует порт 21 плюс отдельный порт для данных. Нет проверки целостности. SFTP шифрует всё через SSH, работает на порту 22, проверяет целостность данных. FTP поддерживается, но использовать опасно.

---

## Слайд 19: Рекомендация FTP/SFTP
**Что говорить:** FTP устаревший и опасный - избегайте. SFTP современный и безопасный - ваш выбор. В FileZilla просто смените тип соединения с FTP на SFTP.

---

## Слайд 20: Как выбрать протокол
**Что говорить:** Для веб-API используйте HTTP/HTTPS - это 99% задач. Для реального времени - WebSocket. Для файлообмена - SFTP. Для надежной передачи - TCP. Для быстрой передачи стримов - UDP. Для проверки доступности хоста - ICMP (ping).

---

## Слайд 21: Виды API
**Комментарий:** Покажите GIF с API и таблицу связи протоколов.

**Что говорить:** Посмотрим на связь API-протоколов и транспортных протоколов. REST работает поверх HTTP/TCP, формат JSON, особенность - stateless и кэширование. GraphQL - тоже HTTP/TCP и JSON, но с гибкими запросами. SOAP - HTTP/TCP и XML, строгая типизация. gRPC - HTTP/2 и Protobuf, высокая скорость. WebSocket - TCP, любой формат, реальное время. Webhook - HTTP/TCP и JSON для пуш-уведомлений.

---

## Слайд 22: REST API
**Комментарий:** Покажите стек протоколов справа.

**Что говорить:** REST используется для публичных API и CRUD-операций. Плюсы: простота, кеширование, поддержка браузерами. Минусы: over-fetching, нет строгой типизации. Пример запроса: GET /api/users/1. Стек протоколов: REST API → HTTP/1.1 → TCP → IP → Физическая среда.

---

## Слайд 23: SOAP
**Что говорить:** SOAP используется в enterprise-системах, банках, госструктурах. Плюсы: безопасность, строгая типизация, ACID-транзакции. Минусы: сложность, низкая производительность. Стек: SOAP → HTTP/SMTP → TCP → IP → Физическая среда.

---

## Слайд 24: gRPC
**Что говорить:** gRPC для микросервисов и высоконагруженных систем. Плюсы: высокая скорость, поддержка потоков. Минусы: сложная отладка, нет поддержки в браузерах. Стек: gRPC → HTTP/2 → TLS → TCP → IP.

---

## Слайд 25: GraphQL
**Что говорить:** GraphQL для сложных клиентов и динамических запросов. Плюсы: гибкость, единый эндпоинт. Минусы: сложность кеширования, N+1 проблема. Стек: GraphQL → HTTP/1.1 → TCP → IP → Физическая среда.

---

## Слайд 26: Сравнение API
**Что говорить:** Сравним API по требованиям. Для публичного API подходят REST и GraphQL. Для высокой скорости - gRPC. Для гибкости запросов - GraphQL. Для безопасности - SOAP и gRPC.

---

## Слайд 27: Выбор протокола по задаче
**Что говорить:** Веб-API для браузеров - REST или GraphQL, это 65% всего ПО. Внутренняя коммуникация сервисов - gRPC, 15%. Real-time уведомления - WebSocket, 8%. Корпоративные системы - SOAP, 7%. Высокочастотные данные - gRPC или WebSocket, 3%. Простая интеграция - REST, 2%.

---

## Слайд 28: Практические кейсы
**Что говорить:** Для социальной сети используйте REST для фиксированных данных или GraphQL для гибкости. Для банковских транзакций - SOAP из-за безопасности и транзакций. Для микросервисов - gRPC из-за скорости и потоков.

---

## Слайд 29: TCP-сервер
**Комментарий:** Разберите код построчно.

**Что говорить:** Как поднять простейший TCP-сервер на Python. Создаем сокет для IPv4 и TCP. Привязываем к localhost:8080. Слушаем входящие соединения. В цикле принимаем клиента, читаем данные, отправляем HTTP-ответ, закрываем соединение. Ограничения: обрабатывает только одного клиента, не парсит HTTP, нет маршрутизации.

---

## Слайд 30: Почему сокеты
**Что говорить:** Сокеты - это интерфейс к сетевому стеку ОС. Стек: Приложение → Сокеты → TCP/UDP → IP → Сетевая карта. Преимущества: абстракция скрывает сложность, стандартный API для всех языков, прямой доступ с минимальными накладными расходами, полный контроль над соединением.

---

## Слайд 31: FastAPI vs aiohttp
**Что говорить:** FastAPI требует меньше кода благодаря автовалидации через Pydantic. Автодокументация Swagger UI из коробки. Type hints для IDE. Меньше кода за счет декораторов. aiohttp лучше когда нужен полный контроль, не только REST, минимальные зависимости.

---

## Слайд 32: RESTful vs GraphQL
**Что говорить:** REST требует много запросов для связанных данных. GraphQL позволяет получить всё одним запросом. REST проще кешировать и отлаживать. GraphQL более гибкий, но сложнее в кешировании.

---

## Слайд 33: REST vs GraphQL - Идеальные сценарии 2025
**Комментарий:** Важный слайд с практическими рекомендациями.

**Что говорить:** REST идеален для публичных API (Яндекс, VK, Сбер), микросервисной архитектуры, простых data-моделей, когда критично HTTP-кеширование для CDN. GraphQL идеален для сложных клиентских приложений на React/Vue/Angular, агрегации данных из множества источников, мобильных приложений с ограниченным каналом, систем реального времени через Subscriptions.

---

## Слайд 34: Тренды 2025 года
**Что говорить:** Гибридная архитектура BFF становится стандартом - GraphQL как шлюз перед микросервисами. gRPC доминирует во внутренней коммуникации, tRPC популярен в TypeScript-приложениях. API-сетка позволяет управлять разными API через единую точку. Фокус на Developer Experience - улучшение инструментов для разработчиков.

---

## Слайд 35: REST(ful)
**Что говорить:** REST - это архитектурный стиль, определенный Роем Филдингом. Характеристики RESTful: использует HTTP и клиент-сервер, не имеет состояния (stateless), кэшируема, основана на ресурсах.

---

## Слайд 36: CRUD операции
**Что говорить:** CRUD - Create, Read, Update, Delete. POST для создания, GET для получения, PUT для полной модификации, PATCH для частичной модификации, DELETE для удаления.

---

## Слайд 37: Коды состояния HTTP
**Что говорить:** 1xx - информационные, продолжение выполнения. 2xx - успех. 3xx - перенаправление. 4xx - ошибка клиента. 5xx - ошибка сервера. Пасхалка: код 418 "I'm a teapot" - шутка из RFC.

---

## Слайд 38: Архитектура уровней
**Что говорить:** Веб-уровень - ввод/вывод поверх HTTP. Сервис - бизнес-логика, обращения к данным. Данные - доступ к хранилищам. Модель - определения данных, общие для всех уровней.

---

## Слайд 39: Преимущества FastAPI
**Что говорить:** Высокая производительность как у Node.js и Go. Ускоренная разработка без острых углов. Качество кода благодаря подсказкам типов. Автодокументация OpenAPI.

---

## Слайд 40: Технологии FastAPI
**Что говорить:** FastAPI построен на подсказках типов Python для поддержки IDE. Starlette - пакет для веб-машин с асинхронностью. Pydantic - для определения и проверки данных. Специальная интеграция с другими фреймворками.

---

## Общие рекомендации для лектора:

1. **Темп:** Не спешите, давайте студентам время на осмысление
2. **Интерактив:** На слайдах с вопросами делайте паузы, спрашивайте студентов
3. **Примеры:** Приводите реальные кейсы из практики
4. **Демонстрация:** Покажите curl-запросы в терминале вживую
5. **Вопросы:** После каждого блока спрашивайте "Есть вопросы?"
6. **Акценты:** Выделяйте голосом ключевые моменты (stateless, кеширование, безопасность)
7. **Юмор:** Используйте шутки из презентации ("Это не я, это DNS")
8. **Практика:** Обещайте практические задания на следующем занятии
